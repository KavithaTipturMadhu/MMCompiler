Args: /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/opt -debug --load /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/../lib/HyperOpCreationPass.so --HyperOpCreationPass -S ./Working/eicas_1.ll -o ./Working/eicas_1_HyOpPass.ll 

Features:
CPU:REDEFINE

Found cycles?0

-----------
Partitioning function:AssignFunction

-------
Acquiring bb entry
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then,if.end,
distance of if.then to exit 19
distance of if.end to exit 18

-------
Acquiring bb if.then
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end

distance of if.end to exit 18

-------
Acquiring bb if.end
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then3,if.end5,
distance of if.then3 to exit 17
distance of if.end5 to exit 16

-------
Acquiring bb if.then3
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end5

distance of if.end5 to exit 16

-------
Acquiring bb if.end5
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then9,lor.lhs.false,
distance of if.then9 to exit 14
distance of lor.lhs.false to exit 15

-------
Acquiring bb lor.lhs.false
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.then9
if.end11,
distance of if.then9 to exit 14
distance of if.end11 to exit 13

-------
Acquiring bb if.then9
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end11

distance of if.end11 to exit 13

-------
Acquiring bb if.end11
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then14,if.end16,
distance of if.then14 to exit 12
distance of if.end16 to exit 11

-------
Acquiring bb if.then14
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end16

distance of if.end16 to exit 11

-------
Acquiring bb if.end16
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then19,if.end21,
distance of if.then19 to exit 10
distance of if.end21 to exit 9

-------
Acquiring bb if.then19
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end21

distance of if.end21 to exit 9

-------
Acquiring bb if.end21
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then24,if.end26,
distance of if.then24 to exit 8
distance of if.end26 to exit 7

-------
Acquiring bb if.then24
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end26

distance of if.end26 to exit 7

-------
Acquiring bb if.end26
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then29,if.end31,
distance of if.then29 to exit 6
distance of if.end31 to exit 5

-------
Acquiring bb if.then29
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end31

distance of if.end31 to exit 5

-------
Acquiring bb if.end31
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then34,if.end36,
distance of if.then34 to exit 4
distance of if.end36 to exit 3

-------
Acquiring bb if.then34
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end36

distance of if.end36 to exit 3

-------
Acquiring bb if.end36
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:if.then39,if.end41,
distance of if.then39 to exit 2
distance of if.end41 to exit 1

-------
Acquiring bb if.then39
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:didn't add if.end41

distance of if.end41 to exit 1

-------
Acquiring bb if.end41
entered end hop for function AssignFunction
Adding basic blocks for traversal in a breadth biased order for function AssignFunction
added to succ list:
adding to creation map bbargs of size 1

-----------
Partitioning function:redefine_start

-------
Acquiring bb entry
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:newName0,
distance of newName0 to exit 1

-------
Acquiring bb newName0
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:newName01,
distance of newName01 to exit 1

-------
Acquiring bb newName01
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:
adding to creation map bbargs of size 3
before partitioning:; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

; Function Attrs: nounwind
define i32 @AssignFunction(i32* %sensors) #0 {
entry:
  %sensors.addr = alloca i32*, align 4
  store i32* %sensors, i32** %sensors.addr, align 4
  %0 = load i32** %sensors.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = load i32* %arrayidx, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* @eicas_discretes, align 4
  %or = or i32 %2, 1
  store i32 %or, i32* @eicas_discretes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32** %sensors.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %3, i32 1
  %4 = load i32* %arrayidx1, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i32* @eicas_discretes, align 4
  %or4 = or i32 %5, 2
  store i32 %or4, i32* @eicas_discretes, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32** %sensors.addr, align 4
  %arrayidx6 = getelementptr inbounds i32* %6, i32 2
  %7 = load i32* %arrayidx6, align 4
  %cmp = icmp sgt i32 %7, 250
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %8 = load i32** %sensors.addr, align 4
  %arrayidx7 = getelementptr inbounds i32* %8, i32 3
  %9 = load i32* %arrayidx7, align 4
  %cmp8 = icmp sgt i32 %9, 250
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %lor.lhs.false, %if.end5
  %10 = load i32* @eicas_discretes, align 4
  %or10 = or i32 %10, 4
  store i32 %or10, i32* @eicas_discretes, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %lor.lhs.false
  %11 = load i32** %sensors.addr, align 4
  %arrayidx12 = getelementptr inbounds i32* %11, i32 4
  %12 = load i32* %arrayidx12, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %13 = load i32* @eicas_discretes, align 4
  %or15 = or i32 %13, 16
  store i32 %or15, i32* @eicas_discretes, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end11
  %14 = load i32** %sensors.addr, align 4
  %arrayidx17 = getelementptr inbounds i32* %14, i32 5
  %15 = load i32* %arrayidx17, align 4
  %tobool18 = icmp ne i32 %15, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %16 = load i32* @eicas_discretes, align 4
  %or20 = or i32 %16, 32
  store i32 %or20, i32* @eicas_discretes, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16
  %17 = load i32** %sensors.addr, align 4
  %arrayidx22 = getelementptr inbounds i32* %17, i32 6
  %18 = load i32* %arrayidx22, align 4
  %tobool23 = icmp ne i32 %18, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %19 = load i32* @eicas_discretes, align 4
  %or25 = or i32 %19, 64
  store i32 %or25, i32* @eicas_discretes, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %20 = load i32** %sensors.addr, align 4
  %arrayidx27 = getelementptr inbounds i32* %20, i32 7
  %21 = load i32* %arrayidx27, align 4
  %tobool28 = icmp ne i32 %21, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %22 = load i32* @eicas_discretes, align 4
  %or30 = or i32 %22, 128
  store i32 %or30, i32* @eicas_discretes, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %23 = load i32** %sensors.addr, align 4
  %arrayidx32 = getelementptr inbounds i32* %23, i32 8
  %24 = load i32* %arrayidx32, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %25 = load i32* @eicas_discretes, align 4
  %or35 = or i32 %25, 256
  store i32 %or35, i32* @eicas_discretes, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %26 = load i32** %sensors.addr, align 4
  %arrayidx37 = getelementptr inbounds i32* %26, i32 9
  %27 = load i32* %arrayidx37, align 4
  %tobool38 = icmp ne i32 %27, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %28 = load i32* @eicas_discretes, align 4
  %or40 = or i32 %28, 512
  store i32 %or40, i32* @eicas_discretes, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %29 = load i32* @eicas_discretes, align 4
  ret i32 %29
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call i32 @AssignFunction(i32* %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  store i32 %call, i32* @redefine_out_eicas_discretes, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{}
-----------Creating HyperOps from partitioned functions-----------
added to traversallist:entry
added to traversallist:newName0
added to traversallist:newName01
now at func:entry

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:entry from parent:redefine_start
created func:redefine_start1
now at func:newName0
now at func:newName01

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:newName01 from parent:redefine_start
created func:redefine_start2
now at func:entry

-----------Creating a new HyperOp for function:AssignFunction-----------
newName0,
--------
Acquired bb:entry from parent:AssignFunction

--------
Acquired bb:if.then from parent:AssignFunction

--------
Acquired bb:if.end from parent:AssignFunction

--------
Acquired bb:if.then3 from parent:AssignFunction

--------
Acquired bb:if.end5 from parent:AssignFunction

--------
Acquired bb:lor.lhs.false from parent:AssignFunction

--------
Acquired bb:if.then9 from parent:AssignFunction

--------
Acquired bb:if.end11 from parent:AssignFunction

--------
Acquired bb:if.then14 from parent:AssignFunction

--------
Acquired bb:if.end16 from parent:AssignFunction

--------
Acquired bb:if.then19 from parent:AssignFunction

--------
Acquired bb:if.end21 from parent:AssignFunction

--------
Acquired bb:if.then24 from parent:AssignFunction

--------
Acquired bb:if.end26 from parent:AssignFunction

--------
Acquired bb:if.then29 from parent:AssignFunction

--------
Acquired bb:if.end31 from parent:AssignFunction

--------
Acquired bb:if.then34 from parent:AssignFunction

--------
Acquired bb:if.end36 from parent:AssignFunction

--------
Acquired bb:if.then39 from parent:AssignFunction

--------
Acquired bb:if.end41 from parent:AssignFunction

--------
Acquired bb:newName0 from parent:redefine_start
created func:AssignFunction3
before patching stuff:; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

; Function Attrs: nounwind
define i32 @AssignFunction(i32* %sensors) #0 {
entry:
  %sensors.addr = alloca i32*, align 4
  store i32* %sensors, i32** %sensors.addr, align 4
  %0 = load i32** %sensors.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = load i32* %arrayidx, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* @eicas_discretes, align 4
  %or = or i32 %2, 1
  store i32 %or, i32* @eicas_discretes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32** %sensors.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %3, i32 1
  %4 = load i32* %arrayidx1, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i32* @eicas_discretes, align 4
  %or4 = or i32 %5, 2
  store i32 %or4, i32* @eicas_discretes, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32** %sensors.addr, align 4
  %arrayidx6 = getelementptr inbounds i32* %6, i32 2
  %7 = load i32* %arrayidx6, align 4
  %cmp = icmp sgt i32 %7, 250
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %8 = load i32** %sensors.addr, align 4
  %arrayidx7 = getelementptr inbounds i32* %8, i32 3
  %9 = load i32* %arrayidx7, align 4
  %cmp8 = icmp sgt i32 %9, 250
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %lor.lhs.false, %if.end5
  %10 = load i32* @eicas_discretes, align 4
  %or10 = or i32 %10, 4
  store i32 %or10, i32* @eicas_discretes, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %lor.lhs.false
  %11 = load i32** %sensors.addr, align 4
  %arrayidx12 = getelementptr inbounds i32* %11, i32 4
  %12 = load i32* %arrayidx12, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %13 = load i32* @eicas_discretes, align 4
  %or15 = or i32 %13, 16
  store i32 %or15, i32* @eicas_discretes, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end11
  %14 = load i32** %sensors.addr, align 4
  %arrayidx17 = getelementptr inbounds i32* %14, i32 5
  %15 = load i32* %arrayidx17, align 4
  %tobool18 = icmp ne i32 %15, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %16 = load i32* @eicas_discretes, align 4
  %or20 = or i32 %16, 32
  store i32 %or20, i32* @eicas_discretes, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16
  %17 = load i32** %sensors.addr, align 4
  %arrayidx22 = getelementptr inbounds i32* %17, i32 6
  %18 = load i32* %arrayidx22, align 4
  %tobool23 = icmp ne i32 %18, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %19 = load i32* @eicas_discretes, align 4
  %or25 = or i32 %19, 64
  store i32 %or25, i32* @eicas_discretes, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %20 = load i32** %sensors.addr, align 4
  %arrayidx27 = getelementptr inbounds i32* %20, i32 7
  %21 = load i32* %arrayidx27, align 4
  %tobool28 = icmp ne i32 %21, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %22 = load i32* @eicas_discretes, align 4
  %or30 = or i32 %22, 128
  store i32 %or30, i32* @eicas_discretes, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %23 = load i32** %sensors.addr, align 4
  %arrayidx32 = getelementptr inbounds i32* %23, i32 8
  %24 = load i32* %arrayidx32, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %25 = load i32* @eicas_discretes, align 4
  %or35 = or i32 %25, 256
  store i32 %or35, i32* @eicas_discretes, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %26 = load i32** %sensors.addr, align 4
  %arrayidx37 = getelementptr inbounds i32* %26, i32 9
  %27 = load i32* %arrayidx37, align 4
  %tobool38 = icmp ne i32 %27, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %28 = load i32* @eicas_discretes, align 4
  %or40 = or i32 %28, 512
  store i32 %or40, i32* @eicas_discretes, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %29 = load i32* @eicas_discretes, align 4
  ret i32 %29
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call i32 @AssignFunction(i32* %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  store i32 %call, i32* @redefine_out_eicas_discretes, align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(i32 inreg) {
redefine_start2.newName01:
  store i32 %0, i32* @redefine_out_eicas_discretes, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @AssignFunction3(i32*) {
AssignFunction3.entry:
  %1 = alloca i32*, align 4
  store i32* %0, i32** %1, align 4
  %2 = load i32** %1, align 4
  %3 = getelementptr inbounds i32* %2, i32 0
  %4 = load i32* %3, align 4
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %AssignFunction3.if.then, label %AssignFunction3.if.end

AssignFunction3.if.then:                          ; preds = %AssignFunction3.entry
  %6 = load i32* @eicas_discretes, align 4
  %7 = or i32 %6, 1
  store i32 %7, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end

AssignFunction3.if.end:                           ; preds = %AssignFunction3.if.then, %AssignFunction3.entry
  %8 = load i32** %1, align 4
  %9 = getelementptr inbounds i32* %8, i32 1
  %10 = load i32* %9, align 4
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %AssignFunction3.if.then3, label %AssignFunction3.if.end5

AssignFunction3.if.then3:                         ; preds = %AssignFunction3.if.end
  %12 = load i32* @eicas_discretes, align 4
  %13 = or i32 %12, 2
  store i32 %13, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end5

AssignFunction3.if.end5:                          ; preds = %AssignFunction3.if.then3, %AssignFunction3.if.end
  %14 = load i32** %1, align 4
  %15 = getelementptr inbounds i32* %14, i32 2
  %16 = load i32* %15, align 4
  %17 = icmp sgt i32 %16, 250
  br i1 %17, label %AssignFunction3.if.then9, label %AssignFunction3.lor.lhs.false

AssignFunction3.lor.lhs.false:                    ; preds = %AssignFunction3.if.end5
  %18 = load i32** %1, align 4
  %19 = getelementptr inbounds i32* %18, i32 3
  %20 = load i32* %19, align 4
  %21 = icmp sgt i32 %20, 250
  br i1 %21, label %AssignFunction3.if.then9, label %AssignFunction3.if.end11

AssignFunction3.if.then9:                         ; preds = %AssignFunction3.lor.lhs.false, %AssignFunction3.if.end5
  %22 = load i32* @eicas_discretes, align 4
  %23 = or i32 %22, 4
  store i32 %23, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end11

AssignFunction3.if.end11:                         ; preds = %AssignFunction3.if.then9, %AssignFunction3.lor.lhs.false
  %24 = load i32** %1, align 4
  %25 = getelementptr inbounds i32* %24, i32 4
  %26 = load i32* %25, align 4
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %AssignFunction3.if.then14, label %AssignFunction3.if.end16

AssignFunction3.if.then14:                        ; preds = %AssignFunction3.if.end11
  %28 = load i32* @eicas_discretes, align 4
  %29 = or i32 %28, 16
  store i32 %29, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end16

AssignFunction3.if.end16:                         ; preds = %AssignFunction3.if.then14, %AssignFunction3.if.end11
  %30 = load i32** %1, align 4
  %31 = getelementptr inbounds i32* %30, i32 5
  %32 = load i32* %31, align 4
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %AssignFunction3.if.then19, label %AssignFunction3.if.end21

AssignFunction3.if.then19:                        ; preds = %AssignFunction3.if.end16
  %34 = load i32* @eicas_discretes, align 4
  %35 = or i32 %34, 32
  store i32 %35, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end21

AssignFunction3.if.end21:                         ; preds = %AssignFunction3.if.then19, %AssignFunction3.if.end16
  %36 = load i32** %1, align 4
  %37 = getelementptr inbounds i32* %36, i32 6
  %38 = load i32* %37, align 4
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %AssignFunction3.if.then24, label %AssignFunction3.if.end26

AssignFunction3.if.then24:                        ; preds = %AssignFunction3.if.end21
  %40 = load i32* @eicas_discretes, align 4
  %41 = or i32 %40, 64
  store i32 %41, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end26

AssignFunction3.if.end26:                         ; preds = %AssignFunction3.if.then24, %AssignFunction3.if.end21
  %42 = load i32** %1, align 4
  %43 = getelementptr inbounds i32* %42, i32 7
  %44 = load i32* %43, align 4
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %AssignFunction3.if.then29, label %AssignFunction3.if.end31

AssignFunction3.if.then29:                        ; preds = %AssignFunction3.if.end26
  %46 = load i32* @eicas_discretes, align 4
  %47 = or i32 %46, 128
  store i32 %47, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end31

AssignFunction3.if.end31:                         ; preds = %AssignFunction3.if.then29, %AssignFunction3.if.end26
  %48 = load i32** %1, align 4
  %49 = getelementptr inbounds i32* %48, i32 8
  %50 = load i32* %49, align 4
  %51 = icmp ne i32 %50, 0
  br i1 %51, label %AssignFunction3.if.then34, label %AssignFunction3.if.end36

AssignFunction3.if.then34:                        ; preds = %AssignFunction3.if.end31
  %52 = load i32* @eicas_discretes, align 4
  %53 = or i32 %52, 256
  store i32 %53, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end36

AssignFunction3.if.end36:                         ; preds = %AssignFunction3.if.then34, %AssignFunction3.if.end31
  %54 = load i32** %1, align 4
  %55 = getelementptr inbounds i32* %54, i32 9
  %56 = load i32* %55, align 4
  %57 = icmp ne i32 %56, 0
  br i1 %57, label %AssignFunction3.if.then39, label %AssignFunction3.if.end41

AssignFunction3.if.then39:                        ; preds = %AssignFunction3.if.end36
  %58 = load i32* @eicas_discretes, align 4
  %59 = or i32 %58, 512
  store i32 %59, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end41

AssignFunction3.if.end41:                         ; preds = %AssignFunction3.if.then39, %AssignFunction3.if.end36
  %60 = load i32* @eicas_discretes, align 4
  br label %AssignFunction3.return

AssignFunction3.return:                           ; preds = %AssignFunction3.if.end41
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (i32*)* @AssignFunction3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}

----------Adding dependences across created HyperOps----------

-----------Patching created function redefine_start1--------------
accumulated bbs:
entry,

----------Adding consumed by metadata----------

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function redefine_start1, module:; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

; Function Attrs: nounwind
define i32 @AssignFunction(i32* %sensors) #0 {
entry:
  %sensors.addr = alloca i32*, align 4
  store i32* %sensors, i32** %sensors.addr, align 4
  %0 = load i32** %sensors.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = load i32* %arrayidx, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* @eicas_discretes, align 4
  %or = or i32 %2, 1
  store i32 %or, i32* @eicas_discretes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32** %sensors.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %3, i32 1
  %4 = load i32* %arrayidx1, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i32* @eicas_discretes, align 4
  %or4 = or i32 %5, 2
  store i32 %or4, i32* @eicas_discretes, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32** %sensors.addr, align 4
  %arrayidx6 = getelementptr inbounds i32* %6, i32 2
  %7 = load i32* %arrayidx6, align 4
  %cmp = icmp sgt i32 %7, 250
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %8 = load i32** %sensors.addr, align 4
  %arrayidx7 = getelementptr inbounds i32* %8, i32 3
  %9 = load i32* %arrayidx7, align 4
  %cmp8 = icmp sgt i32 %9, 250
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %lor.lhs.false, %if.end5
  %10 = load i32* @eicas_discretes, align 4
  %or10 = or i32 %10, 4
  store i32 %or10, i32* @eicas_discretes, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %lor.lhs.false
  %11 = load i32** %sensors.addr, align 4
  %arrayidx12 = getelementptr inbounds i32* %11, i32 4
  %12 = load i32* %arrayidx12, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %13 = load i32* @eicas_discretes, align 4
  %or15 = or i32 %13, 16
  store i32 %or15, i32* @eicas_discretes, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end11
  %14 = load i32** %sensors.addr, align 4
  %arrayidx17 = getelementptr inbounds i32* %14, i32 5
  %15 = load i32* %arrayidx17, align 4
  %tobool18 = icmp ne i32 %15, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %16 = load i32* @eicas_discretes, align 4
  %or20 = or i32 %16, 32
  store i32 %or20, i32* @eicas_discretes, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16
  %17 = load i32** %sensors.addr, align 4
  %arrayidx22 = getelementptr inbounds i32* %17, i32 6
  %18 = load i32* %arrayidx22, align 4
  %tobool23 = icmp ne i32 %18, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %19 = load i32* @eicas_discretes, align 4
  %or25 = or i32 %19, 64
  store i32 %or25, i32* @eicas_discretes, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %20 = load i32** %sensors.addr, align 4
  %arrayidx27 = getelementptr inbounds i32* %20, i32 7
  %21 = load i32* %arrayidx27, align 4
  %tobool28 = icmp ne i32 %21, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %22 = load i32* @eicas_discretes, align 4
  %or30 = or i32 %22, 128
  store i32 %or30, i32* @eicas_discretes, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %23 = load i32** %sensors.addr, align 4
  %arrayidx32 = getelementptr inbounds i32* %23, i32 8
  %24 = load i32* %arrayidx32, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %25 = load i32* @eicas_discretes, align 4
  %or35 = or i32 %25, 256
  store i32 %or35, i32* @eicas_discretes, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %26 = load i32** %sensors.addr, align 4
  %arrayidx37 = getelementptr inbounds i32* %26, i32 9
  %27 = load i32* %arrayidx37, align 4
  %tobool38 = icmp ne i32 %27, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %28 = load i32* @eicas_discretes, align 4
  %or40 = or i32 %28, 512
  store i32 %or40, i32* @eicas_discretes, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %29 = load i32* @eicas_discretes, align 4
  ret i32 %29
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call i32 @AssignFunction(i32* %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  store i32 %call, i32* @redefine_out_eicas_discretes, align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(i32 inreg) {
redefine_start2.newName01:
  store i32 %0, i32* @redefine_out_eicas_discretes, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @AssignFunction3(i32*) {
AssignFunction3.entry:
  %1 = alloca i32*, align 4
  store i32* %0, i32** %1, align 4
  %2 = load i32** %1, align 4
  %3 = getelementptr inbounds i32* %2, i32 0
  %4 = load i32* %3, align 4
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %AssignFunction3.if.then, label %AssignFunction3.if.end

AssignFunction3.if.then:                          ; preds = %AssignFunction3.entry
  %6 = load i32* @eicas_discretes, align 4
  %7 = or i32 %6, 1
  store i32 %7, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end

AssignFunction3.if.end:                           ; preds = %AssignFunction3.if.then, %AssignFunction3.entry
  %8 = load i32** %1, align 4
  %9 = getelementptr inbounds i32* %8, i32 1
  %10 = load i32* %9, align 4
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %AssignFunction3.if.then3, label %AssignFunction3.if.end5

AssignFunction3.if.then3:                         ; preds = %AssignFunction3.if.end
  %12 = load i32* @eicas_discretes, align 4
  %13 = or i32 %12, 2
  store i32 %13, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end5

AssignFunction3.if.end5:                          ; preds = %AssignFunction3.if.then3, %AssignFunction3.if.end
  %14 = load i32** %1, align 4
  %15 = getelementptr inbounds i32* %14, i32 2
  %16 = load i32* %15, align 4
  %17 = icmp sgt i32 %16, 250
  br i1 %17, label %AssignFunction3.if.then9, label %AssignFunction3.lor.lhs.false

AssignFunction3.lor.lhs.false:                    ; preds = %AssignFunction3.if.end5
  %18 = load i32** %1, align 4
  %19 = getelementptr inbounds i32* %18, i32 3
  %20 = load i32* %19, align 4
  %21 = icmp sgt i32 %20, 250
  br i1 %21, label %AssignFunction3.if.then9, label %AssignFunction3.if.end11

AssignFunction3.if.then9:                         ; preds = %AssignFunction3.lor.lhs.false, %AssignFunction3.if.end5
  %22 = load i32* @eicas_discretes, align 4
  %23 = or i32 %22, 4
  store i32 %23, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end11

AssignFunction3.if.end11:                         ; preds = %AssignFunction3.if.then9, %AssignFunction3.lor.lhs.false
  %24 = load i32** %1, align 4
  %25 = getelementptr inbounds i32* %24, i32 4
  %26 = load i32* %25, align 4
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %AssignFunction3.if.then14, label %AssignFunction3.if.end16

AssignFunction3.if.then14:                        ; preds = %AssignFunction3.if.end11
  %28 = load i32* @eicas_discretes, align 4
  %29 = or i32 %28, 16
  store i32 %29, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end16

AssignFunction3.if.end16:                         ; preds = %AssignFunction3.if.then14, %AssignFunction3.if.end11
  %30 = load i32** %1, align 4
  %31 = getelementptr inbounds i32* %30, i32 5
  %32 = load i32* %31, align 4
  %33 = icmp ne i32 %32, 0
  br i1 %33, label %AssignFunction3.if.then19, label %AssignFunction3.if.end21

AssignFunction3.if.then19:                        ; preds = %AssignFunction3.if.end16
  %34 = load i32* @eicas_discretes, align 4
  %35 = or i32 %34, 32
  store i32 %35, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end21

AssignFunction3.if.end21:                         ; preds = %AssignFunction3.if.then19, %AssignFunction3.if.end16
  %36 = load i32** %1, align 4
  %37 = getelementptr inbounds i32* %36, i32 6
  %38 = load i32* %37, align 4
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %AssignFunction3.if.then24, label %AssignFunction3.if.end26

AssignFunction3.if.then24:                        ; preds = %AssignFunction3.if.end21
  %40 = load i32* @eicas_discretes, align 4
  %41 = or i32 %40, 64
  store i32 %41, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end26

AssignFunction3.if.end26:                         ; preds = %AssignFunction3.if.then24, %AssignFunction3.if.end21
  %42 = load i32** %1, align 4
  %43 = getelementptr inbounds i32* %42, i32 7
  %44 = load i32* %43, align 4
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %AssignFunction3.if.then29, label %AssignFunction3.if.end31

AssignFunction3.if.then29:                        ; preds = %AssignFunction3.if.end26
  %46 = load i32* @eicas_discretes, align 4
  %47 = or i32 %46, 128
  store i32 %47, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end31

AssignFunction3.if.end31:                         ; preds = %AssignFunction3.if.then29, %AssignFunction3.if.end26
  %48 = load i32** %1, align 4
  %49 = getelementptr inbounds i32* %48, i32 8
  %50 = load i32* %49, align 4
  %51 = icmp ne i32 %50, 0
  br i1 %51, label %AssignFunction3.if.then34, label %AssignFunction3.if.end36

AssignFunction3.if.then34:                        ; preds = %AssignFunction3.if.end31
  %52 = load i32* @eicas_discretes, align 4
  %53 = or i32 %52, 256
  store i32 %53, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end36

AssignFunction3.if.end36:                         ; preds = %AssignFunction3.if.then34, %AssignFunction3.if.end31
  %54 = load i32** %1, align 4
  %55 = getelementptr inbounds i32* %54, i32 9
  %56 = load i32* %55, align 4
  %57 = icmp ne i32 %56, 0
  br i1 %57, label %AssignFunction3.if.then39, label %AssignFunction3.if.end41

AssignFunction3.if.then39:                        ; preds = %AssignFunction3.if.end36
  %58 = load i32* @eicas_discretes, align 4
  %59 = or i32 %58, 512
  store i32 %59, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end41

AssignFunction3.if.end41:                         ; preds = %AssignFunction3.if.then39, %AssignFunction3.if.end36
  %60 = load i32* @eicas_discretes, align 4
  br label %AssignFunction3.return

AssignFunction3.return:                           ; preds = %AssignFunction3.if.end41
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (i32*)* @AssignFunction3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}

-----------Patching created function redefine_start2--------------
accumulated bbs:
newName01,

----------Adding consumed by metadata----------
  %call = call i32 @AssignFunction(i32* %2)
cloned inst second:  %29 = load i32* @eicas_discretes, align 4
producer function:AssignFunction3
how many clones?1
added metadata on instruction that belongs to parent AssignFunction3 and is mapped to slot 0 when the function has 1 and is of type:0:  %1 = alloca i32, align 4, !ConsumedBy !6

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function redefine_start2, module:; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

; Function Attrs: nounwind
define i32 @AssignFunction(i32* %sensors) #0 {
entry:
  %sensors.addr = alloca i32*, align 4
  store i32* %sensors, i32** %sensors.addr, align 4
  %0 = load i32** %sensors.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = load i32* %arrayidx, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* @eicas_discretes, align 4
  %or = or i32 %2, 1
  store i32 %or, i32* @eicas_discretes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32** %sensors.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %3, i32 1
  %4 = load i32* %arrayidx1, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i32* @eicas_discretes, align 4
  %or4 = or i32 %5, 2
  store i32 %or4, i32* @eicas_discretes, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32** %sensors.addr, align 4
  %arrayidx6 = getelementptr inbounds i32* %6, i32 2
  %7 = load i32* %arrayidx6, align 4
  %cmp = icmp sgt i32 %7, 250
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %8 = load i32** %sensors.addr, align 4
  %arrayidx7 = getelementptr inbounds i32* %8, i32 3
  %9 = load i32* %arrayidx7, align 4
  %cmp8 = icmp sgt i32 %9, 250
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %lor.lhs.false, %if.end5
  %10 = load i32* @eicas_discretes, align 4
  %or10 = or i32 %10, 4
  store i32 %or10, i32* @eicas_discretes, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %lor.lhs.false
  %11 = load i32** %sensors.addr, align 4
  %arrayidx12 = getelementptr inbounds i32* %11, i32 4
  %12 = load i32* %arrayidx12, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %13 = load i32* @eicas_discretes, align 4
  %or15 = or i32 %13, 16
  store i32 %or15, i32* @eicas_discretes, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end11
  %14 = load i32** %sensors.addr, align 4
  %arrayidx17 = getelementptr inbounds i32* %14, i32 5
  %15 = load i32* %arrayidx17, align 4
  %tobool18 = icmp ne i32 %15, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %16 = load i32* @eicas_discretes, align 4
  %or20 = or i32 %16, 32
  store i32 %or20, i32* @eicas_discretes, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16
  %17 = load i32** %sensors.addr, align 4
  %arrayidx22 = getelementptr inbounds i32* %17, i32 6
  %18 = load i32* %arrayidx22, align 4
  %tobool23 = icmp ne i32 %18, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %19 = load i32* @eicas_discretes, align 4
  %or25 = or i32 %19, 64
  store i32 %or25, i32* @eicas_discretes, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %20 = load i32** %sensors.addr, align 4
  %arrayidx27 = getelementptr inbounds i32* %20, i32 7
  %21 = load i32* %arrayidx27, align 4
  %tobool28 = icmp ne i32 %21, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %22 = load i32* @eicas_discretes, align 4
  %or30 = or i32 %22, 128
  store i32 %or30, i32* @eicas_discretes, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %23 = load i32** %sensors.addr, align 4
  %arrayidx32 = getelementptr inbounds i32* %23, i32 8
  %24 = load i32* %arrayidx32, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %25 = load i32* @eicas_discretes, align 4
  %or35 = or i32 %25, 256
  store i32 %or35, i32* @eicas_discretes, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %26 = load i32** %sensors.addr, align 4
  %arrayidx37 = getelementptr inbounds i32* %26, i32 9
  %27 = load i32* %arrayidx37, align 4
  %tobool38 = icmp ne i32 %27, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %28 = load i32* @eicas_discretes, align 4
  %or40 = or i32 %28, 512
  store i32 %or40, i32* @eicas_discretes, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %29 = load i32* @eicas_discretes, align 4
  ret i32 %29
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call i32 @AssignFunction(i32* %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  store i32 %call, i32* @redefine_out_eicas_discretes, align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(i32 inreg) {
redefine_start2.newName01:
  store i32 %0, i32* @redefine_out_eicas_discretes, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @AssignFunction3(i32*) {
AssignFunction3.entry:
  %1 = alloca i32, align 4, !ConsumedBy !6
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 0
  %5 = load i32* %4, align 4
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %AssignFunction3.if.then, label %AssignFunction3.if.end

AssignFunction3.if.then:                          ; preds = %AssignFunction3.entry
  %7 = load i32* @eicas_discretes, align 4
  %8 = or i32 %7, 1
  store i32 %8, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end

AssignFunction3.if.end:                           ; preds = %AssignFunction3.if.then, %AssignFunction3.entry
  %9 = load i32** %2, align 4
  %10 = getelementptr inbounds i32* %9, i32 1
  %11 = load i32* %10, align 4
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %AssignFunction3.if.then3, label %AssignFunction3.if.end5

AssignFunction3.if.then3:                         ; preds = %AssignFunction3.if.end
  %13 = load i32* @eicas_discretes, align 4
  %14 = or i32 %13, 2
  store i32 %14, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end5

AssignFunction3.if.end5:                          ; preds = %AssignFunction3.if.then3, %AssignFunction3.if.end
  %15 = load i32** %2, align 4
  %16 = getelementptr inbounds i32* %15, i32 2
  %17 = load i32* %16, align 4
  %18 = icmp sgt i32 %17, 250
  br i1 %18, label %AssignFunction3.if.then9, label %AssignFunction3.lor.lhs.false

AssignFunction3.lor.lhs.false:                    ; preds = %AssignFunction3.if.end5
  %19 = load i32** %2, align 4
  %20 = getelementptr inbounds i32* %19, i32 3
  %21 = load i32* %20, align 4
  %22 = icmp sgt i32 %21, 250
  br i1 %22, label %AssignFunction3.if.then9, label %AssignFunction3.if.end11

AssignFunction3.if.then9:                         ; preds = %AssignFunction3.lor.lhs.false, %AssignFunction3.if.end5
  %23 = load i32* @eicas_discretes, align 4
  %24 = or i32 %23, 4
  store i32 %24, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end11

AssignFunction3.if.end11:                         ; preds = %AssignFunction3.if.then9, %AssignFunction3.lor.lhs.false
  %25 = load i32** %2, align 4
  %26 = getelementptr inbounds i32* %25, i32 4
  %27 = load i32* %26, align 4
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %AssignFunction3.if.then14, label %AssignFunction3.if.end16

AssignFunction3.if.then14:                        ; preds = %AssignFunction3.if.end11
  %29 = load i32* @eicas_discretes, align 4
  %30 = or i32 %29, 16
  store i32 %30, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end16

AssignFunction3.if.end16:                         ; preds = %AssignFunction3.if.then14, %AssignFunction3.if.end11
  %31 = load i32** %2, align 4
  %32 = getelementptr inbounds i32* %31, i32 5
  %33 = load i32* %32, align 4
  %34 = icmp ne i32 %33, 0
  br i1 %34, label %AssignFunction3.if.then19, label %AssignFunction3.if.end21

AssignFunction3.if.then19:                        ; preds = %AssignFunction3.if.end16
  %35 = load i32* @eicas_discretes, align 4
  %36 = or i32 %35, 32
  store i32 %36, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end21

AssignFunction3.if.end21:                         ; preds = %AssignFunction3.if.then19, %AssignFunction3.if.end16
  %37 = load i32** %2, align 4
  %38 = getelementptr inbounds i32* %37, i32 6
  %39 = load i32* %38, align 4
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %AssignFunction3.if.then24, label %AssignFunction3.if.end26

AssignFunction3.if.then24:                        ; preds = %AssignFunction3.if.end21
  %41 = load i32* @eicas_discretes, align 4
  %42 = or i32 %41, 64
  store i32 %42, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end26

AssignFunction3.if.end26:                         ; preds = %AssignFunction3.if.then24, %AssignFunction3.if.end21
  %43 = load i32** %2, align 4
  %44 = getelementptr inbounds i32* %43, i32 7
  %45 = load i32* %44, align 4
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %AssignFunction3.if.then29, label %AssignFunction3.if.end31

AssignFunction3.if.then29:                        ; preds = %AssignFunction3.if.end26
  %47 = load i32* @eicas_discretes, align 4
  %48 = or i32 %47, 128
  store i32 %48, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end31

AssignFunction3.if.end31:                         ; preds = %AssignFunction3.if.then29, %AssignFunction3.if.end26
  %49 = load i32** %2, align 4
  %50 = getelementptr inbounds i32* %49, i32 8
  %51 = load i32* %50, align 4
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %AssignFunction3.if.then34, label %AssignFunction3.if.end36

AssignFunction3.if.then34:                        ; preds = %AssignFunction3.if.end31
  %53 = load i32* @eicas_discretes, align 4
  %54 = or i32 %53, 256
  store i32 %54, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end36

AssignFunction3.if.end36:                         ; preds = %AssignFunction3.if.then34, %AssignFunction3.if.end31
  %55 = load i32** %2, align 4
  %56 = getelementptr inbounds i32* %55, i32 9
  %57 = load i32* %56, align 4
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %AssignFunction3.if.then39, label %AssignFunction3.if.end41

AssignFunction3.if.then39:                        ; preds = %AssignFunction3.if.end36
  %59 = load i32* @eicas_discretes, align 4
  %60 = or i32 %59, 512
  store i32 %60, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end41

AssignFunction3.if.end41:                         ; preds = %AssignFunction3.if.then39, %AssignFunction3.if.end36
  %61 = load i32* @eicas_discretes, align 4
  store i32 %61, i32* %1, align 4
  br label %AssignFunction3.return

AssignFunction3.return:                           ; preds = %AssignFunction3.if.end41
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (i32*)* @AssignFunction3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !7}
!7 = metadata !{metadata !2, metadata !"Scalar", i32 0}

-----------Patching created function AssignFunction3--------------
accumulated bbs:
entry,if.then,if.end,if.then3,if.end5,lor.lhs.false,if.then9,if.end11,if.then14,if.end16,if.then19,if.end21,if.then24,if.end26,if.then29,if.end31,if.then34,if.end36,if.then39,if.end41,

----------Adding consumed by metadata----------
cloned inst second:  %1 = alloca i32*, align 4
producer function:redefine_start1
how many clones?1
added metadata on instruction that belongs to parent redefine_start1 and is mapped to slot 0 when the function has 1 and is of type:1:  %1 = alloca i32*, align 4, !ConsumedBy !6

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??1

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function AssignFunction3, module:; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

; Function Attrs: nounwind
define i32 @AssignFunction(i32* %sensors) #0 {
entry:
  %sensors.addr = alloca i32*, align 4
  store i32* %sensors, i32** %sensors.addr, align 4
  %0 = load i32** %sensors.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = load i32* %arrayidx, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* @eicas_discretes, align 4
  %or = or i32 %2, 1
  store i32 %or, i32* @eicas_discretes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32** %sensors.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %3, i32 1
  %4 = load i32* %arrayidx1, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i32* @eicas_discretes, align 4
  %or4 = or i32 %5, 2
  store i32 %or4, i32* @eicas_discretes, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32** %sensors.addr, align 4
  %arrayidx6 = getelementptr inbounds i32* %6, i32 2
  %7 = load i32* %arrayidx6, align 4
  %cmp = icmp sgt i32 %7, 250
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %8 = load i32** %sensors.addr, align 4
  %arrayidx7 = getelementptr inbounds i32* %8, i32 3
  %9 = load i32* %arrayidx7, align 4
  %cmp8 = icmp sgt i32 %9, 250
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %lor.lhs.false, %if.end5
  %10 = load i32* @eicas_discretes, align 4
  %or10 = or i32 %10, 4
  store i32 %or10, i32* @eicas_discretes, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %lor.lhs.false
  %11 = load i32** %sensors.addr, align 4
  %arrayidx12 = getelementptr inbounds i32* %11, i32 4
  %12 = load i32* %arrayidx12, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %13 = load i32* @eicas_discretes, align 4
  %or15 = or i32 %13, 16
  store i32 %or15, i32* @eicas_discretes, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end11
  %14 = load i32** %sensors.addr, align 4
  %arrayidx17 = getelementptr inbounds i32* %14, i32 5
  %15 = load i32* %arrayidx17, align 4
  %tobool18 = icmp ne i32 %15, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %16 = load i32* @eicas_discretes, align 4
  %or20 = or i32 %16, 32
  store i32 %or20, i32* @eicas_discretes, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16
  %17 = load i32** %sensors.addr, align 4
  %arrayidx22 = getelementptr inbounds i32* %17, i32 6
  %18 = load i32* %arrayidx22, align 4
  %tobool23 = icmp ne i32 %18, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %19 = load i32* @eicas_discretes, align 4
  %or25 = or i32 %19, 64
  store i32 %or25, i32* @eicas_discretes, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %20 = load i32** %sensors.addr, align 4
  %arrayidx27 = getelementptr inbounds i32* %20, i32 7
  %21 = load i32* %arrayidx27, align 4
  %tobool28 = icmp ne i32 %21, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %22 = load i32* @eicas_discretes, align 4
  %or30 = or i32 %22, 128
  store i32 %or30, i32* @eicas_discretes, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %23 = load i32** %sensors.addr, align 4
  %arrayidx32 = getelementptr inbounds i32* %23, i32 8
  %24 = load i32* %arrayidx32, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %25 = load i32* @eicas_discretes, align 4
  %or35 = or i32 %25, 256
  store i32 %or35, i32* @eicas_discretes, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %26 = load i32** %sensors.addr, align 4
  %arrayidx37 = getelementptr inbounds i32* %26, i32 9
  %27 = load i32* %arrayidx37, align 4
  %tobool38 = icmp ne i32 %27, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %28 = load i32* @eicas_discretes, align 4
  %or40 = or i32 %28, 512
  store i32 %or40, i32* @eicas_discretes, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %29 = load i32* @eicas_discretes, align 4
  ret i32 %29
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call i32 @AssignFunction(i32* %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  store i32 %call, i32* @redefine_out_eicas_discretes, align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4, !ConsumedBy !6
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(i32 inreg) {
redefine_start2.newName01:
  store i32 %0, i32* @redefine_out_eicas_discretes, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @AssignFunction3(i32*) {
AssignFunction3.entry:
  %1 = alloca i32, align 4, !ConsumedBy !8
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 0
  %5 = load i32* %4, align 4
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %AssignFunction3.if.then, label %AssignFunction3.if.end

AssignFunction3.if.then:                          ; preds = %AssignFunction3.entry
  %7 = load i32* @eicas_discretes, align 4
  %8 = or i32 %7, 1
  store i32 %8, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end

AssignFunction3.if.end:                           ; preds = %AssignFunction3.if.then, %AssignFunction3.entry
  %9 = load i32** %2, align 4
  %10 = getelementptr inbounds i32* %9, i32 1
  %11 = load i32* %10, align 4
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %AssignFunction3.if.then3, label %AssignFunction3.if.end5

AssignFunction3.if.then3:                         ; preds = %AssignFunction3.if.end
  %13 = load i32* @eicas_discretes, align 4
  %14 = or i32 %13, 2
  store i32 %14, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end5

AssignFunction3.if.end5:                          ; preds = %AssignFunction3.if.then3, %AssignFunction3.if.end
  %15 = load i32** %2, align 4
  %16 = getelementptr inbounds i32* %15, i32 2
  %17 = load i32* %16, align 4
  %18 = icmp sgt i32 %17, 250
  br i1 %18, label %AssignFunction3.if.then9, label %AssignFunction3.lor.lhs.false

AssignFunction3.lor.lhs.false:                    ; preds = %AssignFunction3.if.end5
  %19 = load i32** %2, align 4
  %20 = getelementptr inbounds i32* %19, i32 3
  %21 = load i32* %20, align 4
  %22 = icmp sgt i32 %21, 250
  br i1 %22, label %AssignFunction3.if.then9, label %AssignFunction3.if.end11

AssignFunction3.if.then9:                         ; preds = %AssignFunction3.lor.lhs.false, %AssignFunction3.if.end5
  %23 = load i32* @eicas_discretes, align 4
  %24 = or i32 %23, 4
  store i32 %24, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end11

AssignFunction3.if.end11:                         ; preds = %AssignFunction3.if.then9, %AssignFunction3.lor.lhs.false
  %25 = load i32** %2, align 4
  %26 = getelementptr inbounds i32* %25, i32 4
  %27 = load i32* %26, align 4
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %AssignFunction3.if.then14, label %AssignFunction3.if.end16

AssignFunction3.if.then14:                        ; preds = %AssignFunction3.if.end11
  %29 = load i32* @eicas_discretes, align 4
  %30 = or i32 %29, 16
  store i32 %30, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end16

AssignFunction3.if.end16:                         ; preds = %AssignFunction3.if.then14, %AssignFunction3.if.end11
  %31 = load i32** %2, align 4
  %32 = getelementptr inbounds i32* %31, i32 5
  %33 = load i32* %32, align 4
  %34 = icmp ne i32 %33, 0
  br i1 %34, label %AssignFunction3.if.then19, label %AssignFunction3.if.end21

AssignFunction3.if.then19:                        ; preds = %AssignFunction3.if.end16
  %35 = load i32* @eicas_discretes, align 4
  %36 = or i32 %35, 32
  store i32 %36, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end21

AssignFunction3.if.end21:                         ; preds = %AssignFunction3.if.then19, %AssignFunction3.if.end16
  %37 = load i32** %2, align 4
  %38 = getelementptr inbounds i32* %37, i32 6
  %39 = load i32* %38, align 4
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %AssignFunction3.if.then24, label %AssignFunction3.if.end26

AssignFunction3.if.then24:                        ; preds = %AssignFunction3.if.end21
  %41 = load i32* @eicas_discretes, align 4
  %42 = or i32 %41, 64
  store i32 %42, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end26

AssignFunction3.if.end26:                         ; preds = %AssignFunction3.if.then24, %AssignFunction3.if.end21
  %43 = load i32** %2, align 4
  %44 = getelementptr inbounds i32* %43, i32 7
  %45 = load i32* %44, align 4
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %AssignFunction3.if.then29, label %AssignFunction3.if.end31

AssignFunction3.if.then29:                        ; preds = %AssignFunction3.if.end26
  %47 = load i32* @eicas_discretes, align 4
  %48 = or i32 %47, 128
  store i32 %48, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end31

AssignFunction3.if.end31:                         ; preds = %AssignFunction3.if.then29, %AssignFunction3.if.end26
  %49 = load i32** %2, align 4
  %50 = getelementptr inbounds i32* %49, i32 8
  %51 = load i32* %50, align 4
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %AssignFunction3.if.then34, label %AssignFunction3.if.end36

AssignFunction3.if.then34:                        ; preds = %AssignFunction3.if.end31
  %53 = load i32* @eicas_discretes, align 4
  %54 = or i32 %53, 256
  store i32 %54, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end36

AssignFunction3.if.end36:                         ; preds = %AssignFunction3.if.then34, %AssignFunction3.if.end31
  %55 = load i32** %2, align 4
  %56 = getelementptr inbounds i32* %55, i32 9
  %57 = load i32* %56, align 4
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %AssignFunction3.if.then39, label %AssignFunction3.if.end41

AssignFunction3.if.then39:                        ; preds = %AssignFunction3.if.end36
  %59 = load i32* @eicas_discretes, align 4
  %60 = or i32 %59, 512
  store i32 %60, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end41

AssignFunction3.if.end41:                         ; preds = %AssignFunction3.if.then39, %AssignFunction3.if.end36
  %61 = load i32* @eicas_discretes, align 4
  store i32 %61, i32* %1, align 4
  br label %AssignFunction3.return

AssignFunction3.return:                           ; preds = %AssignFunction3.if.end41
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (i32*)* @AssignFunction3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !7}
!7 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !2, metadata !"Scalar", i32 0}

----------Adding sync edges to dangling HyperOps----------

-----------Re-routing sync edges from end hyperop to the newly created end HyperOp-----------
whats in module now?; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

; Function Attrs: nounwind
define i32 @AssignFunction(i32* %sensors) #0 {
entry:
  %sensors.addr = alloca i32*, align 4
  store i32* %sensors, i32** %sensors.addr, align 4
  %0 = load i32** %sensors.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = load i32* %arrayidx, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* @eicas_discretes, align 4
  %or = or i32 %2, 1
  store i32 %or, i32* @eicas_discretes, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32** %sensors.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %3, i32 1
  %4 = load i32* %arrayidx1, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i32* @eicas_discretes, align 4
  %or4 = or i32 %5, 2
  store i32 %or4, i32* @eicas_discretes, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32** %sensors.addr, align 4
  %arrayidx6 = getelementptr inbounds i32* %6, i32 2
  %7 = load i32* %arrayidx6, align 4
  %cmp = icmp sgt i32 %7, 250
  br i1 %cmp, label %if.then9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end5
  %8 = load i32** %sensors.addr, align 4
  %arrayidx7 = getelementptr inbounds i32* %8, i32 3
  %9 = load i32* %arrayidx7, align 4
  %cmp8 = icmp sgt i32 %9, 250
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %lor.lhs.false, %if.end5
  %10 = load i32* @eicas_discretes, align 4
  %or10 = or i32 %10, 4
  store i32 %or10, i32* @eicas_discretes, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %lor.lhs.false
  %11 = load i32** %sensors.addr, align 4
  %arrayidx12 = getelementptr inbounds i32* %11, i32 4
  %12 = load i32* %arrayidx12, align 4
  %tobool13 = icmp ne i32 %12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end11
  %13 = load i32* @eicas_discretes, align 4
  %or15 = or i32 %13, 16
  store i32 %or15, i32* @eicas_discretes, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end11
  %14 = load i32** %sensors.addr, align 4
  %arrayidx17 = getelementptr inbounds i32* %14, i32 5
  %15 = load i32* %arrayidx17, align 4
  %tobool18 = icmp ne i32 %15, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.end16
  %16 = load i32* @eicas_discretes, align 4
  %or20 = or i32 %16, 32
  store i32 %or20, i32* @eicas_discretes, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.end16
  %17 = load i32** %sensors.addr, align 4
  %arrayidx22 = getelementptr inbounds i32* %17, i32 6
  %18 = load i32* %arrayidx22, align 4
  %tobool23 = icmp ne i32 %18, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end21
  %19 = load i32* @eicas_discretes, align 4
  %or25 = or i32 %19, 64
  store i32 %or25, i32* @eicas_discretes, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end21
  %20 = load i32** %sensors.addr, align 4
  %arrayidx27 = getelementptr inbounds i32* %20, i32 7
  %21 = load i32* %arrayidx27, align 4
  %tobool28 = icmp ne i32 %21, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %22 = load i32* @eicas_discretes, align 4
  %or30 = or i32 %22, 128
  store i32 %or30, i32* @eicas_discretes, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %23 = load i32** %sensors.addr, align 4
  %arrayidx32 = getelementptr inbounds i32* %23, i32 8
  %24 = load i32* %arrayidx32, align 4
  %tobool33 = icmp ne i32 %24, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end31
  %25 = load i32* @eicas_discretes, align 4
  %or35 = or i32 %25, 256
  store i32 %or35, i32* @eicas_discretes, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end31
  %26 = load i32** %sensors.addr, align 4
  %arrayidx37 = getelementptr inbounds i32* %26, i32 9
  %27 = load i32* %arrayidx37, align 4
  %tobool38 = icmp ne i32 %27, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end36
  %28 = load i32* @eicas_discretes, align 4
  %or40 = or i32 %28, 512
  store i32 %or40, i32* @eicas_discretes, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %if.end36
  %29 = load i32* @eicas_discretes, align 4
  ret i32 %29
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call i32 @AssignFunction(i32* %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  store i32 %call, i32* @redefine_out_eicas_discretes, align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4, !ConsumedBy !6
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(i32 inreg) {
redefine_start2.newName01:
  store i32 %0, i32* @redefine_out_eicas_discretes, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @AssignFunction3(i32*) {
AssignFunction3.entry:
  %1 = alloca i32, align 4, !ConsumedBy !8
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 0
  %5 = load i32* %4, align 4
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %AssignFunction3.if.then, label %AssignFunction3.if.end

AssignFunction3.if.then:                          ; preds = %AssignFunction3.entry
  %7 = load i32* @eicas_discretes, align 4
  %8 = or i32 %7, 1
  store i32 %8, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end

AssignFunction3.if.end:                           ; preds = %AssignFunction3.if.then, %AssignFunction3.entry
  %9 = load i32** %2, align 4
  %10 = getelementptr inbounds i32* %9, i32 1
  %11 = load i32* %10, align 4
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %AssignFunction3.if.then3, label %AssignFunction3.if.end5

AssignFunction3.if.then3:                         ; preds = %AssignFunction3.if.end
  %13 = load i32* @eicas_discretes, align 4
  %14 = or i32 %13, 2
  store i32 %14, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end5

AssignFunction3.if.end5:                          ; preds = %AssignFunction3.if.then3, %AssignFunction3.if.end
  %15 = load i32** %2, align 4
  %16 = getelementptr inbounds i32* %15, i32 2
  %17 = load i32* %16, align 4
  %18 = icmp sgt i32 %17, 250
  br i1 %18, label %AssignFunction3.if.then9, label %AssignFunction3.lor.lhs.false

AssignFunction3.lor.lhs.false:                    ; preds = %AssignFunction3.if.end5
  %19 = load i32** %2, align 4
  %20 = getelementptr inbounds i32* %19, i32 3
  %21 = load i32* %20, align 4
  %22 = icmp sgt i32 %21, 250
  br i1 %22, label %AssignFunction3.if.then9, label %AssignFunction3.if.end11

AssignFunction3.if.then9:                         ; preds = %AssignFunction3.lor.lhs.false, %AssignFunction3.if.end5
  %23 = load i32* @eicas_discretes, align 4
  %24 = or i32 %23, 4
  store i32 %24, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end11

AssignFunction3.if.end11:                         ; preds = %AssignFunction3.if.then9, %AssignFunction3.lor.lhs.false
  %25 = load i32** %2, align 4
  %26 = getelementptr inbounds i32* %25, i32 4
  %27 = load i32* %26, align 4
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %AssignFunction3.if.then14, label %AssignFunction3.if.end16

AssignFunction3.if.then14:                        ; preds = %AssignFunction3.if.end11
  %29 = load i32* @eicas_discretes, align 4
  %30 = or i32 %29, 16
  store i32 %30, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end16

AssignFunction3.if.end16:                         ; preds = %AssignFunction3.if.then14, %AssignFunction3.if.end11
  %31 = load i32** %2, align 4
  %32 = getelementptr inbounds i32* %31, i32 5
  %33 = load i32* %32, align 4
  %34 = icmp ne i32 %33, 0
  br i1 %34, label %AssignFunction3.if.then19, label %AssignFunction3.if.end21

AssignFunction3.if.then19:                        ; preds = %AssignFunction3.if.end16
  %35 = load i32* @eicas_discretes, align 4
  %36 = or i32 %35, 32
  store i32 %36, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end21

AssignFunction3.if.end21:                         ; preds = %AssignFunction3.if.then19, %AssignFunction3.if.end16
  %37 = load i32** %2, align 4
  %38 = getelementptr inbounds i32* %37, i32 6
  %39 = load i32* %38, align 4
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %AssignFunction3.if.then24, label %AssignFunction3.if.end26

AssignFunction3.if.then24:                        ; preds = %AssignFunction3.if.end21
  %41 = load i32* @eicas_discretes, align 4
  %42 = or i32 %41, 64
  store i32 %42, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end26

AssignFunction3.if.end26:                         ; preds = %AssignFunction3.if.then24, %AssignFunction3.if.end21
  %43 = load i32** %2, align 4
  %44 = getelementptr inbounds i32* %43, i32 7
  %45 = load i32* %44, align 4
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %AssignFunction3.if.then29, label %AssignFunction3.if.end31

AssignFunction3.if.then29:                        ; preds = %AssignFunction3.if.end26
  %47 = load i32* @eicas_discretes, align 4
  %48 = or i32 %47, 128
  store i32 %48, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end31

AssignFunction3.if.end31:                         ; preds = %AssignFunction3.if.then29, %AssignFunction3.if.end26
  %49 = load i32** %2, align 4
  %50 = getelementptr inbounds i32* %49, i32 8
  %51 = load i32* %50, align 4
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %AssignFunction3.if.then34, label %AssignFunction3.if.end36

AssignFunction3.if.then34:                        ; preds = %AssignFunction3.if.end31
  %53 = load i32* @eicas_discretes, align 4
  %54 = or i32 %53, 256
  store i32 %54, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end36

AssignFunction3.if.end36:                         ; preds = %AssignFunction3.if.then34, %AssignFunction3.if.end31
  %55 = load i32** %2, align 4
  %56 = getelementptr inbounds i32* %55, i32 9
  %57 = load i32* %56, align 4
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %AssignFunction3.if.then39, label %AssignFunction3.if.end41

AssignFunction3.if.then39:                        ; preds = %AssignFunction3.if.end36
  %59 = load i32* @eicas_discretes, align 4
  %60 = or i32 %59, 512
  store i32 %60, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end41

AssignFunction3.if.end41:                         ; preds = %AssignFunction3.if.then39, %AssignFunction3.if.end36
  %61 = load i32* @eicas_discretes, align 4
  store i32 %61, i32* %1, align 4
  br label %AssignFunction3.return

AssignFunction3.return:                           ; preds = %AssignFunction3.if.end41
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (i32*)* @AssignFunction3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !7}
!7 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !2, metadata !"Scalar", i32 0}

-----------Deleting unused functions-----------
deleting contents of function:AssignFunction
deleting contents of function:redefine_start
Final module contents:; ModuleID = './Working/eicas_1.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@eicas_discretes = global i32 0, align 4
@redefine_in_sensors = common global [10 x i32] zeroinitializer, align 4
@redefine_out_eicas_discretes = common global i32 0, align 4

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds i32* @eicas_discretes, i32 0
  store i32 0, i32* %0, align 4
  %1 = alloca i32*, align 4, !ConsumedBy !6
  store i32* getelementptr inbounds ([10 x i32]* @redefine_in_sensors, i32 0, i32 0), i32** %1
  %2 = load i32** %1
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(i32 inreg) {
redefine_start2.newName01:
  store i32 %0, i32* @redefine_out_eicas_discretes, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @AssignFunction3(i32*) {
AssignFunction3.entry:
  %1 = alloca i32, align 4, !ConsumedBy !8
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 0
  %5 = load i32* %4, align 4
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %AssignFunction3.if.then, label %AssignFunction3.if.end

AssignFunction3.if.then:                          ; preds = %AssignFunction3.entry
  %7 = load i32* @eicas_discretes, align 4
  %8 = or i32 %7, 1
  store i32 %8, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end

AssignFunction3.if.end:                           ; preds = %AssignFunction3.if.then, %AssignFunction3.entry
  %9 = load i32** %2, align 4
  %10 = getelementptr inbounds i32* %9, i32 1
  %11 = load i32* %10, align 4
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %AssignFunction3.if.then3, label %AssignFunction3.if.end5

AssignFunction3.if.then3:                         ; preds = %AssignFunction3.if.end
  %13 = load i32* @eicas_discretes, align 4
  %14 = or i32 %13, 2
  store i32 %14, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end5

AssignFunction3.if.end5:                          ; preds = %AssignFunction3.if.then3, %AssignFunction3.if.end
  %15 = load i32** %2, align 4
  %16 = getelementptr inbounds i32* %15, i32 2
  %17 = load i32* %16, align 4
  %18 = icmp sgt i32 %17, 250
  br i1 %18, label %AssignFunction3.if.then9, label %AssignFunction3.lor.lhs.false

AssignFunction3.lor.lhs.false:                    ; preds = %AssignFunction3.if.end5
  %19 = load i32** %2, align 4
  %20 = getelementptr inbounds i32* %19, i32 3
  %21 = load i32* %20, align 4
  %22 = icmp sgt i32 %21, 250
  br i1 %22, label %AssignFunction3.if.then9, label %AssignFunction3.if.end11

AssignFunction3.if.then9:                         ; preds = %AssignFunction3.lor.lhs.false, %AssignFunction3.if.end5
  %23 = load i32* @eicas_discretes, align 4
  %24 = or i32 %23, 4
  store i32 %24, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end11

AssignFunction3.if.end11:                         ; preds = %AssignFunction3.if.then9, %AssignFunction3.lor.lhs.false
  %25 = load i32** %2, align 4
  %26 = getelementptr inbounds i32* %25, i32 4
  %27 = load i32* %26, align 4
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %AssignFunction3.if.then14, label %AssignFunction3.if.end16

AssignFunction3.if.then14:                        ; preds = %AssignFunction3.if.end11
  %29 = load i32* @eicas_discretes, align 4
  %30 = or i32 %29, 16
  store i32 %30, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end16

AssignFunction3.if.end16:                         ; preds = %AssignFunction3.if.then14, %AssignFunction3.if.end11
  %31 = load i32** %2, align 4
  %32 = getelementptr inbounds i32* %31, i32 5
  %33 = load i32* %32, align 4
  %34 = icmp ne i32 %33, 0
  br i1 %34, label %AssignFunction3.if.then19, label %AssignFunction3.if.end21

AssignFunction3.if.then19:                        ; preds = %AssignFunction3.if.end16
  %35 = load i32* @eicas_discretes, align 4
  %36 = or i32 %35, 32
  store i32 %36, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end21

AssignFunction3.if.end21:                         ; preds = %AssignFunction3.if.then19, %AssignFunction3.if.end16
  %37 = load i32** %2, align 4
  %38 = getelementptr inbounds i32* %37, i32 6
  %39 = load i32* %38, align 4
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %AssignFunction3.if.then24, label %AssignFunction3.if.end26

AssignFunction3.if.then24:                        ; preds = %AssignFunction3.if.end21
  %41 = load i32* @eicas_discretes, align 4
  %42 = or i32 %41, 64
  store i32 %42, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end26

AssignFunction3.if.end26:                         ; preds = %AssignFunction3.if.then24, %AssignFunction3.if.end21
  %43 = load i32** %2, align 4
  %44 = getelementptr inbounds i32* %43, i32 7
  %45 = load i32* %44, align 4
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %AssignFunction3.if.then29, label %AssignFunction3.if.end31

AssignFunction3.if.then29:                        ; preds = %AssignFunction3.if.end26
  %47 = load i32* @eicas_discretes, align 4
  %48 = or i32 %47, 128
  store i32 %48, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end31

AssignFunction3.if.end31:                         ; preds = %AssignFunction3.if.then29, %AssignFunction3.if.end26
  %49 = load i32** %2, align 4
  %50 = getelementptr inbounds i32* %49, i32 8
  %51 = load i32* %50, align 4
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %AssignFunction3.if.then34, label %AssignFunction3.if.end36

AssignFunction3.if.then34:                        ; preds = %AssignFunction3.if.end31
  %53 = load i32* @eicas_discretes, align 4
  %54 = or i32 %53, 256
  store i32 %54, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end36

AssignFunction3.if.end36:                         ; preds = %AssignFunction3.if.then34, %AssignFunction3.if.end31
  %55 = load i32** %2, align 4
  %56 = getelementptr inbounds i32* %55, i32 9
  %57 = load i32* %56, align 4
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %AssignFunction3.if.then39, label %AssignFunction3.if.end41

AssignFunction3.if.then39:                        ; preds = %AssignFunction3.if.end36
  %59 = load i32* @eicas_discretes, align 4
  %60 = or i32 %59, 512
  store i32 %60, i32* @eicas_discretes, align 4
  br label %AssignFunction3.if.end41

AssignFunction3.if.end41:                         ; preds = %AssignFunction3.if.then39, %AssignFunction3.if.end36
  %61 = load i32* @eicas_discretes, align 4
  store i32 %61, i32* %1, align 4
  br label %AssignFunction3.return

AssignFunction3.return:                           ; preds = %AssignFunction3.if.end41
  ret void
}

!redefine.annotations = !{!0, !1, !2, !3, !4, !5}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (i32*)* @AssignFunction3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !7}
!7 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !2, metadata !"Scalar", i32 0}
