Args: /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/opt -debug --load /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/../lib/HyperOpCreationPass.so --HyperOpCreationPass -S ./Compilation_Error/startupoil.ll -o ./Compilation_Error/startupoil_HyOpPass.ll 

Features:
CPU:REDEFINE

Found cycles?0

-----------
Partitioning function:asl_open_oil_valve

-------
Acquiring bb entry
entered end hop for function asl_open_oil_valve
Adding basic blocks for traversal in a breadth biased order for function asl_open_oil_valve
added to succ list:
adding to creation map bbargs of size 1

-----------
Partitioning function:regulation_oil

-------
Acquiring bb entry
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:if.then,if.end12,
distance of if.then to exit 6
distance of if.end12 to exit 1

-------
Acquiring bb if.then
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:if.then8,if.else,
distance of if.end12 to exit 1
distance of if.then8 to exit 3
distance of if.else to exit 5

-------
Acquiring bb if.else
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:if.then10,if.end,
distance of if.then8 to exit 3
distance of if.end12 to exit 1
distance of if.then10 to exit 4
distance of if.end to exit 3

-------
Acquiring bb if.then10
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:didn't add if.end

distance of if.then8 to exit 3
distance of if.end to exit 3
distance of if.end12 to exit 1

-------
Acquiring bb if.then8
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:if.end11,
distance of if.end to exit 3
distance of if.end12 to exit 1
distance of if.end11 to exit 2

-------
Acquiring bb if.end
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:didn't add if.end11

distance of if.end11 to exit 2
distance of if.end12 to exit 1

-------
Acquiring bb if.end11
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:didn't add if.end12

distance of if.end12 to exit 1

-------
Acquiring bb if.end12
entered end hop for function regulation_oil
Adding basic blocks for traversal in a breadth biased order for function regulation_oil
added to succ list:
adding to creation map bbargs of size 1

-----------
Partitioning function:startup_oil

-------
Acquiring bb entry
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:if.then,if.else,
distance of if.then to exit 2
distance of if.else to exit 2

-------
Acquiring bb if.then
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:newName0,
distance of if.then to exit 3
distance of if.else to exit 2
distance of newName0 to exit 2

-------
Acquiring bb if.then
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:didn't add newName0

distance of if.else to exit 2
distance of newName0 to exit 2

-------
Acquiring bb if.else
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:newName01,
distance of newName0 to exit 2
distance of newName01 to exit 2

-------
Acquiring bb newName0
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:return,
distance of newName01 to exit 2
distance of return to exit 1

-------
Acquiring bb newName01
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:didn't add return

distance of newName01 to exit 2
distance of return to exit 1

-------
Acquiring bb newName01
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:newName02,
distance of return to exit 1
distance of newName02 to exit 2

-------
Acquiring bb newName02
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:didn't add return

distance of return to exit 1

-------
Acquiring bb return
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:
distance of return to exit 1

-------
Acquiring bb return
entered end hop for function startup_oil
Adding basic blocks for traversal in a breadth biased order for function startup_oil
added to succ list:
adding to creation map bbargs of size 7

-----------
Partitioning function:redefine_start

-------
Acquiring bb entry
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:newName0,
distance of newName0 to exit 1

-------
Acquiring bb newName0
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:newName01,
distance of newName01 to exit 1

-------
Acquiring bb newName01
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:
adding to creation map bbargs of size 3
before partitioning:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{}
-----------Creating HyperOps from partitioned functions-----------
added to traversallist:entry
added to traversallist:newName0
added to traversallist:newName01
now at func:entry

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:entry from parent:redefine_start
created func:redefine_start1
now at func:newName0
now at func:newName01

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:newName01 from parent:redefine_start
created func:redefine_start2
now at func:return

-----------Creating a new HyperOp for function:startup_oil-----------

--------
Acquired bb:return from parent:startup_oil
created func:startup_oil3
now at func:newName02

-----------Creating a new HyperOp for function:startup_oil-----------

--------
Acquired bb:newName02 from parent:startup_oil
created func:startup_oil4
now at func:newName01
now at func:newName0

-----------Creating a new HyperOp for function:startup_oil-----------

--------
Acquired bb:newName0 from parent:startup_oil
created func:startup_oil5
now at func:if.else

-----------Creating a new HyperOp for function:startup_oil-----------

--------
Acquired bb:if.else from parent:startup_oil
created func:startup_oil6
now at func:if.then
now at func:entry

-----------Creating a new HyperOp for function:startup_oil-----------
newName0,
--------
Acquired bb:entry from parent:startup_oil

--------
Acquired bb:newName0 from parent:redefine_start
created func:startup_oil7
now at func:entry

-----------Creating a new HyperOp for function:regulation_oil-----------
newName01,
--------
Acquired bb:entry from parent:regulation_oil

--------
Acquired bb:if.then from parent:regulation_oil

--------
Acquired bb:if.else from parent:regulation_oil

--------
Acquired bb:if.then10 from parent:regulation_oil

--------
Acquired bb:if.then8 from parent:regulation_oil

--------
Acquired bb:if.end from parent:regulation_oil

--------
Acquired bb:if.end11 from parent:regulation_oil

--------
Acquired bb:if.end12 from parent:regulation_oil

--------
Acquired bb:newName01 from parent:startup_oil
created func:regulation_oil8
now at func:entry

-----------Creating a new HyperOp for function:asl_open_oil_valve-----------
if.then,
--------
Acquired bb:entry from parent:asl_open_oil_valve

--------
Acquired bb:if.then from parent:startup_oil
created func:asl_open_oil_valve9
before patching stuff:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %startup_oil5.newName0, %startup_oil4.newName02, %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = load float** %0
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %return

startup_oil4.return:                              ; No predecessors!
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %return

startup_oil5.return:                              ; No predecessors!
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca float*, align 4
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 1
  %5 = load i32* %4, align 4
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %if.then, label %if.else

startup_oil7.return:                              ; No predecessors!
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca i32*, align 4
  %2 = alloca float, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  store i32* %0, i32** %1, align 4
  %9 = load i32** %1, align 4
  %10 = getelementptr inbounds i32* %9, i32 0
  %11 = bitcast i32* %10 to float*
  %12 = load float* %11, align 4
  store float %12, float* %2, align 4
  store float 0.000000e+00, float* %3, align 4
  store float 0x3D147DCB00000000, float* %4, align 4
  store float 0x3E191525E0000000, float* %5, align 4
  store float 0x3F063AD4E0000000, float* %6, align 4
  store float 0x3FA7A786C0000000, float* %7, align 4
  store float 0x3FF147AE20000000, float* %8, align 4
  %13 = load float* %2, align 4
  %14 = fcmp ogt float %13, 3.500000e+03
  br i1 %14, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %15 = load float* %4, align 4
  %16 = load float* %2, align 4
  %17 = fmul float %15, %16
  %18 = load float* %2, align 4
  %19 = fmul float %17, %18
  %20 = load float* %5, align 4
  %21 = load float* %2, align 4
  %22 = fmul float %20, %21
  %23 = load float* %2, align 4
  %24 = fmul float %22, %23
  %25 = fsub float %19, %24
  %26 = load float* %6, align 4
  %27 = load float* %2, align 4
  %28 = fmul float %26, %27
  %29 = fadd float %25, %28
  %30 = load float* %7, align 4
  %31 = fadd float %29, %30
  %32 = load float* %8, align 4
  %33 = fmul float %31, %32
  store float %33, float* %3, align 4
  %34 = load float* %3, align 4
  %35 = fcmp olt float %34, 3.000000e+00
  br i1 %35, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %36 = load float* %3, align 4
  %37 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %38 = fcmp ogt float %36, %37
  br i1 %38, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %39 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %39, float* %3, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %3, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %40 = load float* %3, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}

----------Adding dependences across created HyperOps----------

-----------Patching created function redefine_start1--------------
accumulated bbs:
entry,

----------Adding consumed by metadata----------

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function redefine_start1, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %startup_oil5.newName0, %startup_oil4.newName02, %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = load float** %0
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %return

startup_oil4.return:                              ; No predecessors!
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %return

startup_oil5.return:                              ; No predecessors!
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca float*, align 4
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 1
  %5 = load i32* %4, align 4
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %if.then, label %if.else

startup_oil7.return:                              ; No predecessors!
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca i32*, align 4
  %2 = alloca float, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  store i32* %0, i32** %1, align 4
  %9 = load i32** %1, align 4
  %10 = getelementptr inbounds i32* %9, i32 0
  %11 = bitcast i32* %10 to float*
  %12 = load float* %11, align 4
  store float %12, float* %2, align 4
  store float 0.000000e+00, float* %3, align 4
  store float 0x3D147DCB00000000, float* %4, align 4
  store float 0x3E191525E0000000, float* %5, align 4
  store float 0x3F063AD4E0000000, float* %6, align 4
  store float 0x3FA7A786C0000000, float* %7, align 4
  store float 0x3FF147AE20000000, float* %8, align 4
  %13 = load float* %2, align 4
  %14 = fcmp ogt float %13, 3.500000e+03
  br i1 %14, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %15 = load float* %4, align 4
  %16 = load float* %2, align 4
  %17 = fmul float %15, %16
  %18 = load float* %2, align 4
  %19 = fmul float %17, %18
  %20 = load float* %5, align 4
  %21 = load float* %2, align 4
  %22 = fmul float %20, %21
  %23 = load float* %2, align 4
  %24 = fmul float %22, %23
  %25 = fsub float %19, %24
  %26 = load float* %6, align 4
  %27 = load float* %2, align 4
  %28 = fmul float %26, %27
  %29 = fadd float %25, %28
  %30 = load float* %7, align 4
  %31 = fadd float %29, %30
  %32 = load float* %8, align 4
  %33 = fmul float %31, %32
  store float %33, float* %3, align 4
  %34 = load float* %3, align 4
  %35 = fcmp olt float %34, 3.000000e+00
  br i1 %35, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %36 = load float* %3, align 4
  %37 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %38 = fcmp ogt float %36, %37
  br i1 %38, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %39 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %39, float* %3, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %3, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %40 = load float* %3, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}

-----------Patching created function redefine_start2--------------
accumulated bbs:
newName01,

----------Adding consumed by metadata----------
  %call = call float* @startup_oil(i32* %4)
cloned inst second:  %6 = load float** %retval
producer function:startup_oil3
how many clones?1
added metadata on instruction that belongs to parent startup_oil3 and is mapped to slot 0 when the function has 1 and is of type:1:  %1 = alloca float*, align 4, !ConsumedBy !18

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function redefine_start2, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %startup_oil5.newName0, %startup_oil4.newName02, %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !18
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %return

startup_oil4.return:                              ; No predecessors!
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %return

startup_oil5.return:                              ; No predecessors!
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca float*, align 4
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 1
  %5 = load i32* %4, align 4
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %if.then, label %if.else

startup_oil7.return:                              ; No predecessors!
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca i32*, align 4
  %2 = alloca float, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  store i32* %0, i32** %1, align 4
  %9 = load i32** %1, align 4
  %10 = getelementptr inbounds i32* %9, i32 0
  %11 = bitcast i32* %10 to float*
  %12 = load float* %11, align 4
  store float %12, float* %2, align 4
  store float 0.000000e+00, float* %3, align 4
  store float 0x3D147DCB00000000, float* %4, align 4
  store float 0x3E191525E0000000, float* %5, align 4
  store float 0x3F063AD4E0000000, float* %6, align 4
  store float 0x3FA7A786C0000000, float* %7, align 4
  store float 0x3FF147AE20000000, float* %8, align 4
  %13 = load float* %2, align 4
  %14 = fcmp ogt float %13, 3.500000e+03
  br i1 %14, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %15 = load float* %4, align 4
  %16 = load float* %2, align 4
  %17 = fmul float %15, %16
  %18 = load float* %2, align 4
  %19 = fmul float %17, %18
  %20 = load float* %5, align 4
  %21 = load float* %2, align 4
  %22 = fmul float %20, %21
  %23 = load float* %2, align 4
  %24 = fmul float %22, %23
  %25 = fsub float %19, %24
  %26 = load float* %6, align 4
  %27 = load float* %2, align 4
  %28 = fmul float %26, %27
  %29 = fadd float %25, %28
  %30 = load float* %7, align 4
  %31 = fadd float %29, %30
  %32 = load float* %8, align 4
  %33 = fmul float %31, %32
  store float %33, float* %3, align 4
  %34 = load float* %3, align 4
  %35 = fcmp olt float %34, 3.000000e+00
  br i1 %35, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %36 = load float* %3, align 4
  %37 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %38 = fcmp ogt float %36, %37
  br i1 %38, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %39 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %39, float* %3, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %3, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %40 = load float* %3, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !2, metadata !"LocalReference", i32 0}

-----------Patching created function startup_oil3--------------
accumulated bbs:
return,

----------Adding consumed by metadata----------
cloned inst second:  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
producer function:startup_oil4
how many clones?1
added metadata on instruction that belongs to parent startup_oil4 and is mapped to slot 0 when the function has 1 and is of type:1:  %1 = alloca float*, align 4, !ConsumedBy !18
cloned inst second:  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
producer function:startup_oil5
how many clones?1
added metadata on instruction that belongs to parent startup_oil5 and is mapped to slot 0 when the function has 1 and is of type:1:  %1 = alloca float*, align 4, !ConsumedBy !18

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:2
what was callsite size earlier??1
what was callsite size earlier??1

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function startup_oil3, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !18
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca float*, align 4
  %2 = alloca i32*, align 4
  store i32* %0, i32** %2, align 4
  %3 = load i32** %2, align 4
  %4 = getelementptr inbounds i32* %3, i32 1
  %5 = load i32* %4, align 4
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %if.then, label %if.else

startup_oil7.return:                              ; No predecessors!
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca i32*, align 4
  %2 = alloca float, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  store i32* %0, i32** %1, align 4
  %9 = load i32** %1, align 4
  %10 = getelementptr inbounds i32* %9, i32 0
  %11 = bitcast i32* %10 to float*
  %12 = load float* %11, align 4
  store float %12, float* %2, align 4
  store float 0.000000e+00, float* %3, align 4
  store float 0x3D147DCB00000000, float* %4, align 4
  store float 0x3E191525E0000000, float* %5, align 4
  store float 0x3F063AD4E0000000, float* %6, align 4
  store float 0x3FA7A786C0000000, float* %7, align 4
  store float 0x3FF147AE20000000, float* %8, align 4
  %13 = load float* %2, align 4
  %14 = fcmp ogt float %13, 3.500000e+03
  br i1 %14, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %15 = load float* %4, align 4
  %16 = load float* %2, align 4
  %17 = fmul float %15, %16
  %18 = load float* %2, align 4
  %19 = fmul float %17, %18
  %20 = load float* %5, align 4
  %21 = load float* %2, align 4
  %22 = fmul float %20, %21
  %23 = load float* %2, align 4
  %24 = fmul float %22, %23
  %25 = fsub float %19, %24
  %26 = load float* %6, align 4
  %27 = load float* %2, align 4
  %28 = fmul float %26, %27
  %29 = fadd float %25, %28
  %30 = load float* %7, align 4
  %31 = fadd float %29, %30
  %32 = load float* %8, align 4
  %33 = fmul float %31, %32
  store float %33, float* %3, align 4
  %34 = load float* %3, align 4
  %35 = fcmp olt float %34, 3.000000e+00
  br i1 %35, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %36 = load float* %3, align 4
  %37 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %38 = fcmp ogt float %36, %37
  br i1 %38, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %39 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %39, float* %3, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %3, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %40 = load float* %3, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !4, metadata !"LocalReference", i32 0}

-----------Patching created function startup_oil4--------------
accumulated bbs:
newName02,

----------Adding consumed by metadata----------
  %call = call float* @startup_oil(i32* %4)
  %call2 = call float @regulation_oil(i32* %5)
cloned inst second:  %18 = load float* %oil_pump_cmd, align 4
producer function:regulation_oil8
how many clones?1
added metadata on instruction that belongs to parent regulation_oil8 and is mapped to slot 0 when the function has 1 and is of type:1:  %1 = alloca float, align 4, !ConsumedBy !18

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %if.then, label %if.else
target bb:
newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

producer of data:startup_oil and its clone?startup_oil7, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??1

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function startup_oil4, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !18
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !22
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %if.else

startup_oil7.return:                              ; No predecessors!
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !24
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23}
!23 = metadata !{metadata !6, metadata !"0"}
!24 = metadata !{metadata !25}
!25 = metadata !{metadata !6, metadata !"LocalReference", i32 0}

-----------Patching created function startup_oil5--------------
accumulated bbs:
newName0,

----------Adding consumed by metadata----------
  %call = call float* @startup_oil(i32* %4)
  %call = call i32 @asl_open_oil_valve()
  %call = call float* @startup_oil(i32* %4)
  %call = call i32 @asl_open_oil_valve()
cloned inst second:i32 1
producer function:asl_open_oil_valve9
how many clones?1
added metadata on instruction that belongs to parent asl_open_oil_valve9 and is mapped to slot 0 when the function has 1 and is of type:0:  %0 = alloca i32, align 4, !ConsumedBy !18

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %if.then, label %if.else
target bb:
newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

producer of data:startup_oil and its clone?startup_oil7, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??1

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function startup_oil5, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !18
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !22
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %if.else

startup_oil7.return:                              ; No predecessors!
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !25
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  %0 = alloca i32, align 4, !ConsumedBy !27
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  store i32 1, i32* %0, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23, metadata !24}
!23 = metadata !{metadata !6, metadata !"0"}
!24 = metadata !{metadata !8, metadata !"1"}
!25 = metadata !{metadata !26}
!26 = metadata !{metadata !6, metadata !"LocalReference", i32 0}
!27 = metadata !{metadata !28}
!28 = metadata !{metadata !8, metadata !"Scalar", i32 0}

-----------Patching created function startup_oil6--------------
accumulated bbs:
if.else,

----------Adding consumed by metadata----------
cloned inst second:  store i32* %input, i32** %input.addr, align 4
producer function:startup_oil7
how many clones?1
added metadata on instruction that belongs to parent startup_oil7 and is mapped to slot 0 when the function has 1 and is of type:1:  %3 = alloca i32*, align 4, !ConsumedBy !21

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %if.then, label %if.else
target bb:
if.else:                                          ; preds = %startup_oil7.entry, %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

producer of data:startup_oil and its clone?startup_oil7, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function startup_oil6, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %redefine_start1.entry, %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !18
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !22
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !26
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %startup_oil7.return

startup_oil7.return:                              ; preds = %startup_oil7.entry
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !28
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  %0 = alloca i32, align 4, !ConsumedBy !30
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  store i32 1, i32* %0, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23, metadata !24, metadata !25}
!23 = metadata !{metadata !6, metadata !"0"}
!24 = metadata !{metadata !8, metadata !"1"}
!25 = metadata !{metadata !10, metadata !"0"}
!26 = metadata !{metadata !27}
!27 = metadata !{metadata !10, metadata !"LocalReference", i32 0}
!28 = metadata !{metadata !29}
!29 = metadata !{metadata !6, metadata !"LocalReference", i32 0}
!30 = metadata !{metadata !31}
!31 = metadata !{metadata !8, metadata !"Scalar", i32 0}

-----------Patching created function startup_oil7--------------
accumulated bbs:
entry,

----------Adding consumed by metadata----------
cloned inst second:  %3 = alloca i32*, align 4
producer function:redefine_start1
how many clones?1
added metadata on instruction that belongs to parent redefine_start1 and is mapped to slot 0 when the function has 1 and is of type:1:  %3 = alloca i32*, align 4, !ConsumedBy !18

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??1

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function startup_oil7, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !18
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = load i32** %0, align 4
  %2 = getelementptr inbounds i32* %1, i32 2
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %0, align 4
  br label %newName01

startup_oil6.return:                              ; No predecessors!
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !24
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !28
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %startup_oil7.return

startup_oil7.return:                              ; preds = %startup_oil7.entry
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !30
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  %0 = alloca i32, align 4, !ConsumedBy !32
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  store i32 1, i32* %0, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !12, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23}
!23 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!24 = metadata !{metadata !25, metadata !26, metadata !27}
!25 = metadata !{metadata !6, metadata !"0"}
!26 = metadata !{metadata !8, metadata !"1"}
!27 = metadata !{metadata !10, metadata !"0"}
!28 = metadata !{metadata !29}
!29 = metadata !{metadata !10, metadata !"LocalReference", i32 0}
!30 = metadata !{metadata !31}
!31 = metadata !{metadata !6, metadata !"LocalReference", i32 0}
!32 = metadata !{metadata !33}
!33 = metadata !{metadata !8, metadata !"Scalar", i32 0}

-----------Patching created function regulation_oil8--------------
accumulated bbs:
entry,if.then,if.else,if.then10,if.then8,if.end,if.end11,if.end12,

----------Adding consumed by metadata----------
cloned inst second:  %5 = load i32** %input.addr, align 4
producer function:startup_oil6
how many clones?1
added metadata on instruction that belongs to parent startup_oil6 and is mapped to slot 0 when the function has 1 and is of type:1:  %1 = alloca i32*, align 4, !ConsumedBy !18

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %if.then, label %if.else
target bb:
newName01:                                        ; preds = %startup_oil6.if.else, %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

producer of data:startup_oil and its clone?startup_oil7, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??2

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function regulation_oil8, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !18
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = alloca i32*, align 4, !ConsumedBy !24
  %2 = load i32** %0, align 4
  %3 = getelementptr inbounds i32* %2, i32 2
  %4 = bitcast i32* %3 to float*
  %5 = load float* %4, align 4
  store float %5, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %6 = load i32** %0, align 4
  store i32* %6, i32** %1, align 4
  br label %startup_oil6.return

startup_oil6.return:                              ; preds = %startup_oil6.if.else
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !26
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !31
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %startup_oil7.return

startup_oil7.return:                              ; preds = %startup_oil7.entry
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !33
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  %0 = alloca i32, align 4, !ConsumedBy !35
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  store i32 1, i32* %0, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !12, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23}
!23 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!24 = metadata !{metadata !25}
!25 = metadata !{metadata !14, metadata !"LocalReference", i32 0}
!26 = metadata !{metadata !27, metadata !28, metadata !29, metadata !30}
!27 = metadata !{metadata !6, metadata !"0"}
!28 = metadata !{metadata !8, metadata !"1"}
!29 = metadata !{metadata !10, metadata !"0"}
!30 = metadata !{metadata !14, metadata !"0"}
!31 = metadata !{metadata !32}
!32 = metadata !{metadata !10, metadata !"LocalReference", i32 0}
!33 = metadata !{metadata !34}
!34 = metadata !{metadata !6, metadata !"LocalReference", i32 0}
!35 = metadata !{metadata !36}
!36 = metadata !{metadata !8, metadata !"Scalar", i32 0}

-----------Patching created function asl_open_oil_valve9--------------
accumulated bbs:
entry,

----------Adding consumed by metadata----------

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %if.then, label %if.else
target bb:
if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

producer of data:startup_oil and its clone?startup_oil7, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function asl_open_oil_valve9, module:; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !18
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = alloca i32*, align 4, !ConsumedBy !24
  %2 = load i32** %0, align 4
  %3 = getelementptr inbounds i32* %2, i32 2
  %4 = bitcast i32* %3 to float*
  %5 = load float* %4, align 4
  store float %5, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %6 = load i32** %0, align 4
  store i32* %6, i32** %1, align 4
  br label %startup_oil6.return

startup_oil6.return:                              ; preds = %startup_oil6.if.else
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !26
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !32
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %startup_oil7.return

startup_oil7.return:                              ; preds = %startup_oil7.entry
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !34
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  %0 = alloca i32, align 4, !ConsumedBy !36
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  store i32 1, i32* %0, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !12, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23}
!23 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!24 = metadata !{metadata !25}
!25 = metadata !{metadata !14, metadata !"LocalReference", i32 0}
!26 = metadata !{metadata !27, metadata !28, metadata !29, metadata !30, metadata !31}
!27 = metadata !{metadata !6, metadata !"0"}
!28 = metadata !{metadata !8, metadata !"1"}
!29 = metadata !{metadata !10, metadata !"0"}
!30 = metadata !{metadata !14, metadata !"0"}
!31 = metadata !{metadata !16, metadata !"1"}
!32 = metadata !{metadata !33}
!33 = metadata !{metadata !10, metadata !"LocalReference", i32 0}
!34 = metadata !{metadata !35}
!35 = metadata !{metadata !6, metadata !"LocalReference", i32 0}
!36 = metadata !{metadata !37}
!37 = metadata !{metadata !8, metadata !"Scalar", i32 0}

----------Adding sync edges to dangling HyperOps----------

-----------Re-routing sync edges from end hyperop to the newly created end HyperOp-----------
whats in module now?; ModuleID = './Compilation_Error/startupoil.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@OIL_PUMP_CMD_MAX_PULSE_WIDTH = global float 0x3FEE147AE0000000, align 4
@startup_oil.output = internal global [2 x float] zeroinitializer, align 4
@redefine_in_a = common global [3 x i32] zeroinitializer, align 4
@redefine_out_b = common global [2 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define i32 @asl_open_oil_valve() #0 {
entry:
  ret i32 1
}

; Function Attrs: nounwind
define float @regulation_oil(i32* %input) #0 {
entry:
  %input.addr = alloca i32*, align 4
  %current_nh = alloca float, align 4
  %oil_pump_cmd = alloca float, align 4
  %var1 = alloca float, align 4
  %var2 = alloca float, align 4
  %var3 = alloca float, align 4
  %var4 = alloca float, align 4
  %var5 = alloca float, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 0
  %1 = bitcast i32* %arrayidx to float*
  %2 = load float* %1, align 4
  store float %2, float* %current_nh, align 4
  store float 0.000000e+00, float* %oil_pump_cmd, align 4
  store float 0x3D147DCB00000000, float* %var1, align 4
  store float 0x3E191525E0000000, float* %var2, align 4
  store float 0x3F063AD4E0000000, float* %var3, align 4
  store float 0x3FA7A786C0000000, float* %var4, align 4
  store float 0x3FF147AE20000000, float* %var5, align 4
  %3 = load float* %current_nh, align 4
  %cmp = fcmp ogt float %3, 3.500000e+03
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %4 = load float* %var1, align 4
  %5 = load float* %current_nh, align 4
  %mul = fmul float %4, %5
  %6 = load float* %current_nh, align 4
  %mul1 = fmul float %mul, %6
  %7 = load float* %var2, align 4
  %8 = load float* %current_nh, align 4
  %mul2 = fmul float %7, %8
  %9 = load float* %current_nh, align 4
  %mul3 = fmul float %mul2, %9
  %sub = fsub float %mul1, %mul3
  %10 = load float* %var3, align 4
  %11 = load float* %current_nh, align 4
  %mul4 = fmul float %10, %11
  %add = fadd float %sub, %mul4
  %12 = load float* %var4, align 4
  %add5 = fadd float %add, %12
  %13 = load float* %var5, align 4
  %mul6 = fmul float %add5, %13
  store float %mul6, float* %oil_pump_cmd, align 4
  %14 = load float* %oil_pump_cmd, align 4
  %cmp7 = fcmp olt float %14, 3.000000e+00
  br i1 %cmp7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  store float 3.000000e+00, float* %oil_pump_cmd, align 4
  br label %if.end11

if.else:                                          ; preds = %if.then
  %15 = load float* %oil_pump_cmd, align 4
  %16 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %cmp9 = fcmp ogt float %15, %16
  br i1 %cmp9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.else
  %17 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %17, float* %oil_pump_cmd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %entry
  %18 = load float* %oil_pump_cmd, align 4
  ret float %18
}

; Function Attrs: nounwind
define float* @startup_oil(i32* %input) #0 {
entry:
  %retval = alloca float*, align 4
  %input.addr = alloca i32*, align 4
  store i32* %input, i32** %input.addr, align 4
  %0 = load i32** %input.addr, align 4
  %arrayidx = getelementptr inbounds i32* %0, i32 1
  %1 = load i32* %arrayidx, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %startup_oil7.entry, %entry
  %call = call i32 @asl_open_oil_valve()
  br label %newName0

newName0:                                         ; preds = %if.then
  %conv = sitofp i32 %call to float
  store float %conv, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i32** %input.addr, align 4
  %arrayidx1 = getelementptr inbounds i32* %2, i32 2
  %3 = bitcast i32* %arrayidx1 to float*
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %5 = load i32** %input.addr, align 4
  br label %newName01

newName01:                                        ; preds = %if.else
  %call2 = call float @regulation_oil(i32* %5)
  br label %newName02

newName02:                                        ; preds = %newName01
  store float %call2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %retval
  br label %return

return:                                           ; preds = %newName02, %newName0
  %6 = load float** %retval
  ret float* %6
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %newName0

newName0:                                         ; preds = %entry
  %call = call float* @startup_oil(i32* %4)
  br label %newName01

newName01:                                        ; preds = %newName0
  %output = alloca float*, align 4
  store float* %call, float** %output, align 4
  %5 = load float** %output, align 4
  %arrayidx = getelementptr inbounds float* %5, i32 0
  %6 = load float* %arrayidx, align 4
  store float %6, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %7 = load float** %output, align 4
  %arrayidx1 = getelementptr inbounds float* %7, i32 1
  %8 = load float* %arrayidx1, align 4
  store float %8, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = getelementptr inbounds float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, i32 0
  store float 0x3FEE147AE0000000, float* %0, align 4
  %1 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 0
  store float 0.000000e+00, float* %1, align 4
  %2 = getelementptr inbounds [2 x float]* @startup_oil.output, i32 0, i32 1
  store float 0.000000e+00, float* %2, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !18
  store i32* getelementptr inbounds ([3 x i32]* @redefine_in_a, i32 0, i32 0), i32** %3
  %4 = load i32** %3
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.entry
  ret void
}

define void @redefine_start2(float*) {
redefine_start2.newName01:
  %1 = alloca float*, align 4
  store float* %0, float** %1, align 4
  %2 = load float** %1, align 4
  %3 = getelementptr inbounds float* %2, i32 0
  %4 = load float* %3, align 4
  store float %4, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 0), align 4
  %5 = load float** %1, align 4
  %6 = getelementptr inbounds float* %5, i32 1
  %7 = load float* %6, align 4
  store float %7, float* getelementptr inbounds ([2 x float]* @redefine_out_b, i32 0, i32 1), align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.newName01
  ret void
}

define void @startup_oil3(float**) {
startup_oil3.return1:
  %1 = alloca float*, align 4, !ConsumedBy !20
  %2 = load float** %0
  store float* %2, float** %1, align 4
  br label %startup_oil3.return

startup_oil3.return:                              ; preds = %startup_oil3.return1
  ret void
}

define void @startup_oil4(float*) {
startup_oil4.newName02:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = load float* %0
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil4.return

startup_oil4.return:                              ; preds = %startup_oil4.newName02
  ret void
}

define void @startup_oil5(i32 inreg) {
startup_oil5.newName0:
  %1 = alloca float*, align 4, !ConsumedBy !22
  %2 = sitofp i32 %0 to float
  store float %2, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  store float 0.000000e+00, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 1), align 4
  store float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), float** %1
  br label %startup_oil5.return

startup_oil5.return:                              ; preds = %startup_oil5.newName0
  ret void
}

define void @startup_oil6(i32**) {
startup_oil6.if.else:
  %1 = alloca i32*, align 4, !ConsumedBy !24
  %2 = load i32** %0, align 4
  %3 = getelementptr inbounds i32* %2, i32 2
  %4 = bitcast i32* %3 to float*
  %5 = load float* %4, align 4
  store float %5, float* getelementptr inbounds ([2 x float]* @startup_oil.output, i32 0, i32 0), align 4
  %6 = load i32** %0, align 4
  store i32* %6, i32** %1, align 4
  br label %startup_oil6.return

startup_oil6.return:                              ; preds = %startup_oil6.if.else
  ret void
}

define void @startup_oil7(i32*) {
startup_oil7.entry:
  %1 = alloca i1, align 4, !Controls !26
  %2 = alloca float*, align 4
  %3 = alloca i32*, align 4, !ConsumedBy !32
  store i32* %0, i32** %3, align 4
  %4 = load i32** %3, align 4
  %5 = getelementptr inbounds i32* %4, i32 1
  %6 = load i32* %5, align 4
  %7 = icmp eq i32 %6, 0
  store i1 %7, i1* %1, align 4
  br i1 %7, label %if.then, label %startup_oil7.return

startup_oil7.return:                              ; preds = %startup_oil7.entry
  ret void
}

define void @regulation_oil8(i32*) {
regulation_oil8.entry:
  %1 = alloca float, align 4, !ConsumedBy !34
  %2 = alloca i32*, align 4
  %3 = alloca float, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %6 = alloca float, align 4
  %7 = alloca float, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  store i32* %0, i32** %2, align 4
  %10 = load i32** %2, align 4
  %11 = getelementptr inbounds i32* %10, i32 0
  %12 = bitcast i32* %11 to float*
  %13 = load float* %12, align 4
  store float %13, float* %3, align 4
  store float 0.000000e+00, float* %4, align 4
  store float 0x3D147DCB00000000, float* %5, align 4
  store float 0x3E191525E0000000, float* %6, align 4
  store float 0x3F063AD4E0000000, float* %7, align 4
  store float 0x3FA7A786C0000000, float* %8, align 4
  store float 0x3FF147AE20000000, float* %9, align 4
  %14 = load float* %3, align 4
  %15 = fcmp ogt float %14, 3.500000e+03
  br i1 %15, label %regulation_oil8.if.then, label %regulation_oil8.if.end12

regulation_oil8.if.then:                          ; preds = %regulation_oil8.entry
  %16 = load float* %5, align 4
  %17 = load float* %3, align 4
  %18 = fmul float %16, %17
  %19 = load float* %3, align 4
  %20 = fmul float %18, %19
  %21 = load float* %6, align 4
  %22 = load float* %3, align 4
  %23 = fmul float %21, %22
  %24 = load float* %3, align 4
  %25 = fmul float %23, %24
  %26 = fsub float %20, %25
  %27 = load float* %7, align 4
  %28 = load float* %3, align 4
  %29 = fmul float %27, %28
  %30 = fadd float %26, %29
  %31 = load float* %8, align 4
  %32 = fadd float %30, %31
  %33 = load float* %9, align 4
  %34 = fmul float %32, %33
  store float %34, float* %4, align 4
  %35 = load float* %4, align 4
  %36 = fcmp olt float %35, 3.000000e+00
  br i1 %36, label %regulation_oil8.if.then8, label %regulation_oil8.if.else

regulation_oil8.if.else:                          ; preds = %regulation_oil8.if.then
  %37 = load float* %4, align 4
  %38 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  %39 = fcmp ogt float %37, %38
  br i1 %39, label %regulation_oil8.if.then10, label %regulation_oil8.if.end

regulation_oil8.if.then10:                        ; preds = %regulation_oil8.if.else
  %40 = load float* @OIL_PUMP_CMD_MAX_PULSE_WIDTH, align 4
  store float %40, float* %4, align 4
  br label %regulation_oil8.if.end

regulation_oil8.if.then8:                         ; preds = %regulation_oil8.if.then
  store float 3.000000e+00, float* %4, align 4
  br label %regulation_oil8.if.end11

regulation_oil8.if.end:                           ; preds = %regulation_oil8.if.then10, %regulation_oil8.if.else
  br label %regulation_oil8.if.end11

regulation_oil8.if.end11:                         ; preds = %regulation_oil8.if.end, %regulation_oil8.if.then8
  br label %regulation_oil8.if.end12

regulation_oil8.if.end12:                         ; preds = %regulation_oil8.if.end11, %regulation_oil8.entry
  %41 = load float* %4, align 4
  store float %41, float* %1, align 4
  br label %regulation_oil8.return

regulation_oil8.return:                           ; preds = %regulation_oil8.if.end12
  ret void
}

define void @asl_open_oil_valve9() {
asl_open_oil_valve9.entry:
  %0 = alloca i32, align 4, !ConsumedBy !36
  br label %asl_open_oil_valve9.return

asl_open_oil_valve9.return:                       ; preds = %asl_open_oil_valve9.entry
  store i32 1, i32* %0, align 4
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Exit", metadata !2}
!4 = metadata !{metadata !"HyperOp", void (float**)* @startup_oil3, metadata !"Static"}
!5 = metadata !{metadata !"Intermediate", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (float*)* @startup_oil4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !"HyperOp", void (i32)* @startup_oil5, metadata !"Static"}
!9 = metadata !{metadata !"Intermediate", metadata !8}
!10 = metadata !{metadata !"HyperOp", void (i32**)* @startup_oil6, metadata !"Static"}
!11 = metadata !{metadata !"Intermediate", metadata !10}
!12 = metadata !{metadata !"HyperOp", void (i32*)* @startup_oil7, metadata !"Static"}
!13 = metadata !{metadata !"Intermediate", metadata !12}
!14 = metadata !{metadata !"HyperOp", void (i32*)* @regulation_oil8, metadata !"Static"}
!15 = metadata !{metadata !"Intermediate", metadata !14}
!16 = metadata !{metadata !"HyperOp", void ()* @asl_open_oil_valve9, metadata !"Static"}
!17 = metadata !{metadata !"Intermediate", metadata !16}
!18 = metadata !{metadata !19}
!19 = metadata !{metadata !12, metadata !"LocalReference", i32 0}
!20 = metadata !{metadata !21}
!21 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!22 = metadata !{metadata !23}
!23 = metadata !{metadata !4, metadata !"LocalReference", i32 0}
!24 = metadata !{metadata !25}
!25 = metadata !{metadata !14, metadata !"LocalReference", i32 0}
!26 = metadata !{metadata !27, metadata !28, metadata !29, metadata !30, metadata !31}
!27 = metadata !{metadata !6, metadata !"0"}
!28 = metadata !{metadata !8, metadata !"1"}
!29 = metadata !{metadata !10, metadata !"0"}
!30 = metadata !{metadata !14, metadata !"0"}
!31 = metadata !{metadata !16, metadata !"1"}
!32 = metadata !{metadata !33}
!33 = metadata !{metadata !10, metadata !"LocalReference", i32 0}
!34 = metadata !{metadata !35}
!35 = metadata !{metadata !6, metadata !"LocalReference", i32 0}
!36 = metadata !{metadata !37}
!37 = metadata !{metadata !8, metadata !"Scalar", i32 0}

-----------Deleting unused functions-----------
deleting contents of function:asl_open_oil_valve
deleting contents of function:regulation_oil
deleting contents of function:startup_oil
While deleting: label %if.then
Use still stuck around after Def is destroyed:opt: /home/arka/Workspace/work/MM_Compiler_latest/include/llvm/Support/Casting.h:97: static bool llvm::isa_impl_cl<To, const From*>::doit(const From*) [with To = llvm::Instruction; From = llvm::Value]: Assertion `Val && "isa<> used on a null pointer"' failed.
0  opt                    0x0000000001277552 llvm::sys::PrintStackTrace(_IO_FILE*) + 34
1  opt                    0x00000000012771e4
2  libpthread.so.0        0x00002b2347d5a330
3  libc.so.6              0x00002b2348c5fc37 gsignal + 55
4  libc.so.6              0x00002b2348c63028 abort + 328
5  libc.so.6              0x00002b2348c58bf6
6  libc.so.6              0x00002b2348c58ca2
7  opt                    0x00000000012247b3 llvm::TypeFinder::run(llvm::Module const&, bool) + 995
8  opt                    0x0000000001154f2a
9  opt                    0x000000000115b4e9 llvm::Value::print(llvm::raw_ostream&, llvm::AssemblyAnnotationWriter*) const + 457
10 opt                    0x0000000001226e97 llvm::Value::~Value() + 359
11 opt                    0x0000000001166c99 llvm::BasicBlock::~BasicBlock() + 9
12 opt                    0x00000000011a72ca llvm::Function::dropAllReferences() + 74
13 HyperOpCreationPass.so 0x00002b2349009043
14 opt                    0x0000000001214e5b llvm::MPPassManager::runOnModule(llvm::Module&) + 603
15 opt                    0x000000000121503f llvm::PassManagerImpl::run(llvm::Module&) + 223
16 opt                    0x00000000005a9de0 main + 2688
17 libc.so.6              0x00002b2348c4af45 __libc_start_main + 245
18 opt                    0x00000000005c8b63
Stack dump:
0.	Program arguments: /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/opt -debug --load /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/../lib/HyperOpCreationPass.so --HyperOpCreationPass -S ./Compilation_Error/startupoil.ll -o ./Compilation_Error/startupoil_HyOpPass.ll 
1.	Running pass 'Pass to create HyperOps' on module './Compilation_Error/startupoil.ll'.
Aborted
