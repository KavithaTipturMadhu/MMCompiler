Args: /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/llc --mattr=+has4ce --mtriple redefine -debug ./Working/eicas_0_HyOpPass.ll -o ./Working/eicas_0.as 

Features:+has4ce
CPU:REDEFINE

CGP: Found      local addrmode: [Base:@redefine_in_eicas_egt]
CGP: Found      local addrmode: [Base:%0]
Computing probabilities for redefine_start1.return
Computing probabilities for redefine_start1.entry
new hop:redefine_start1
new hyop#0:redefine_start1
new hop:redefine_start2
new hyop#1:redefine_start2
new hop:eicas_calculator3
new hyop#2:eicas_calculator3
problems setting inputs?
skipping abort
source hop:redefine_start1
frame size for hop redefine_start1:4
source hop:redefine_start2
source hop:eicas_calculator3
frame size for hop eicas_calculator3:12
max mem frame size:12
digraph{
redefine_start1[label="Name:redefine_start1,Dom:NULL, PostDom:NULL,Map:0:0, Context frame:0,SyncCount:1"];
redefine_start1->eicas_calculator3[label=scalar0];
redefine_start2[label="Name:redefine_start2,Dom:NULL, PostDom:NULL,Map:0:0, Context frame:0,SyncCount:0"];
eicas_calculator3[label="Name:eicas_calculator3,Dom:NULL, PostDom:NULL,Map:0:0, Context frame:0,SyncCount:0"];
eicas_calculator3->redefine_start2[label=scalar0];
}
Setting domf of node redefine_start1 to size 0
Setting domf of node redefine_start2 to size 0
Setting domf of node eicas_calculator3 to size 0
idom of node:redefine_start1
idom of node:eicas_calculator3

------
forwarding address to redefine_start1:

------
forwarding address to redefine_start2:

------
forwarding address to eicas_calculator3:

Dominant sequence computed:
redefine_start1->eicas_calculator3->redefine_start2->

Dominant sequence computed:
redefine_start1->eicas_calculator3->redefine_start2->
before merging, num of clusters:1
each cluster:
redefine_start1,eicas_calculator3,redefine_start2,
Minimizing ordering edges
setting context frame id of redefine_start1 to 0
setting context frame id of eicas_calculator3 to 1
setting context frame id of redefine_start2 to 2
Computing whether there is a control/scalar path between a pair of HyperOps communicating via memory and adding sync edges if there is no control path
If the producer and consumer are mapped to different CRs, treat them as localrefs only instead of scalars to avoid reconciles
problems setting inputs?
generated cfg:Setting domf of node redefine_start1 to size 0
Setting domf of node redefine_start2 to size 0
Setting domf of node eicas_calculator3 to size 0
idom of node:redefine_start1
idom of node:eicas_calculator3
Delivering reaching predicate with decrement count in case operands to be delivered are on the non taken path
before decrementing sync, graph:Decrementing sync count for nodes with sync edges coming from mutually exclusive paths
updating node with incoming sync edges redefine_start1
after minimizing cluster and converting scalar edges to local refs, graph:digraph{
redefine_start1[label="Name:redefine_start1,Dom:NULL, PostDom:eicas_calculator3,Map:0:0, Context frame:0,SyncCount:1"];
redefine_start1->eicas_calculator3[label=scalar0];
redefine_start2[label="Name:redefine_start2,Dom:eicas_calculator3, PostDom:NULL,Map:0:0, Context frame:2,SyncCount:0"];
eicas_calculator3[label="Name:eicas_calculator3,Dom:redefine_start1, PostDom:redefine_start2,Map:0:0, Context frame:1,SyncCount:0"];
eicas_calculator3->redefine_start2[label=scalar0];
}
num of clusters:1
num constraints:0
setting target resource 0
setting target resource 0
setting target resource 0
digraph{
redefine_start1[label="Name:redefine_start1,Dom:NULL, PostDom:eicas_calculator3,Map:0:0, Context frame:0,SyncCount:1"];
redefine_start1->eicas_calculator3[label=scalar0];
redefine_start2[label="Name:redefine_start2,Dom:eicas_calculator3, PostDom:NULL,Map:0:0, Context frame:2,SyncCount:0"];
eicas_calculator3[label="Name:eicas_calculator3,Dom:redefine_start1, PostDom:redefine_start2,Map:0:0, Context frame:1,SyncCount:0"];
eicas_calculator3->redefine_start2[label=scalar0];
}



=== redefine_start1
visiting load instruction   %1 = load i32* @redefine_in_eicas_egt, align 4
I was here to add @redefine_in_eicas_egt = common global i32 0, align 4
with I type i32and sd value :0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0
new load?0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]>
dag after load is dealt with?SelectionDAG has 5 nodes:
  0x28aee90: i32 = Constant<0>

    0x2891968: ch = EntryToken

    0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0

    0x28aef90: i32 = undef

  0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]>

  0x2891968: ch = EntryToken


store visit is after?  store i32 %1, i32* %0, align 4
I was here to add   %0 = alloca i32, align 4, !ConsumedBy !6
whats in dag after store?SelectionDAG has 7 nodes:
  0x28aee90: i32 = Constant<0>

  0x28aef90: i32 = undef [ORD=1]

    0x2891968: ch = EntryToken [ORD=1]

    0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0 [ORD=1]

    0x28aef90: <multiple use>
  0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1]

    0x28af090: <multiple use>
    0x28af090: <multiple use>
    0x28af190: i32 = FrameIndex<0> [ORD=2]

    0x28aef90: <multiple use>
  0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2]


Initial selection DAG: BB#0 'redefine_start1:redefine_start1.entry'
SelectionDAG has 7 nodes:
  0x28aee90: i32 = Constant<0>

  0x28aef90: i32 = undef [ORD=1]

    0x2891968: ch = EntryToken [ORD=1]

    0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0 [ORD=1]

    0x28aef90: <multiple use>
  0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1]

    0x28af090: <multiple use>
    0x28af090: <multiple use>
    0x28af190: i32 = FrameIndex<0> [ORD=2]

    0x28aef90: <multiple use>
  0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2]


Optimized lowered selection DAG: BB#0 'redefine_start1:redefine_start1.entry'
SelectionDAG has 6 nodes:
  0x28aef90: i32 = undef [ORD=1]

    0x2891968: ch = EntryToken [ORD=1]

    0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0 [ORD=1]

    0x28aef90: <multiple use>
  0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1]

    0x28af090: <multiple use>
    0x28af090: <multiple use>
    0x28af190: i32 = FrameIndex<0> [ORD=2]

    0x28aef90: <multiple use>
  0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2]


Legally typed node: 0x28af190: i32 = FrameIndex<0> [ORD=2] [ID=0]

Legally typed node: 0x28aef90: i32 = undef [ORD=1] [ID=0]

Legally typed node: 0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0 [ORD=1] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=1] [ID=0]

Legally typed node: 0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=0]

Legally typed node: 0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2] [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28af290 [ID=0]

Type-legalized selection DAG: BB#0 'redefine_start1:redefine_start1.entry'
SelectionDAG has 6 nodes:
  0x28aef90: i32 = undef [ORD=1] [ID=-3]

    0x2891968: ch = EntryToken [ORD=1] [ID=-3]

    0x28aed90: i32 = GlobalAddress<i32* @redefine_in_eicas_egt> 0 [ORD=1] [ID=-3]

    0x28aef90: <multiple use>
  0x28af090: i32,ch = load 0x2891968, 0x28aed90, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=-3]

    0x28af090: <multiple use>
    0x28af090: <multiple use>
    0x28af190: i32 = FrameIndex<0> [ORD=2] [ID=-3]

    0x28aef90: <multiple use>
  0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2] [ID=-3]


Legalized selection DAG: BB#0 'redefine_start1:redefine_start1.entry'
SelectionDAG has 10 nodes:
  0x28aef90: i32 = undef [ORD=1] [ID=2]

    0x2891968: ch = EntryToken [ORD=1] [ID=0]

        0x28aee90: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=2]

      0x28af490: i32 = REDEFINEISD::Hi 0x28aee90

        0x28af390: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=3]

      0x28af590: i32 = REDEFINEISD::Lo 0x28af390

    0x28af690: i32 = add 0x28af490, 0x28af590

    0x28aef90: <multiple use>
  0x28af090: i32,ch = load 0x2891968, 0x28af690, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=4]

    0x28af090: <multiple use>
    0x28af090: <multiple use>
    0x28af190: i32 = FrameIndex<0> [ORD=2] [ID=3]

    0x28aef90: <multiple use>
  0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2] [ID=5]


Optimized legalized selection DAG: BB#0 'redefine_start1:redefine_start1.entry'
SelectionDAG has 10 nodes:
  0x28aef90: i32 = undef [ORD=1] [ID=2]

    0x2891968: ch = EntryToken [ORD=1] [ID=0]

        0x28aee90: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=2]

      0x28af490: i32 = REDEFINEISD::Hi 0x28aee90

        0x28af390: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=3]

      0x28af590: i32 = REDEFINEISD::Lo 0x28af390

    0x28af690: i32 = add 0x28af490, 0x28af590

    0x28aef90: <multiple use>
  0x28af090: i32,ch = load 0x2891968, 0x28af690, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=4]

    0x28af090: <multiple use>
    0x28af090: <multiple use>
    0x28af190: i32 = FrameIndex<0> [ORD=2] [ID=3]

    0x28aef90: <multiple use>
  0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2] [ID=5]


===== Instruction selection begins: BB#0 'redefine_start1.entry'
ISEL: Starting pattern match on root node: 0x28af290: ch = store 0x28af090:1, 0x28af090, 0x28af190, 0x28aef90<ST4[%0]> [ORD=2] [ID=9]

  Morphed node: 0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2]

ISEL: Match complete!
=> 0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2]

ISEL: Starting pattern match on root node: 0x28af090: i32,ch = load 0x2891968, 0x28af690, 0x28aef90<LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=8]

  Initial Opcode index to 5
  TypeSwitch[i32] from 10 to 14
  Morphed node: 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1]

ISEL: Match complete!
=> 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1]

ISEL: Starting pattern match on root node: 0x28af690: i32 = add 0x28af490, 0x28af590 [ID=7]

  Initial Opcode index to 493
  Match failed at index 499
  Continuing at 516
  Morphed node: 0x28af690: i32 = ADD 0x28af590, 0x28af490

ISEL: Match complete!
=> 0x28af690: i32 = ADD 0x28af590, 0x28af490

ISEL: Starting pattern match on root node: 0x28af590: i32 = REDEFINEISD::Lo 0x28af390 [ID=6]

  Initial Opcode index to 1204
  Morphed node: 0x28af590: i32 = ADDI 0x28aef90, 0x28af390

ISEL: Match complete!
=> 0x28af590: i32 = ADDI 0x28aef90, 0x28af390

ISEL: Starting pattern match on root node: 0x28af490: i32 = REDEFINEISD::Hi 0x28aee90 [ID=5]

  Initial Opcode index to 1186
  Morphed node: 0x28af490: i32 = LUI 0x28aee90

ISEL: Match complete!
=> 0x28af490: i32 = LUI 0x28aee90

=> 0x28af390: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=3]

=> 0x28aee90: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=2]

=> 0x2891968: ch = EntryToken [ORD=1]

===== Instruction selection ends:
Selected selection DAG: BB#0 'redefine_start1:redefine_start1.entry'
SelectionDAG has 13 nodes:
        0x28aef90: i32 = Register %zero

        0x28af390: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=3]

      0x28af590: i32 = ADDI 0x28aef90, 0x28af390

        0x28aee90: i32 = TargetGlobalAddress<i32* @redefine_in_eicas_egt> 0 [TF=2]

      0x28af490: i32 = LUI 0x28aee90

    0x28af690: i32 = ADD 0x28af590, 0x28af490

    0x28aed90: <multiple use>
    0x2891968: ch = EntryToken [ORD=1]

  0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1]

  0x28aed90: i32 = TargetConstant<0>

    0x28af090: <multiple use>
      0x28af790: i32 = Register %t5

      0x28af890: i32 = TargetFrameIndex<0>

    0x28af190: i32 = ADDI 0x28af790, 0x28af890 [ORD=2]

    0x28aed90: <multiple use>
    0x28af090: <multiple use>
  0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2]


********** List Scheduling BB#0 'redefine_start1.entry' **********
SU(0): 0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2] [ID=0]

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
   val SU(1): Latency=1
   ch  SU(2): Latency=1

SU(1): 0x28af190: i32 = ADDI 0x28af790, 0x28af890 [ORD=2] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1

SU(2): 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=2]

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(0): Latency=1
   ch  SU(0): Latency=1

SU(3): 0x28af690: i32 = ADD 0x28af590, 0x28af490 [ID=3]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(5): Latency=1
   val SU(4): Latency=1
  Successors:
   val SU(2): Latency=1

SU(4): 0x28af490: i32 = LUI 0x28aee90 [ID=4]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(3): Latency=1

SU(5): 0x28af590: i32 = ADDI 0x28aef90, 0x28af390 [ID=5]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(3): Latency=1


Examining Available:
Height 0: SU(0): 0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2] [ID=0]


*** Scheduling [0]: SU(0): 0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2] [ID=0]


Examining Available:
Height 1: SU(1): 0x28af190: i32 = ADDI 0x28af790, 0x28af890 [ORD=2] [ID=1]

Height 1: SU(2): 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=2]


*** Scheduling [1]: SU(1): 0x28af190: i32 = ADDI 0x28af790, 0x28af890 [ORD=2] [ID=1]


Examining Available:
Height 1: SU(2): 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=2]


*** Scheduling [2]: SU(2): 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=2]


Examining Available:
Height 3: SU(3): 0x28af690: i32 = ADD 0x28af590, 0x28af490 [ID=3]


*** Scheduling [3]: SU(3): 0x28af690: i32 = ADD 0x28af590, 0x28af490 [ID=3]


Examining Available:
Height 4: SU(5): 0x28af590: i32 = ADDI 0x28aef90, 0x28af390 [ID=5]

Height 4: SU(4): 0x28af490: i32 = LUI 0x28aee90 [ID=4]


*** Scheduling [4]: SU(5): 0x28af590: i32 = ADDI 0x28aef90, 0x28af390 [ID=5]


Examining Available:
Height 4: SU(4): 0x28af490: i32 = LUI 0x28aee90 [ID=4]


*** Scheduling [5]: SU(4): 0x28af490: i32 = LUI 0x28aee90 [ID=4]

*** Final schedule ***
SU(4): 0x28af490: i32 = LUI 0x28aee90 [ID=4]

SU(5): 0x28af590: i32 = ADDI 0x28aef90, 0x28af390 [ID=5]

SU(3): 0x28af690: i32 = ADD 0x28af590, 0x28af490 [ID=3]

SU(2): 0x28af090: i32,ch = LW 0x28af690, 0x28aed90, 0x2891968<Mem:LD4[@redefine_in_eicas_egt]> [ORD=1] [ID=2]

SU(1): 0x28af190: i32 = ADDI 0x28af790, 0x28af890 [ORD=2] [ID=1]

SU(0): 0x28af290: ch = SW 0x28af090, 0x28af190, 0x28aed90, 0x28af090:1<Mem:ST4[%0]> [ORD=2] [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#1 'redefine_start1:redefine_start1.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken


Optimized lowered selection DAG: BB#1 'redefine_start1:redefine_start1.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken


Legally typed node: 0x2891968: ch = EntryToken [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x2891968 [ID=0]

Type-legalized selection DAG: BB#1 'redefine_start1:redefine_start1.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken [ID=-3]


Legalized selection DAG: BB#1 'redefine_start1:redefine_start1.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken [ID=0]


Optimized legalized selection DAG: BB#1 'redefine_start1:redefine_start1.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken [ID=0]


===== Instruction selection begins: BB#1 'redefine_start1.return'
=> 0x2891968: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#1 'redefine_start1:redefine_start1.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken


********** List Scheduling BB#1 'redefine_start1.return' **********
*** Final schedule ***

Total amount of phi nodes to update: 0

*** Tail-duplicating BB#1

Merging into block: BB#0: derived from LLVM BB %redefine_start1.entry
	%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
	%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
	%vreg2<def> = ADD %vreg1<kill>, %vreg0<kill>; GR32Bit:%vreg2,%vreg1,%vreg0
	%vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
	%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
	SW %vreg3<kill>, %vreg4<kill>, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
    Successors according to CFG: BB#1
From MBB: BB#1: derived from LLVM BB %redefine_start1.return
    Predecessors according to CFG: BB#0

Removing MBB: BB#1: derived from LLVM BB %redefine_start1.return
# Machine code for function redefine_start1: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

0B	BB#0: derived from LLVM BB %redefine_start1.entry
16B		%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
48B		%vreg2<def> = ADD %vreg1<kill>, %vreg0<kill>; GR32Bit:%vreg2,%vreg1,%vreg0
64B		%vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
80B		%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
96B		SW %vreg3<kill>, %vreg4<kill>, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4

# End machine code for function redefine_start1.

********** Stack Coloring **********
********** Function: redefine_start1
Found 0 markers and 1 slots
Slot structure:
Slot #0 - 4 bytes.
Total Stack size: 4 bytes

Will not try to merge slots.
Removed 0 markers.
******** Pre-regalloc Machine LICM: redefine_start1 ********
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: redefine_start1
********** PROCESS IMPLICIT DEFS **********
********** Function: redefine_start1
********** REWRITING TWO-ADDR INSTRS **********
********** Function: redefine_start1
# Machine code for function redefine_start1: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

0B	BB#0: derived from LLVM BB %redefine_start1.entry
16B		%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
48B		%vreg2<def> = ADD %vreg1<kill>, %vreg0<kill>; GR32Bit:%vreg2,%vreg1,%vreg0
64B		%vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
80B		%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
96B		SW %vreg3<kill>, %vreg4<kill>, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4

# End machine code for function redefine_start1.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%vreg0 = [16r,48r:0)  0@16r
%vreg1 = [32r,48r:0)  0@32r
%vreg2 = [48r,64r:0)  0@48r
%vreg3 = [64r,96r:0)  0@64r
%vreg4 = [80r,96r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function redefine_start1: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

0B	BB#0: derived from LLVM BB %redefine_start1.entry
16B		%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
48B		%vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
64B		%vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
80B		%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
96B		SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4

# End machine code for function redefine_start1.

********** SIMPLE REGISTER COALESCING **********
********** Function: redefine_start1
********** JOINING INTERVALS ***********
redefine_start1.entry:
Trying to inflate 0 regs.
********** INTERVALS **********
%vreg0 = [16r,48r:0)  0@16r
%vreg1 = [32r,48r:0)  0@32r
%vreg2 = [48r,64r:0)  0@48r
%vreg3 = [64r,96r:0)  0@64r
%vreg4 = [80r,96r:0)  0@80r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function redefine_start1: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

0B	BB#0: derived from LLVM BB %redefine_start1.entry
16B		%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
48B		%vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
64B		%vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
80B		%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
96B		SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4

# End machine code for function redefine_start1.

Before MISched:
# Machine code for function redefine_start1: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

BB#0: derived from LLVM BB %redefine_start1.entry
	%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
	%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
	%vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
	%vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
	%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
	SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4

# End machine code for function redefine_start1.


-------------
Starting new basic block BB#0
********** MI Scheduling **********
redefine_start1:BB#0 redefine_start1.entry
  From: %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
    To: End Remaining: 0
Max Pressure: GR32Bit=2
Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 2
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 0
  SU(3) in tree 0
  SU(4) in tree 0
  SU(5) in tree 0
SU(0):   %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
   val SU(2): Latency=5 Reg=%vreg0

SU(1):   %vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
   val SU(2): Latency=5 Reg=%vreg1

SU(2):   %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 5
  Height             : 7
  Predecessors:
   val SU(1): Latency=5 Reg=%vreg1
   val SU(0): Latency=5 Reg=%vreg0
  Successors:
   val SU(3): Latency=5 Reg=%vreg2

SU(3):   %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 10
  Height             : 2
  Predecessors:
   val SU(2): Latency=5 Reg=%vreg2
  Successors:
   val SU(5): Latency=2 Reg=%vreg3

SU(4):   %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(5): Latency=5 Reg=%vreg4

SU(5):   SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 12
  Height             : 0
  Predecessors:
   val SU(3): Latency=2 Reg=%vreg3
   val SU(4): Latency=5 Reg=%vreg4
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
   val SU(2): Latency=5 Reg=%vreg0

SU(1):   %vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 12
  Successors:
   val SU(2): Latency=5 Reg=%vreg1

SU(2):   %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 5
  Height             : 7
  Predecessors:
   val SU(1): Latency=5 Reg=%vreg1
   val SU(0): Latency=5 Reg=%vreg0
  Successors:
   val SU(3): Latency=5 Reg=%vreg2

SU(3):   %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 10
  Height             : 2
  Predecessors:
   val SU(2): Latency=5 Reg=%vreg2
  Successors:
   val SU(5): Latency=2 Reg=%vreg3

SU(4):   %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(5): Latency=5 Reg=%vreg4

SU(5):   SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 12
  Height             : 0
  Predecessors:
   val SU(3): Latency=2 Reg=%vreg3
   val SU(4): Latency=5 Reg=%vreg4
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(4)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
handleMove 80B -> 8B: %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
     %vreg4:	[80r,96r:0)  0@80r
        -->	[8r,96r:0)  0@8r
     t5:	EMPTY
        -->	EMPTY
Pick node SU(0)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
Pick node SU(1)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
Pick node SU(2)  ILP: 3 / 6 = 0.5 Tree: 0 @0
Scheduling %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
Pick node SU(3)  ILP: 4 / 11 = 0.363636 Tree: 0 @0
Scheduling %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
Pick node SU(5)  ILP: 6 / 13 = 0.461538 Tree: 0 @0
Scheduling SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
*** Final schedule for BB#0 ***
SU(4):   %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
SU(0):   %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
SU(1):   %vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
SU(2):   %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
SU(3):   %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
SU(5):   SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4


*** Renumbered SlotIndexes 4-28 ***

*** Renumbered SlotIndexes 16-56 ***

*** Renumbered SlotIndexes 28-76 ***

*** Renumbered SlotIndexes 40-104 ***

*** Renumbered SlotIndexes 52-124 ***

*** Renumbered SlotIndexes 64-136 ***

*** Renumbered SlotIndexes 76-148 ***

*** Renumbered SlotIndexes 88-160 ***

*** Renumbered SlotIndexes 100-172 ***

*** Renumbered SlotIndexes 112-184 ***

*** Renumbered SlotIndexes 124-196 ***

*** Renumbered SlotIndexes 136-208 ***

*** Renumbered SlotIndexes 148-220 ***

*** Renumbered SlotIndexes 160-232 ***

*** Renumbered SlotIndexes 172-244 ***

*** Renumbered SlotIndexes 184-256 ***

*** Renumbered SlotIndexes 196-268 ***

*** Renumbered SlotIndexes 208-280 ***

*** Renumbered SlotIndexes 220-292 ***

*** Renumbered SlotIndexes 232-304 ***

*** Renumbered SlotIndexes 244-316 ***

*** Renumbered SlotIndexes 256-328 ***

*** Renumbered SlotIndexes 268-340 ***

*** Renumbered SlotIndexes 280-352 ***

*** Renumbered SlotIndexes 292-364 ***

*** Renumbered SlotIndexes 304-376 ***

*** Renumbered SlotIndexes 316-388 ***

*** Renumbered SlotIndexes 328-400 ***

*** Renumbered SlotIndexes 340-412 ***

*** Renumbered SlotIndexes 352-424 ***

*** Renumbered SlotIndexes 364-436 ***

*** Renumbered SlotIndexes 376-448 ***

*** Renumbered SlotIndexes 388-460 ***

*** Renumbered SlotIndexes 400-472 ***
Partitioning instructions of the region into multiple CEs
instr:  %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
instr:  %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
instr:  %vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
instr:  %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
instr:  %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
instr:  SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
before falloc, state of bb0:BB#0: derived from LLVM BB %redefine_start1.entry
	%vreg5<def> = ADD %t5, %zero; GR32Bit:%vreg5
	%vreg7<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg7
	%vreg8<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg8
	%vreg9<def> = SRLI %vreg8, 12; GR32Bit:%vreg9,%vreg8
	%vreg10<def> = ADD %vreg7, %vreg9; GR32Bit:%vreg10,%vreg7,%vreg9
	%vreg11<def> = ADDI %zero, 12; GR32Bit:%vreg11
	%vreg12<def> = SRLI %t5, 22; GR32Bit:%vreg12
	%vreg13<def> = SRLI %t5, 12; GR32Bit:%vreg13
	%vreg14<def> = ANDI %vreg13, 15; GR32Bit:%vreg14,%vreg13
	%vreg15<def> = SRLI %t5, 6; GR32Bit:%vreg15
	%vreg16<def> = ANDI %vreg15, 63; GR32Bit:%vreg16,%vreg15
	%vreg17<def> = ADDI %zero, 832; GR32Bit:%vreg17
	%vreg18<def> = MUL %vreg12, %vreg17; GR32Bit:%vreg18,%vreg12,%vreg17
	%vreg19<def> = ADDI %zero, 52; GR32Bit:%vreg19
	%vreg20<def> = MUL %vreg14, %vreg19; GR32Bit:%vreg20,%vreg14,%vreg19
	%vreg21<def> = ADD %vreg20, %vreg16; GR32Bit:%vreg21,%vreg20,%vreg16
	%vreg22<def> = ADD %vreg21, %vreg18; GR32Bit:%vreg22,%vreg21,%vreg18
	%vreg23<def> = MUL %vreg22, %vreg11; GR32Bit:%vreg23,%vreg22,%vreg11
	%vreg6<def> = ADD %vreg10, %vreg23; GR32Bit:%vreg6,%vreg10,%vreg23
	%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
	%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
	%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
	%vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
	%vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
	SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
	%vreg24<def> = ADD %t5, %zero; GR32Bit:%vreg24
	%vreg26<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg26
	%vreg27<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg27
	%vreg28<def> = SRLI %vreg27, 12; GR32Bit:%vreg28,%vreg27
	%vreg29<def> = ADD %vreg26, %vreg28; GR32Bit:%vreg29,%vreg26,%vreg28
	%vreg30<def> = ADDI %zero, 12; GR32Bit:%vreg30
	%vreg31<def> = SRLI %t5, 22; GR32Bit:%vreg31
	%vreg32<def> = SRLI %t5, 12; GR32Bit:%vreg32
	%vreg33<def> = ANDI %vreg32, 15; GR32Bit:%vreg33,%vreg32
	%vreg34<def> = SRLI %t5, 6; GR32Bit:%vreg34
	%vreg35<def> = ANDI %vreg34, 63; GR32Bit:%vreg35,%vreg34
	%vreg36<def> = ADDI %zero, 832; GR32Bit:%vreg36
	%vreg37<def> = MUL %vreg31, %vreg36; GR32Bit:%vreg37,%vreg31,%vreg36
	%vreg38<def> = ADDI %zero, 52; GR32Bit:%vreg38
	%vreg39<def> = MUL %vreg33, %vreg38; GR32Bit:%vreg39,%vreg33,%vreg38
	%vreg40<def> = ADD %vreg39, %vreg35; GR32Bit:%vreg40,%vreg39,%vreg35
	%vreg41<def> = ADD %vreg40, %vreg37; GR32Bit:%vreg41,%vreg40,%vreg37
	%vreg42<def> = MUL %vreg41, %vreg30; GR32Bit:%vreg42,%vreg41,%vreg30
	%vreg25<def> = ADD %vreg29, %vreg42; GR32Bit:%vreg25,%vreg29,%vreg42
	%vreg43<def> = ADD %t5, %zero; GR32Bit:%vreg43
	%vreg45<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg45
	%vreg46<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg46
	%vreg47<def> = SRLI %vreg46, 12; GR32Bit:%vreg47,%vreg46
	%vreg48<def> = ADD %vreg45, %vreg47; GR32Bit:%vreg48,%vreg45,%vreg47
	%vreg49<def> = ADDI %zero, 12; GR32Bit:%vreg49
	%vreg50<def> = SRLI %t5, 22; GR32Bit:%vreg50
	%vreg51<def> = SRLI %t5, 12; GR32Bit:%vreg51
	%vreg52<def> = ANDI %vreg51, 15; GR32Bit:%vreg52,%vreg51
	%vreg53<def> = SRLI %t5, 6; GR32Bit:%vreg53
	%vreg54<def> = ANDI %vreg53, 63; GR32Bit:%vreg54,%vreg53
	%vreg55<def> = ADDI %zero, 832; GR32Bit:%vreg55
	%vreg56<def> = MUL %vreg50, %vreg55; GR32Bit:%vreg56,%vreg50,%vreg55
	%vreg57<def> = ADDI %zero, 52; GR32Bit:%vreg57
	%vreg58<def> = MUL %vreg52, %vreg57; GR32Bit:%vreg58,%vreg52,%vreg57
	%vreg59<def> = ADD %vreg58, %vreg54; GR32Bit:%vreg59,%vreg58,%vreg54
	%vreg60<def> = ADD %vreg59, %vreg56; GR32Bit:%vreg60,%vreg59,%vreg56
	%vreg61<def> = MUL %vreg60, %vreg49; GR32Bit:%vreg61,%vreg60,%vreg49
	%vreg44<def> = ADD %vreg48, %vreg61; GR32Bit:%vreg44,%vreg48,%vreg61
	%vreg62<def> = ADD %t5, %zero; GR32Bit:%vreg62
	%vreg64<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg64
	%vreg65<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg65
	%vreg66<def> = SRLI %vreg65, 12; GR32Bit:%vreg66,%vreg65
	%vreg67<def> = ADD %vreg64, %vreg66; GR32Bit:%vreg67,%vreg64,%vreg66
	%vreg68<def> = ADDI %zero, 12; GR32Bit:%vreg68
	%vreg69<def> = SRLI %t5, 22; GR32Bit:%vreg69
	%vreg70<def> = SRLI %t5, 12; GR32Bit:%vreg70
	%vreg71<def> = ANDI %vreg70, 15; GR32Bit:%vreg71,%vreg70
	%vreg72<def> = SRLI %t5, 6; GR32Bit:%vreg72
	%vreg73<def> = ANDI %vreg72, 63; GR32Bit:%vreg73,%vreg72
	%vreg74<def> = ADDI %zero, 832; GR32Bit:%vreg74
	%vreg75<def> = MUL %vreg69, %vreg74; GR32Bit:%vreg75,%vreg69,%vreg74
	%vreg76<def> = ADDI %zero, 52; GR32Bit:%vreg76
	%vreg77<def> = MUL %vreg71, %vreg76; GR32Bit:%vreg77,%vreg71,%vreg76
	%vreg78<def> = ADD %vreg77, %vreg73; GR32Bit:%vreg78,%vreg77,%vreg73
	%vreg79<def> = ADD %vreg78, %vreg75; GR32Bit:%vreg79,%vreg78,%vreg75
	%vreg80<def> = MUL %vreg79, %vreg68; GR32Bit:%vreg80,%vreg79,%vreg68
	%vreg63<def> = ADD %vreg67, %vreg80; GR32Bit:%vreg63,%vreg67,%vreg80
Adding all fallocs first to avoid stalls due to sequential fallocs and fbinds
Adding writecm(for writing sync count to context frames) and fbind instructions
live end of child is itself
live end of child is itself
Adding localref sw instructions to hyperOp redefine_start1
Adding writecm instructions to hyperOp redefine_start1

*** Renumbered SlotIndexes 412-484 ***
Adding writecmp and sync instructions
Adding endHyperOp instructions to each pHyperOp

*** Renumbered SlotIndexes 424-496 ***
  %zero<def> = ADDI %zero, 0
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 436-508 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 448-520 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 460-532 ***
  %zero<def> = ADDI %zero, 0
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 472-544 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 484-556 ***
  %zero<def> = ADDI %zero, 0
After Shuffling regions of basic block, state of BB#0:
BB#0: derived from LLVM BB %redefine_start1.entry
	%vreg5<def> = ADD %t5, %zero; GR32Bit:%vreg5
	%vreg7<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg7
	%vreg8<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg8
	%vreg9<def> = SRLI %vreg8, 12; GR32Bit:%vreg9,%vreg8
	%vreg10<def> = ADD %vreg7, %vreg9; GR32Bit:%vreg10,%vreg7,%vreg9
	%vreg11<def> = ADDI %zero, 12; GR32Bit:%vreg11
	%vreg12<def> = SRLI %t5, 22; GR32Bit:%vreg12
	%vreg13<def> = SRLI %t5, 12; GR32Bit:%vreg13
	%vreg14<def> = ANDI %vreg13, 15; GR32Bit:%vreg14,%vreg13
	%vreg15<def> = SRLI %t5, 6; GR32Bit:%vreg15
	%vreg16<def> = ANDI %vreg15, 63; GR32Bit:%vreg16,%vreg15
	%vreg17<def> = ADDI %zero, 832; GR32Bit:%vreg17
	%vreg18<def> = MUL %vreg12, %vreg17; GR32Bit:%vreg18,%vreg12,%vreg17
	%vreg19<def> = ADDI %zero, 52; GR32Bit:%vreg19
	%vreg20<def> = MUL %vreg14, %vreg19; GR32Bit:%vreg20,%vreg14,%vreg19
	%vreg21<def> = ADD %vreg20, %vreg16; GR32Bit:%vreg21,%vreg20,%vreg16
	%vreg22<def> = ADD %vreg21, %vreg18; GR32Bit:%vreg22,%vreg21,%vreg18
	%vreg23<def> = MUL %vreg22, %vreg11; GR32Bit:%vreg23,%vreg22,%vreg11
	%vreg6<def> = ADD %vreg10, %vreg23; GR32Bit:%vreg6,%vreg10,%vreg23
	%vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
	%vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
	%vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
	%vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
	%vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
	SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
	%vreg81<def> = ADDI %zero, 64; GR32Bit:%vreg81
	%vreg82<def> = LW %t5, <fi#0>; GR32Bit:%vreg82
	WRITECM %vreg81, %vreg82, 0; GR32Bit:%vreg81,%vreg82
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg24<def> = ADD %t5, %zero; GR32Bit:%vreg24
	%vreg26<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg26
	%vreg27<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg27
	%vreg28<def> = SRLI %vreg27, 12; GR32Bit:%vreg28,%vreg27
	%vreg29<def> = ADD %vreg26, %vreg28; GR32Bit:%vreg29,%vreg26,%vreg28
	%vreg30<def> = ADDI %zero, 12; GR32Bit:%vreg30
	%vreg31<def> = SRLI %t5, 22; GR32Bit:%vreg31
	%vreg32<def> = SRLI %t5, 12; GR32Bit:%vreg32
	%vreg33<def> = ANDI %vreg32, 15; GR32Bit:%vreg33,%vreg32
	%vreg34<def> = SRLI %t5, 6; GR32Bit:%vreg34
	%vreg35<def> = ANDI %vreg34, 63; GR32Bit:%vreg35,%vreg34
	%vreg36<def> = ADDI %zero, 832; GR32Bit:%vreg36
	%vreg37<def> = MUL %vreg31, %vreg36; GR32Bit:%vreg37,%vreg31,%vreg36
	%vreg38<def> = ADDI %zero, 52; GR32Bit:%vreg38
	%vreg39<def> = MUL %vreg33, %vreg38; GR32Bit:%vreg39,%vreg33,%vreg38
	%vreg40<def> = ADD %vreg39, %vreg35; GR32Bit:%vreg40,%vreg39,%vreg35
	%vreg41<def> = ADD %vreg40, %vreg37; GR32Bit:%vreg41,%vreg40,%vreg37
	%vreg42<def> = MUL %vreg41, %vreg30; GR32Bit:%vreg42,%vreg41,%vreg30
	%vreg25<def> = ADD %vreg29, %vreg42; GR32Bit:%vreg25,%vreg29,%vreg42
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg43<def> = ADD %t5, %zero; GR32Bit:%vreg43
	%vreg45<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg45
	%vreg46<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg46
	%vreg47<def> = SRLI %vreg46, 12; GR32Bit:%vreg47,%vreg46
	%vreg48<def> = ADD %vreg45, %vreg47; GR32Bit:%vreg48,%vreg45,%vreg47
	%vreg49<def> = ADDI %zero, 12; GR32Bit:%vreg49
	%vreg50<def> = SRLI %t5, 22; GR32Bit:%vreg50
	%vreg51<def> = SRLI %t5, 12; GR32Bit:%vreg51
	%vreg52<def> = ANDI %vreg51, 15; GR32Bit:%vreg52,%vreg51
	%vreg53<def> = SRLI %t5, 6; GR32Bit:%vreg53
	%vreg54<def> = ANDI %vreg53, 63; GR32Bit:%vreg54,%vreg53
	%vreg55<def> = ADDI %zero, 832; GR32Bit:%vreg55
	%vreg56<def> = MUL %vreg50, %vreg55; GR32Bit:%vreg56,%vreg50,%vreg55
	%vreg57<def> = ADDI %zero, 52; GR32Bit:%vreg57
	%vreg58<def> = MUL %vreg52, %vreg57; GR32Bit:%vreg58,%vreg52,%vreg57
	%vreg59<def> = ADD %vreg58, %vreg54; GR32Bit:%vreg59,%vreg58,%vreg54
	%vreg60<def> = ADD %vreg59, %vreg56; GR32Bit:%vreg60,%vreg59,%vreg56
	%vreg61<def> = MUL %vreg60, %vreg49; GR32Bit:%vreg61,%vreg60,%vreg49
	%vreg44<def> = ADD %vreg48, %vreg61; GR32Bit:%vreg44,%vreg48,%vreg61
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg62<def> = ADD %t5, %zero; GR32Bit:%vreg62
	%vreg64<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg64
	%vreg65<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg65
	%vreg66<def> = SRLI %vreg65, 12; GR32Bit:%vreg66,%vreg65
	%vreg67<def> = ADD %vreg64, %vreg66; GR32Bit:%vreg67,%vreg64,%vreg66
	%vreg68<def> = ADDI %zero, 12; GR32Bit:%vreg68
	%vreg69<def> = SRLI %t5, 22; GR32Bit:%vreg69
	%vreg70<def> = SRLI %t5, 12; GR32Bit:%vreg70
	%vreg71<def> = ANDI %vreg70, 15; GR32Bit:%vreg71,%vreg70
	%vreg72<def> = SRLI %t5, 6; GR32Bit:%vreg72
	%vreg73<def> = ANDI %vreg72, 63; GR32Bit:%vreg73,%vreg72
	%vreg74<def> = ADDI %zero, 832; GR32Bit:%vreg74
	%vreg75<def> = MUL %vreg69, %vreg74; GR32Bit:%vreg75,%vreg69,%vreg74
	%vreg76<def> = ADDI %zero, 52; GR32Bit:%vreg76
	%vreg77<def> = MUL %vreg71, %vreg76; GR32Bit:%vreg77,%vreg71,%vreg76
	%vreg78<def> = ADD %vreg77, %vreg73; GR32Bit:%vreg78,%vreg77,%vreg73
	%vreg79<def> = ADD %vreg78, %vreg75; GR32Bit:%vreg79,%vreg78,%vreg75
	%vreg80<def> = MUL %vreg79, %vreg68; GR32Bit:%vreg80,%vreg79,%vreg68
	%vreg63<def> = ADD %vreg67, %vreg80; GR32Bit:%vreg63,%vreg67,%vreg80
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 316-628 ***

*** Renumbered SlotIndexes 304-648 ***

*** Renumbered SlotIndexes 216-696 ***

*** Renumbered SlotIndexes 204-716 ***

*** Renumbered SlotIndexes 204-732 ***

*** Renumbered SlotIndexes 112-776 ***

*** Renumbered SlotIndexes 100-796 ***

*** Renumbered SlotIndexes 100-812 ***

*** Renumbered SlotIndexes 100-828 ***

*** Renumbered SlotIndexes 100-844 ***

*** Renumbered SlotIndexes 100-860 ***

*** Renumbered SlotIndexes 100-876 ***

*** Renumbered SlotIndexes 12-916 ***
Creating pHyperOp bundles for CEs for bb0
  %vreg24<def> = ADD %t5, %zero; GR32Bit:%vreg24
starting at   %vreg5<def> = ADD %t5, %zero; GR32Bit:%vreg5
  %vreg43<def> = ADD %t5, %zero; GR32Bit:%vreg43
starting at   %vreg24<def> = ADD %t5, %zero; GR32Bit:%vreg24
  %vreg62<def> = ADD %t5, %zero; GR32Bit:%vreg62
starting at   %vreg43<def> = ADD %t5, %zero; GR32Bit:%vreg43
starting at   %vreg62<def> = ADD %t5, %zero; GR32Bit:%vreg62
After bundling, state of BB0:BB#0: derived from LLVM BB %redefine_start1.entry
	%vreg5<def> = ADD %t5, %zero; GR32Bit:%vreg5
	  * %vreg7<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg7
	  * %vreg8<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg8
	  * %vreg9<def> = SRLI %vreg8, 12; GR32Bit:%vreg9,%vreg8
	  * %vreg10<def> = ADD %vreg7, %vreg9; GR32Bit:%vreg10,%vreg7,%vreg9
	  * %vreg11<def> = ADDI %zero, 12; GR32Bit:%vreg11
	  * %vreg12<def> = SRLI %t5, 22; GR32Bit:%vreg12
	  * %vreg13<def> = SRLI %t5, 12; GR32Bit:%vreg13
	  * %vreg14<def> = ANDI %vreg13, 15; GR32Bit:%vreg14,%vreg13
	  * %vreg15<def> = SRLI %t5, 6; GR32Bit:%vreg15
	  * %vreg16<def> = ANDI %vreg15, 63; GR32Bit:%vreg16,%vreg15
	  * %vreg17<def> = ADDI %zero, 832; GR32Bit:%vreg17
	  * %vreg18<def> = MUL %vreg12, %vreg17; GR32Bit:%vreg18,%vreg12,%vreg17
	  * %vreg19<def> = ADDI %zero, 52; GR32Bit:%vreg19
	  * %vreg20<def> = MUL %vreg14, %vreg19; GR32Bit:%vreg20,%vreg14,%vreg19
	  * %vreg21<def> = ADD %vreg20, %vreg16; GR32Bit:%vreg21,%vreg20,%vreg16
	  * %vreg22<def> = ADD %vreg21, %vreg18; GR32Bit:%vreg22,%vreg21,%vreg18
	  * %vreg23<def> = MUL %vreg22, %vreg11; GR32Bit:%vreg23,%vreg22,%vreg11
	  * %vreg6<def> = ADD %vreg10, %vreg23; GR32Bit:%vreg6,%vreg10,%vreg23
	  * %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
	  * %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
	  * %vreg1<def> = ADDI %zero, <ga:@redefine_in_eicas_egt>[TF=3]; GR32Bit:%vreg1
	  * %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
	  * %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
	  * SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
	  * %vreg81<def> = ADDI %zero, 64; GR32Bit:%vreg81
	  * %vreg82<def> = LW %t5, <fi#0>; GR32Bit:%vreg82
	  * WRITECM %vreg81, %vreg82, 0; GR32Bit:%vreg81,%vreg82
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg24<def> = ADD %t5, %zero; GR32Bit:%vreg24
	  * %vreg26<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg26
	  * %vreg27<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg27
	  * %vreg28<def> = SRLI %vreg27, 12; GR32Bit:%vreg28,%vreg27
	  * %vreg29<def> = ADD %vreg26, %vreg28; GR32Bit:%vreg29,%vreg26,%vreg28
	  * %vreg30<def> = ADDI %zero, 12; GR32Bit:%vreg30
	  * %vreg31<def> = SRLI %t5, 22; GR32Bit:%vreg31
	  * %vreg32<def> = SRLI %t5, 12; GR32Bit:%vreg32
	  * %vreg33<def> = ANDI %vreg32, 15; GR32Bit:%vreg33,%vreg32
	  * %vreg34<def> = SRLI %t5, 6; GR32Bit:%vreg34
	  * %vreg35<def> = ANDI %vreg34, 63; GR32Bit:%vreg35,%vreg34
	  * %vreg36<def> = ADDI %zero, 832; GR32Bit:%vreg36
	  * %vreg37<def> = MUL %vreg31, %vreg36; GR32Bit:%vreg37,%vreg31,%vreg36
	  * %vreg38<def> = ADDI %zero, 52; GR32Bit:%vreg38
	  * %vreg39<def> = MUL %vreg33, %vreg38; GR32Bit:%vreg39,%vreg33,%vreg38
	  * %vreg40<def> = ADD %vreg39, %vreg35; GR32Bit:%vreg40,%vreg39,%vreg35
	  * %vreg41<def> = ADD %vreg40, %vreg37; GR32Bit:%vreg41,%vreg40,%vreg37
	  * %vreg42<def> = MUL %vreg41, %vreg30; GR32Bit:%vreg42,%vreg41,%vreg30
	  * %vreg25<def> = ADD %vreg29, %vreg42; GR32Bit:%vreg25,%vreg29,%vreg42
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg43<def> = ADD %t5, %zero; GR32Bit:%vreg43
	  * %vreg45<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg45
	  * %vreg46<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg46
	  * %vreg47<def> = SRLI %vreg46, 12; GR32Bit:%vreg47,%vreg46
	  * %vreg48<def> = ADD %vreg45, %vreg47; GR32Bit:%vreg48,%vreg45,%vreg47
	  * %vreg49<def> = ADDI %zero, 12; GR32Bit:%vreg49
	  * %vreg50<def> = SRLI %t5, 22; GR32Bit:%vreg50
	  * %vreg51<def> = SRLI %t5, 12; GR32Bit:%vreg51
	  * %vreg52<def> = ANDI %vreg51, 15; GR32Bit:%vreg52,%vreg51
	  * %vreg53<def> = SRLI %t5, 6; GR32Bit:%vreg53
	  * %vreg54<def> = ANDI %vreg53, 63; GR32Bit:%vreg54,%vreg53
	  * %vreg55<def> = ADDI %zero, 832; GR32Bit:%vreg55
	  * %vreg56<def> = MUL %vreg50, %vreg55; GR32Bit:%vreg56,%vreg50,%vreg55
	  * %vreg57<def> = ADDI %zero, 52; GR32Bit:%vreg57
	  * %vreg58<def> = MUL %vreg52, %vreg57; GR32Bit:%vreg58,%vreg52,%vreg57
	  * %vreg59<def> = ADD %vreg58, %vreg54; GR32Bit:%vreg59,%vreg58,%vreg54
	  * %vreg60<def> = ADD %vreg59, %vreg56; GR32Bit:%vreg60,%vreg59,%vreg56
	  * %vreg61<def> = MUL %vreg60, %vreg49; GR32Bit:%vreg61,%vreg60,%vreg49
	  * %vreg44<def> = ADD %vreg48, %vreg61; GR32Bit:%vreg44,%vreg48,%vreg61
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg62<def> = ADD %t5, %zero; GR32Bit:%vreg62
	  * %vreg64<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg64
	  * %vreg65<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg65
	  * %vreg66<def> = SRLI %vreg65, 12; GR32Bit:%vreg66,%vreg65
	  * %vreg67<def> = ADD %vreg64, %vreg66; GR32Bit:%vreg67,%vreg64,%vreg66
	  * %vreg68<def> = ADDI %zero, 12; GR32Bit:%vreg68
	  * %vreg69<def> = SRLI %t5, 22; GR32Bit:%vreg69
	  * %vreg70<def> = SRLI %t5, 12; GR32Bit:%vreg70
	  * %vreg71<def> = ANDI %vreg70, 15; GR32Bit:%vreg71,%vreg70
	  * %vreg72<def> = SRLI %t5, 6; GR32Bit:%vreg72
	  * %vreg73<def> = ANDI %vreg72, 63; GR32Bit:%vreg73,%vreg72
	  * %vreg74<def> = ADDI %zero, 832; GR32Bit:%vreg74
	  * %vreg75<def> = MUL %vreg69, %vreg74; GR32Bit:%vreg75,%vreg69,%vreg74
	  * %vreg76<def> = ADDI %zero, 52; GR32Bit:%vreg76
	  * %vreg77<def> = MUL %vreg71, %vreg76; GR32Bit:%vreg77,%vreg71,%vreg76
	  * %vreg78<def> = ADD %vreg77, %vreg73; GR32Bit:%vreg78,%vreg77,%vreg73
	  * %vreg79<def> = ADD %vreg78, %vreg75; GR32Bit:%vreg79,%vreg78,%vreg75
	  * %vreg80<def> = MUL %vreg79, %vreg68; GR32Bit:%vreg80,%vreg79,%vreg68
	  * %vreg63<def> = ADD %vreg67, %vreg80; GR32Bit:%vreg63,%vreg67,%vreg80
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
Patching the instructions that are supposed to use the physical registers r30 and r31
Computing live-in reg-units in ABI blocks.
Created 0 new intervals.

*** Renumbered SlotIndexes 8-936 ***
********** INTERVALS **********
t5 = EMPTY
%vreg0 = [176r,192r:0)  0@176r
%vreg1 = [184r,192r:0)  0@184r
%vreg2 = [192r,200r:0)  0@192r
%vreg3 = [200r,208r:0)  0@200r
%vreg4 = [168r,208r:0)  0@168r
%vreg5 = [4r,4d:0)  0@4r
%vreg6 = [160r,160d:0)  0@160r
%vreg7 = [24r,48r:0)  0@24r
%vreg8 = [32r,40r:0)  0@32r
%vreg9 = [40r,48r:0)  0@40r
%vreg10 = [48r,160r:0)  0@48r
%vreg11 = [56r,152r:0)  0@56r
%vreg12 = [64r,112r:0)  0@64r
%vreg13 = [72r,80r:0)  0@72r
%vreg14 = [80r,128r:0)  0@80r
%vreg15 = [88r,96r:0)  0@88r
%vreg16 = [96r,136r:0)  0@96r
%vreg17 = [104r,112r:0)  0@104r
%vreg18 = [112r,144r:0)  0@112r
%vreg19 = [120r,128r:0)  0@120r
%vreg20 = [128r,136r:0)  0@128r
%vreg21 = [136r,144r:0)  0@136r
%vreg22 = [144r,152r:0)  0@144r
%vreg23 = [152r,160r:0)  0@152r
%vreg24 = [264r,264d:0)  0@264r
%vreg25 = [408r,408d:0)  0@408r
%vreg26 = [272r,296r:0)  0@272r
%vreg27 = [280r,288r:0)  0@280r
%vreg28 = [288r,296r:0)  0@288r
%vreg29 = [296r,408r:0)  0@296r
%vreg30 = [304r,400r:0)  0@304r
%vreg31 = [312r,360r:0)  0@312r
%vreg32 = [320r,328r:0)  0@320r
%vreg33 = [328r,376r:0)  0@328r
%vreg34 = [336r,344r:0)  0@336r
%vreg35 = [344r,384r:0)  0@344r
%vreg36 = [352r,360r:0)  0@352r
%vreg37 = [360r,392r:0)  0@360r
%vreg38 = [368r,376r:0)  0@368r
%vreg39 = [376r,384r:0)  0@376r
%vreg40 = [384r,392r:0)  0@384r
%vreg41 = [392r,400r:0)  0@392r
%vreg42 = [400r,408r:0)  0@400r
%vreg43 = [440r,440d:0)  0@440r
%vreg44 = [584r,584d:0)  0@584r
%vreg45 = [448r,472r:0)  0@448r
%vreg46 = [456r,464r:0)  0@456r
%vreg47 = [464r,472r:0)  0@464r
%vreg48 = [472r,584r:0)  0@472r
%vreg49 = [480r,576r:0)  0@480r
%vreg50 = [488r,536r:0)  0@488r
%vreg51 = [496r,504r:0)  0@496r
%vreg52 = [504r,552r:0)  0@504r
%vreg53 = [512r,520r:0)  0@512r
%vreg54 = [520r,560r:0)  0@520r
%vreg55 = [528r,536r:0)  0@528r
%vreg56 = [536r,568r:0)  0@536r
%vreg57 = [544r,552r:0)  0@544r
%vreg58 = [552r,560r:0)  0@552r
%vreg59 = [560r,568r:0)  0@560r
%vreg60 = [568r,576r:0)  0@568r
%vreg61 = [576r,584r:0)  0@576r
%vreg62 = [616r,616d:0)  0@616r
%vreg63 = [760r,760d:0)  0@760r
%vreg64 = [624r,648r:0)  0@624r
%vreg65 = [632r,640r:0)  0@632r
%vreg66 = [640r,648r:0)  0@640r
%vreg67 = [648r,760r:0)  0@648r
%vreg68 = [656r,752r:0)  0@656r
%vreg69 = [664r,712r:0)  0@664r
%vreg70 = [672r,680r:0)  0@672r
%vreg71 = [680r,728r:0)  0@680r
%vreg72 = [688r,696r:0)  0@688r
%vreg73 = [696r,736r:0)  0@696r
%vreg74 = [704r,712r:0)  0@704r
%vreg75 = [712r,744r:0)  0@712r
%vreg76 = [720r,728r:0)  0@720r
%vreg77 = [728r,736r:0)  0@728r
%vreg78 = [736r,744r:0)  0@736r
%vreg79 = [744r,752r:0)  0@744r
%vreg80 = [752r,760r:0)  0@752r
%vreg81 = [216r,232r:0)  0@216r
%vreg82 = [224r,232r:0)  0@224r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function redefine_start1: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

0B	BB#0: derived from LLVM BB %redefine_start1.entry
4B		%t4<def> = ADD %t5, %zero
4B		  * %vreg7<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg7
4B		  * %vreg8<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg8
4B		  * %vreg9<def> = SRLI %vreg8, 12; GR32Bit:%vreg9,%vreg8
4B		  * %vreg10<def> = ADD %vreg7, %vreg9; GR32Bit:%vreg10,%vreg7,%vreg9
4B		  * %vreg11<def> = ADDI %zero, 12; GR32Bit:%vreg11
4B		  * %vreg12<def> = SRLI %t5, 22; GR32Bit:%vreg12
4B		  * %vreg13<def> = SRLI %t5, 12; GR32Bit:%vreg13
4B		  * %vreg14<def> = ANDI %vreg13, 15; GR32Bit:%vreg14,%vreg13
4B		  * %vreg15<def> = SRLI %t5, 6; GR32Bit:%vreg15
4B		  * %vreg16<def> = ANDI %vreg15, 63; GR32Bit:%vreg16,%vreg15
4B		  * %vreg17<def> = ADDI %zero, 832; GR32Bit:%vreg17
4B		  * %vreg18<def> = MUL %vreg12, %vreg17; GR32Bit:%vreg18,%vreg12,%vreg17
4B		  * %vreg19<def> = ADDI %zero, 52; GR32Bit:%vreg19
4B		  * %vreg20<def> = MUL %vreg14, %vreg19; GR32Bit:%vreg20,%vreg14,%vreg19
4B		  * %vreg21<def> = ADD %vreg20, %vreg16; GR32Bit:%vreg21,%vreg20,%vreg16
4B		  * %vreg22<def> = ADD %vreg21, %vreg18; GR32Bit:%vreg22,%vreg21,%vreg18
4B		  * %vreg23<def> = MUL %vreg22, %vreg11; GR32Bit:%vreg23,%vreg22,%vreg11
4B		  * %t5<def> = ADD %vreg10, %vreg23; GR32Bit:%vreg10,%vreg23
4B		  * %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
4B		  * %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
4B		  * %vreg1<def> = LUI <MCSym="%lo("ga#0")">; GR32Bit:%vreg1
4B		  * SRLI %vreg1, %vreg1, 12; GR32Bit:%vreg1
4B		  * %vreg2<def> = ADD %vreg1, %vreg0; GR32Bit:%vreg2,%vreg1,%vreg0
4B		  * %vreg3<def> = LW %vreg2, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
4B		  * SW %vreg3, %vreg4, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
4B		  * %vreg81<def> = ADDI %zero, 64; GR32Bit:%vreg81
4B		  * %vreg82<def> = LW %t5, <fi#0>; GR32Bit:%vreg82
4B		  * WRITECM %vreg81, %vreg82, 0; GR32Bit:%vreg81,%vreg82
4B		  * END 0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
264B		%t4<def> = ADD %t5, %zero
264B		  * %vreg26<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg26
264B		  * %vreg27<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg27
264B		  * %vreg28<def> = SRLI %vreg27, 12; GR32Bit:%vreg28,%vreg27
264B		  * %vreg29<def> = ADD %vreg26, %vreg28; GR32Bit:%vreg29,%vreg26,%vreg28
264B		  * %vreg30<def> = ADDI %zero, 12; GR32Bit:%vreg30
264B		  * %vreg31<def> = SRLI %t5, 22; GR32Bit:%vreg31
264B		  * %vreg32<def> = SRLI %t5, 12; GR32Bit:%vreg32
264B		  * %vreg33<def> = ANDI %vreg32, 15; GR32Bit:%vreg33,%vreg32
264B		  * %vreg34<def> = SRLI %t5, 6; GR32Bit:%vreg34
264B		  * %vreg35<def> = ANDI %vreg34, 63; GR32Bit:%vreg35,%vreg34
264B		  * %vreg36<def> = ADDI %zero, 832; GR32Bit:%vreg36
264B		  * %vreg37<def> = MUL %vreg31, %vreg36; GR32Bit:%vreg37,%vreg31,%vreg36
264B		  * %vreg38<def> = ADDI %zero, 52; GR32Bit:%vreg38
264B		  * %vreg39<def> = MUL %vreg33, %vreg38; GR32Bit:%vreg39,%vreg33,%vreg38
264B		  * %vreg40<def> = ADD %vreg39, %vreg35; GR32Bit:%vreg40,%vreg39,%vreg35
264B		  * %vreg41<def> = ADD %vreg40, %vreg37; GR32Bit:%vreg41,%vreg40,%vreg37
264B		  * %vreg42<def> = MUL %vreg41, %vreg30; GR32Bit:%vreg42,%vreg41,%vreg30
264B		  * %t5<def> = ADD %vreg29, %vreg42; GR32Bit:%vreg29,%vreg42
264B		  * END 0
264B		  * %zero<def> = ADDI %zero, 0
264B		  * %zero<def> = ADDI %zero, 0
440B		%t4<def> = ADD %t5, %zero
440B		  * %vreg45<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg45
440B		  * %vreg46<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg46
440B		  * %vreg47<def> = SRLI %vreg46, 12; GR32Bit:%vreg47,%vreg46
440B		  * %vreg48<def> = ADD %vreg45, %vreg47; GR32Bit:%vreg48,%vreg45,%vreg47
440B		  * %vreg49<def> = ADDI %zero, 12; GR32Bit:%vreg49
440B		  * %vreg50<def> = SRLI %t5, 22; GR32Bit:%vreg50
440B		  * %vreg51<def> = SRLI %t5, 12; GR32Bit:%vreg51
440B		  * %vreg52<def> = ANDI %vreg51, 15; GR32Bit:%vreg52,%vreg51
440B		  * %vreg53<def> = SRLI %t5, 6; GR32Bit:%vreg53
440B		  * %vreg54<def> = ANDI %vreg53, 63; GR32Bit:%vreg54,%vreg53
440B		  * %vreg55<def> = ADDI %zero, 832; GR32Bit:%vreg55
440B		  * %vreg56<def> = MUL %vreg50, %vreg55; GR32Bit:%vreg56,%vreg50,%vreg55
440B		  * %vreg57<def> = ADDI %zero, 52; GR32Bit:%vreg57
440B		  * %vreg58<def> = MUL %vreg52, %vreg57; GR32Bit:%vreg58,%vreg52,%vreg57
440B		  * %vreg59<def> = ADD %vreg58, %vreg54; GR32Bit:%vreg59,%vreg58,%vreg54
440B		  * %vreg60<def> = ADD %vreg59, %vreg56; GR32Bit:%vreg60,%vreg59,%vreg56
440B		  * %vreg61<def> = MUL %vreg60, %vreg49; GR32Bit:%vreg61,%vreg60,%vreg49
440B		  * %t5<def> = ADD %vreg48, %vreg61; GR32Bit:%vreg48,%vreg61
440B		  * END 0
440B		  * %zero<def> = ADDI %zero, 0
440B		  * %zero<def> = ADDI %zero, 0
616B		%t4<def> = ADD %t5, %zero
616B		  * %vreg64<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg64
616B		  * %vreg65<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg65
616B		  * %vreg66<def> = SRLI %vreg65, 12; GR32Bit:%vreg66,%vreg65
616B		  * %vreg67<def> = ADD %vreg64, %vreg66; GR32Bit:%vreg67,%vreg64,%vreg66
616B		  * %vreg68<def> = ADDI %zero, 12; GR32Bit:%vreg68
616B		  * %vreg69<def> = SRLI %t5, 22; GR32Bit:%vreg69
616B		  * %vreg70<def> = SRLI %t5, 12; GR32Bit:%vreg70
616B		  * %vreg71<def> = ANDI %vreg70, 15; GR32Bit:%vreg71,%vreg70
616B		  * %vreg72<def> = SRLI %t5, 6; GR32Bit:%vreg72
616B		  * %vreg73<def> = ANDI %vreg72, 63; GR32Bit:%vreg73,%vreg72
616B		  * %vreg74<def> = ADDI %zero, 832; GR32Bit:%vreg74
616B		  * %vreg75<def> = MUL %vreg69, %vreg74; GR32Bit:%vreg75,%vreg69,%vreg74
616B		  * %vreg76<def> = ADDI %zero, 52; GR32Bit:%vreg76
616B		  * %vreg77<def> = MUL %vreg71, %vreg76; GR32Bit:%vreg77,%vreg71,%vreg76
616B		  * %vreg78<def> = ADD %vreg77, %vreg73; GR32Bit:%vreg78,%vreg77,%vreg73
616B		  * %vreg79<def> = ADD %vreg78, %vreg75; GR32Bit:%vreg79,%vreg78,%vreg75
616B		  * %vreg80<def> = MUL %vreg79, %vreg68; GR32Bit:%vreg80,%vreg79,%vreg68
616B		  * %t5<def> = ADD %vreg67, %vreg80; GR32Bit:%vreg67,%vreg80
616B		  * END 0
616B		  * %zero<def> = ADDI %zero, 0
616B		  * %zero<def> = ADDI %zero, 0

# End machine code for function redefine_start1.

********** COMPUTING LIVE DEBUG VARIABLES: redefine_start1 **********
********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: redefine_start1
********** GREEDY REGISTER ALLOCATION **********
********** Function: redefine_start1

selectOrSplit GR32Bit:%vreg10 [48r,160r:0)  0@48r
AllocationOrder(GR32Bit) = [ %t0 %t1 %t2 %fp %a0 %a1 %a2 %a3 %a4 %a6 %a7 %t3 %ra %sp %gp %tp %s0 %s1 %s2 %s3 %s4 %s5 %s6 %s7 %s8 %s9 %s10 %s11 ]
assigning %vreg10 to %t0: t0

selectOrSplit GR32Bit:%vreg29 [296r,408r:0)  0@296r
assigning %vreg29 to %t0: t0

selectOrSplit GR32Bit:%vreg48 [472r,584r:0)  0@472r
assigning %vreg48 to %t0: t0

selectOrSplit GR32Bit:%vreg67 [648r,760r:0)  0@648r
assigning %vreg67 to %t0: t0

selectOrSplit GR32Bit:%vreg11 [56r,152r:0)  0@56r
assigning %vreg11 to %t1: t1

selectOrSplit GR32Bit:%vreg30 [304r,400r:0)  0@304r
assigning %vreg30 to %t1: t1

selectOrSplit GR32Bit:%vreg49 [480r,576r:0)  0@480r
assigning %vreg49 to %t1: t1

selectOrSplit GR32Bit:%vreg68 [656r,752r:0)  0@656r
assigning %vreg68 to %t1: t1

selectOrSplit GR32Bit:%vreg12 [64r,112r:0)  0@64r
assigning %vreg12 to %t2: t2

selectOrSplit GR32Bit:%vreg14 [80r,128r:0)  0@80r
assigning %vreg14 to %fp: fp

selectOrSplit GR32Bit:%vreg31 [312r,360r:0)  0@312r
assigning %vreg31 to %t2: t2

selectOrSplit GR32Bit:%vreg33 [328r,376r:0)  0@328r
assigning %vreg33 to %fp: fp

selectOrSplit GR32Bit:%vreg50 [488r,536r:0)  0@488r
assigning %vreg50 to %t2: t2

selectOrSplit GR32Bit:%vreg52 [504r,552r:0)  0@504r
assigning %vreg52 to %fp: fp

selectOrSplit GR32Bit:%vreg69 [664r,712r:0)  0@664r
assigning %vreg69 to %t2: t2

selectOrSplit GR32Bit:%vreg71 [680r,728r:0)  0@680r
assigning %vreg71 to %fp: fp

selectOrSplit GR32Bit:%vreg4 [168r,208r:0)  0@168r
assigning %vreg4 to %t0: t0

selectOrSplit GR32Bit:%vreg16 [96r,136r:0)  0@96r
assigning %vreg16 to %a0: a0

selectOrSplit GR32Bit:%vreg35 [344r,384r:0)  0@344r
assigning %vreg35 to %a0: a0

selectOrSplit GR32Bit:%vreg54 [520r,560r:0)  0@520r
assigning %vreg54 to %a0: a0

selectOrSplit GR32Bit:%vreg73 [696r,736r:0)  0@696r
assigning %vreg73 to %a0: a0

selectOrSplit GR32Bit:%vreg18 [112r,144r:0)  0@112r
assigning %vreg18 to %t2: t2

selectOrSplit GR32Bit:%vreg37 [360r,392r:0)  0@360r
assigning %vreg37 to %t2: t2

selectOrSplit GR32Bit:%vreg56 [536r,568r:0)  0@536r
assigning %vreg56 to %t2: t2

selectOrSplit GR32Bit:%vreg75 [712r,744r:0)  0@712r
assigning %vreg75 to %t2: t2

selectOrSplit GR32Bit:%vreg7 [24r,48r:0)  0@24r
assigning %vreg7 to %t0: t0

selectOrSplit GR32Bit:%vreg26 [272r,296r:0)  0@272r
assigning %vreg26 to %t0: t0

selectOrSplit GR32Bit:%vreg45 [448r,472r:0)  0@448r
assigning %vreg45 to %t0: t0

selectOrSplit GR32Bit:%vreg64 [624r,648r:0)  0@624r
assigning %vreg64 to %t0: t0

selectOrSplit GR32Bit:%vreg0 [176r,192r:0)  0@176r
assigning %vreg0 to %t1: t1

selectOrSplit GR32Bit:%vreg81 [216r,232r:0)  0@216r
assigning %vreg81 to %t0: t0

selectOrSplit GR32Bit:%vreg1 [184r,192r:0)  0@184r
assigning %vreg1 to %t2: t2

selectOrSplit GR32Bit:%vreg2 [192r,200r:0)  0@192r
assigning %vreg2 to %t1: t1

selectOrSplit GR32Bit:%vreg3 [200r,208r:0)  0@200r
assigning %vreg3 to %t1: t1

selectOrSplit GR32Bit:%vreg8 [32r,40r:0)  0@32r
assigning %vreg8 to %t1: t1

selectOrSplit GR32Bit:%vreg9 [40r,48r:0)  0@40r
assigning %vreg9 to %t1: t1

selectOrSplit GR32Bit:%vreg13 [72r,80r:0)  0@72r
assigning %vreg13 to %fp: fp

selectOrSplit GR32Bit:%vreg15 [88r,96r:0)  0@88r
assigning %vreg15 to %a0: a0

selectOrSplit GR32Bit:%vreg17 [104r,112r:0)  0@104r
assigning %vreg17 to %a1: a1

selectOrSplit GR32Bit:%vreg19 [120r,128r:0)  0@120r
assigning %vreg19 to %a1: a1

selectOrSplit GR32Bit:%vreg20 [128r,136r:0)  0@128r
assigning %vreg20 to %fp: fp

selectOrSplit GR32Bit:%vreg21 [136r,144r:0)  0@136r
assigning %vreg21 to %fp: fp

selectOrSplit GR32Bit:%vreg22 [144r,152r:0)  0@144r
assigning %vreg22 to %t2: t2

selectOrSplit GR32Bit:%vreg23 [152r,160r:0)  0@152r
assigning %vreg23 to %t1: t1

selectOrSplit GR32Bit:%vreg27 [280r,288r:0)  0@280r
assigning %vreg27 to %t1: t1

selectOrSplit GR32Bit:%vreg28 [288r,296r:0)  0@288r
assigning %vreg28 to %t1: t1

selectOrSplit GR32Bit:%vreg32 [320r,328r:0)  0@320r
assigning %vreg32 to %fp: fp

selectOrSplit GR32Bit:%vreg34 [336r,344r:0)  0@336r
assigning %vreg34 to %a0: a0

selectOrSplit GR32Bit:%vreg36 [352r,360r:0)  0@352r
assigning %vreg36 to %a1: a1

selectOrSplit GR32Bit:%vreg38 [368r,376r:0)  0@368r
assigning %vreg38 to %a1: a1

selectOrSplit GR32Bit:%vreg39 [376r,384r:0)  0@376r
assigning %vreg39 to %fp: fp

selectOrSplit GR32Bit:%vreg40 [384r,392r:0)  0@384r
assigning %vreg40 to %fp: fp

selectOrSplit GR32Bit:%vreg41 [392r,400r:0)  0@392r
assigning %vreg41 to %t2: t2

selectOrSplit GR32Bit:%vreg42 [400r,408r:0)  0@400r
assigning %vreg42 to %t1: t1

selectOrSplit GR32Bit:%vreg46 [456r,464r:0)  0@456r
assigning %vreg46 to %t1: t1

selectOrSplit GR32Bit:%vreg47 [464r,472r:0)  0@464r
assigning %vreg47 to %t1: t1

selectOrSplit GR32Bit:%vreg51 [496r,504r:0)  0@496r
assigning %vreg51 to %fp: fp

selectOrSplit GR32Bit:%vreg53 [512r,520r:0)  0@512r
assigning %vreg53 to %a0: a0

selectOrSplit GR32Bit:%vreg55 [528r,536r:0)  0@528r
assigning %vreg55 to %a1: a1

selectOrSplit GR32Bit:%vreg57 [544r,552r:0)  0@544r
assigning %vreg57 to %a1: a1

selectOrSplit GR32Bit:%vreg58 [552r,560r:0)  0@552r
assigning %vreg58 to %fp: fp

selectOrSplit GR32Bit:%vreg59 [560r,568r:0)  0@560r
assigning %vreg59 to %fp: fp

selectOrSplit GR32Bit:%vreg60 [568r,576r:0)  0@568r
assigning %vreg60 to %t2: t2

selectOrSplit GR32Bit:%vreg61 [576r,584r:0)  0@576r
assigning %vreg61 to %t1: t1

selectOrSplit GR32Bit:%vreg65 [632r,640r:0)  0@632r
assigning %vreg65 to %t1: t1

selectOrSplit GR32Bit:%vreg66 [640r,648r:0)  0@640r
assigning %vreg66 to %t1: t1

selectOrSplit GR32Bit:%vreg70 [672r,680r:0)  0@672r
assigning %vreg70 to %fp: fp

selectOrSplit GR32Bit:%vreg72 [688r,696r:0)  0@688r
assigning %vreg72 to %a0: a0

selectOrSplit GR32Bit:%vreg74 [704r,712r:0)  0@704r
assigning %vreg74 to %a1: a1

selectOrSplit GR32Bit:%vreg76 [720r,728r:0)  0@720r
assigning %vreg76 to %a1: a1

selectOrSplit GR32Bit:%vreg77 [728r,736r:0)  0@728r
assigning %vreg77 to %fp: fp

selectOrSplit GR32Bit:%vreg78 [736r,744r:0)  0@736r
assigning %vreg78 to %fp: fp

selectOrSplit GR32Bit:%vreg79 [744r,752r:0)  0@744r
assigning %vreg79 to %t2: t2

selectOrSplit GR32Bit:%vreg80 [752r,760r:0)  0@752r
assigning %vreg80 to %t1: t1

selectOrSplit GR32Bit:%vreg82 [224r,232r:0)  0@224r
assigning %vreg82 to %t1: t1
********** REWRITE VIRTUAL REGISTERS **********
********** Function: redefine_start1
********** REGISTER MAP **********
[%vreg0 -> %t1] GR32Bit
[%vreg1 -> %t2] GR32Bit
[%vreg2 -> %t1] GR32Bit
[%vreg3 -> %t1] GR32Bit
[%vreg4 -> %t0] GR32Bit
[%vreg7 -> %t0] GR32Bit
[%vreg8 -> %t1] GR32Bit
[%vreg9 -> %t1] GR32Bit
[%vreg10 -> %t0] GR32Bit
[%vreg11 -> %t1] GR32Bit
[%vreg12 -> %t2] GR32Bit
[%vreg13 -> %fp] GR32Bit
[%vreg14 -> %fp] GR32Bit
[%vreg15 -> %a0] GR32Bit
[%vreg16 -> %a0] GR32Bit
[%vreg17 -> %a1] GR32Bit
[%vreg18 -> %t2] GR32Bit
[%vreg19 -> %a1] GR32Bit
[%vreg20 -> %fp] GR32Bit
[%vreg21 -> %fp] GR32Bit
[%vreg22 -> %t2] GR32Bit
[%vreg23 -> %t1] GR32Bit
[%vreg26 -> %t0] GR32Bit
[%vreg27 -> %t1] GR32Bit
[%vreg28 -> %t1] GR32Bit
[%vreg29 -> %t0] GR32Bit
[%vreg30 -> %t1] GR32Bit
[%vreg31 -> %t2] GR32Bit
[%vreg32 -> %fp] GR32Bit
[%vreg33 -> %fp] GR32Bit
[%vreg34 -> %a0] GR32Bit
[%vreg35 -> %a0] GR32Bit
[%vreg36 -> %a1] GR32Bit
[%vreg37 -> %t2] GR32Bit
[%vreg38 -> %a1] GR32Bit
[%vreg39 -> %fp] GR32Bit
[%vreg40 -> %fp] GR32Bit
[%vreg41 -> %t2] GR32Bit
[%vreg42 -> %t1] GR32Bit
[%vreg45 -> %t0] GR32Bit
[%vreg46 -> %t1] GR32Bit
[%vreg47 -> %t1] GR32Bit
[%vreg48 -> %t0] GR32Bit
[%vreg49 -> %t1] GR32Bit
[%vreg50 -> %t2] GR32Bit
[%vreg51 -> %fp] GR32Bit
[%vreg52 -> %fp] GR32Bit
[%vreg53 -> %a0] GR32Bit
[%vreg54 -> %a0] GR32Bit
[%vreg55 -> %a1] GR32Bit
[%vreg56 -> %t2] GR32Bit
[%vreg57 -> %a1] GR32Bit
[%vreg58 -> %fp] GR32Bit
[%vreg59 -> %fp] GR32Bit
[%vreg60 -> %t2] GR32Bit
[%vreg61 -> %t1] GR32Bit
[%vreg64 -> %t0] GR32Bit
[%vreg65 -> %t1] GR32Bit
[%vreg66 -> %t1] GR32Bit
[%vreg67 -> %t0] GR32Bit
[%vreg68 -> %t1] GR32Bit
[%vreg69 -> %t2] GR32Bit
[%vreg70 -> %fp] GR32Bit
[%vreg71 -> %fp] GR32Bit
[%vreg72 -> %a0] GR32Bit
[%vreg73 -> %a0] GR32Bit
[%vreg74 -> %a1] GR32Bit
[%vreg75 -> %t2] GR32Bit
[%vreg76 -> %a1] GR32Bit
[%vreg77 -> %fp] GR32Bit
[%vreg78 -> %fp] GR32Bit
[%vreg79 -> %t2] GR32Bit
[%vreg80 -> %t1] GR32Bit
[%vreg81 -> %t0] GR32Bit
[%vreg82 -> %t1] GR32Bit

0B	BB#0: derived from LLVM BB %redefine_start1.entry
4B		%t4<def> = ADD %t5, %zero
4B		  * %vreg7<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg7
4B		  * %vreg8<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg8
4B		  * %vreg9<def> = SRLI %vreg8<kill>, 12; GR32Bit:%vreg9,%vreg8
4B		  * %vreg10<def> = ADD %vreg7<kill>, %vreg9<kill>; GR32Bit:%vreg10,%vreg7,%vreg9
4B		  * %vreg11<def> = ADDI %zero, 12; GR32Bit:%vreg11
4B		  * %vreg12<def> = SRLI %t5, 22; GR32Bit:%vreg12
4B		  * %vreg13<def> = SRLI %t5, 12; GR32Bit:%vreg13
4B		  * %vreg14<def> = ANDI %vreg13<kill>, 15; GR32Bit:%vreg14,%vreg13
4B		  * %vreg15<def> = SRLI %t5, 6; GR32Bit:%vreg15
4B		  * %vreg16<def> = ANDI %vreg15<kill>, 63; GR32Bit:%vreg16,%vreg15
4B		  * %vreg17<def> = ADDI %zero, 832; GR32Bit:%vreg17
4B		  * %vreg18<def> = MUL %vreg12<kill>, %vreg17<kill>; GR32Bit:%vreg18,%vreg12,%vreg17
4B		  * %vreg19<def> = ADDI %zero, 52; GR32Bit:%vreg19
4B		  * %vreg20<def> = MUL %vreg14<kill>, %vreg19<kill>; GR32Bit:%vreg20,%vreg14,%vreg19
4B		  * %vreg21<def> = ADD %vreg20<kill>, %vreg16<kill>; GR32Bit:%vreg21,%vreg20,%vreg16
4B		  * %vreg22<def> = ADD %vreg21<kill>, %vreg18<kill>; GR32Bit:%vreg22,%vreg21,%vreg18
4B		  * %vreg23<def> = MUL %vreg22<kill>, %vreg11<kill>; GR32Bit:%vreg23,%vreg22,%vreg11
4B		  * %t5<def> = ADD %vreg10<kill>, %vreg23<kill>; GR32Bit:%vreg10,%vreg23
4B		  * %vreg4<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg4
4B		  * %vreg0<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]; GR32Bit:%vreg0
4B		  * %vreg1<def> = LUI <MCSym="%lo("ga#0")">; GR32Bit:%vreg1
4B		  * SRLI %vreg1, %vreg1, 12; GR32Bit:%vreg1
4B		  * %vreg2<def> = ADD %vreg1<kill>, %vreg0<kill>; GR32Bit:%vreg2,%vreg1,%vreg0
4B		  * %vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[@redefine_in_eicas_egt] GR32Bit:%vreg3,%vreg2
4B		  * SW %vreg3<kill>, %vreg4<kill>, 0; mem:ST4[%0] GR32Bit:%vreg3,%vreg4
4B		  * %vreg81<def> = ADDI %zero, 64; GR32Bit:%vreg81
4B		  * %vreg82<def> = LW %t5, <fi#0>; GR32Bit:%vreg82
4B		  * WRITECM %vreg81<kill>, %vreg82<kill>, 0; GR32Bit:%vreg81,%vreg82
4B		  * END 0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
264B		%t4<def> = ADD %t5, %zero
264B		  * %vreg26<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg26
264B		  * %vreg27<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg27
264B		  * %vreg28<def> = SRLI %vreg27<kill>, 12; GR32Bit:%vreg28,%vreg27
264B		  * %vreg29<def> = ADD %vreg26<kill>, %vreg28<kill>; GR32Bit:%vreg29,%vreg26,%vreg28
264B		  * %vreg30<def> = ADDI %zero, 12; GR32Bit:%vreg30
264B		  * %vreg31<def> = SRLI %t5, 22; GR32Bit:%vreg31
264B		  * %vreg32<def> = SRLI %t5, 12; GR32Bit:%vreg32
264B		  * %vreg33<def> = ANDI %vreg32<kill>, 15; GR32Bit:%vreg33,%vreg32
264B		  * %vreg34<def> = SRLI %t5, 6; GR32Bit:%vreg34
264B		  * %vreg35<def> = ANDI %vreg34<kill>, 63; GR32Bit:%vreg35,%vreg34
264B		  * %vreg36<def> = ADDI %zero, 832; GR32Bit:%vreg36
264B		  * %vreg37<def> = MUL %vreg31<kill>, %vreg36<kill>; GR32Bit:%vreg37,%vreg31,%vreg36
264B		  * %vreg38<def> = ADDI %zero, 52; GR32Bit:%vreg38
264B		  * %vreg39<def> = MUL %vreg33<kill>, %vreg38<kill>; GR32Bit:%vreg39,%vreg33,%vreg38
264B		  * %vreg40<def> = ADD %vreg39<kill>, %vreg35<kill>; GR32Bit:%vreg40,%vreg39,%vreg35
264B		  * %vreg41<def> = ADD %vreg40<kill>, %vreg37<kill>; GR32Bit:%vreg41,%vreg40,%vreg37
264B		  * %vreg42<def> = MUL %vreg41<kill>, %vreg30<kill>; GR32Bit:%vreg42,%vreg41,%vreg30
264B		  * %t5<def> = ADD %vreg29<kill>, %vreg42<kill>; GR32Bit:%vreg29,%vreg42
264B		  * END 0
264B		  * %zero<def> = ADDI %zero, 0
264B		  * %zero<def> = ADDI %zero, 0
440B		%t4<def> = ADD %t5, %zero
440B		  * %vreg45<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg45
440B		  * %vreg46<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg46
440B		  * %vreg47<def> = SRLI %vreg46<kill>, 12; GR32Bit:%vreg47,%vreg46
440B		  * %vreg48<def> = ADD %vreg45<kill>, %vreg47<kill>; GR32Bit:%vreg48,%vreg45,%vreg47
440B		  * %vreg49<def> = ADDI %zero, 12; GR32Bit:%vreg49
440B		  * %vreg50<def> = SRLI %t5, 22; GR32Bit:%vreg50
440B		  * %vreg51<def> = SRLI %t5, 12; GR32Bit:%vreg51
440B		  * %vreg52<def> = ANDI %vreg51<kill>, 15; GR32Bit:%vreg52,%vreg51
440B		  * %vreg53<def> = SRLI %t5, 6; GR32Bit:%vreg53
440B		  * %vreg54<def> = ANDI %vreg53<kill>, 63; GR32Bit:%vreg54,%vreg53
440B		  * %vreg55<def> = ADDI %zero, 832; GR32Bit:%vreg55
440B		  * %vreg56<def> = MUL %vreg50<kill>, %vreg55<kill>; GR32Bit:%vreg56,%vreg50,%vreg55
440B		  * %vreg57<def> = ADDI %zero, 52; GR32Bit:%vreg57
440B		  * %vreg58<def> = MUL %vreg52<kill>, %vreg57<kill>; GR32Bit:%vreg58,%vreg52,%vreg57
440B		  * %vreg59<def> = ADD %vreg58<kill>, %vreg54<kill>; GR32Bit:%vreg59,%vreg58,%vreg54
440B		  * %vreg60<def> = ADD %vreg59<kill>, %vreg56<kill>; GR32Bit:%vreg60,%vreg59,%vreg56
440B		  * %vreg61<def> = MUL %vreg60<kill>, %vreg49<kill>; GR32Bit:%vreg61,%vreg60,%vreg49
440B		  * %t5<def> = ADD %vreg48<kill>, %vreg61<kill>; GR32Bit:%vreg48,%vreg61
440B		  * END 0
440B		  * %zero<def> = ADDI %zero, 0
440B		  * %zero<def> = ADDI %zero, 0
616B		%t4<def> = ADD %t5, %zero
616B		  * %vreg64<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg64
616B		  * %vreg65<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg65
616B		  * %vreg66<def> = SRLI %vreg65<kill>, 12; GR32Bit:%vreg66,%vreg65
616B		  * %vreg67<def> = ADD %vreg64<kill>, %vreg66<kill>; GR32Bit:%vreg67,%vreg64,%vreg66
616B		  * %vreg68<def> = ADDI %zero, 12; GR32Bit:%vreg68
616B		  * %vreg69<def> = SRLI %t5, 22; GR32Bit:%vreg69
616B		  * %vreg70<def> = SRLI %t5, 12; GR32Bit:%vreg70
616B		  * %vreg71<def> = ANDI %vreg70<kill>, 15; GR32Bit:%vreg71,%vreg70
616B		  * %vreg72<def> = SRLI %t5, 6; GR32Bit:%vreg72
616B		  * %vreg73<def> = ANDI %vreg72<kill>, 63; GR32Bit:%vreg73,%vreg72
616B		  * %vreg74<def> = ADDI %zero, 832; GR32Bit:%vreg74
616B		  * %vreg75<def> = MUL %vreg69<kill>, %vreg74<kill>; GR32Bit:%vreg75,%vreg69,%vreg74
616B		  * %vreg76<def> = ADDI %zero, 52; GR32Bit:%vreg76
616B		  * %vreg77<def> = MUL %vreg71<kill>, %vreg76<kill>; GR32Bit:%vreg77,%vreg71,%vreg76
616B		  * %vreg78<def> = ADD %vreg77<kill>, %vreg73<kill>; GR32Bit:%vreg78,%vreg77,%vreg73
616B		  * %vreg79<def> = ADD %vreg78<kill>, %vreg75<kill>; GR32Bit:%vreg79,%vreg78,%vreg75
616B		  * %vreg80<def> = MUL %vreg79<kill>, %vreg68<kill>; GR32Bit:%vreg80,%vreg79,%vreg68
616B		  * %t5<def> = ADD %vreg67<kill>, %vreg80<kill>; GR32Bit:%vreg67,%vreg80
616B		  * END 0
616B		  * %zero<def> = ADDI %zero, 0
616B		  * %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> %t0<def> = ADDI %t5, <fi#0>
> %t1<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]
> %t2<def> = LUI <MCSym="%lo("ga#0")">
> SRLI %t2, %t2, 12
> %t1<def> = ADD %t2<kill>, %t1<kill>
> %t1<def> = LW %t1<kill>, 0; mem:LD4[@redefine_in_eicas_egt]
> SW %t1<kill>, %t0<kill>, 0; mem:ST4[%0]
> %t0<def> = ADDI %zero, 64
> %t1<def> = LW %t5, <fi#0>
> WRITECM %t0<kill>, %t1<kill>, 0
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
********** EMITTING LIVE DEBUG VARIABLES **********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: redefine_start1
max x:0, min x:0
max y:0, min y:0
current state of mf:# Machine code for function redefine_start1: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]

BB#0: derived from LLVM BB %redefine_start1.entry
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * %t0<def> = ADDI %t5, <fi#0>
	  * %t1<def> = LUI <ga:@redefine_in_eicas_egt>[TF=2]
	  * %t2<def> = LUI <MCSym="%lo("ga#0")">
	  * SRLI %t2, %t2, 12
	  * %t1<def> = ADD %t2<kill>, %t1<kill>
	  * %t1<def> = LW %t1<kill>, 0; mem:LD4[@redefine_in_eicas_egt]
	  * SW %t1<kill>, %t0<kill>, 0; mem:ST4[%0]
	  * %t0<def> = ADDI %zero, 64
	  * %t1<def> = LW %t5, <fi#0>
	  * WRITECM %t0<kill>, %t1<kill>, 0
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0

# End machine code for function redefine_start1.

lowering frame index for func redefine_start1:0 TO VAL:0
lowering frame index for func redefine_start1:0 TO VAL:0
CGP: Found      local addrmode: [Base:@redefine_out_eicas_egt]
Computing probabilities for redefine_start2.return
Computing probabilities for redefine_start2.newName01



=== redefine_start2
store visit is after?  store i32 %0, i32* @redefine_out_eicas_egt, align 4
I was here to add @redefine_out_eicas_egt = common global i32 0, align 4
whats in dag after store?SelectionDAG has 7 nodes:
  0x2891968: ch = EntryToken [ORD=3]

  0x28aed90: i32 = Constant<0>

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3]

    0x28aef90: i32 = GlobalAddress<i32* @redefine_out_eicas_egt> 0 [ORD=3]

    0x28af290: i32 = undef [ORD=3]

  0x28af090: ch = store 0x2891968, 0x28af790, 0x28aef90, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3]


Initial selection DAG: BB#0 'redefine_start2:redefine_start2.newName01'
SelectionDAG has 7 nodes:
  0x2891968: ch = EntryToken [ORD=3]

  0x28aed90: i32 = Constant<0>

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3]

    0x28aef90: i32 = GlobalAddress<i32* @redefine_out_eicas_egt> 0 [ORD=3]

    0x28af290: i32 = undef [ORD=3]

  0x28af090: ch = store 0x2891968, 0x28af790, 0x28aef90, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3]


Optimized lowered selection DAG: BB#0 'redefine_start2:redefine_start2.newName01'
SelectionDAG has 6 nodes:
  0x2891968: ch = EntryToken [ORD=3]

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3]

    0x28aef90: i32 = GlobalAddress<i32* @redefine_out_eicas_egt> 0 [ORD=3]

    0x28af290: i32 = undef [ORD=3]

  0x28af090: ch = store 0x2891968, 0x28af790, 0x28aef90, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3]


Legally typed node: 0x28af290: i32 = undef [ORD=3] [ID=0]

Legally typed node: 0x28aef90: i32 = GlobalAddress<i32* @redefine_out_eicas_egt> 0 [ORD=3] [ID=0]

Legally typed node: 0x28af890: i32 = Register %vreg0 [ORD=3] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=3] [ID=0]

Legally typed node: 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=0]

Legally typed node: 0x28af090: ch = store 0x2891968, 0x28af790, 0x28aef90, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28af090 [ID=0]

Type-legalized selection DAG: BB#0 'redefine_start2:redefine_start2.newName01'
SelectionDAG has 6 nodes:
  0x2891968: ch = EntryToken [ORD=3] [ID=-3]

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3] [ID=-3]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=-3]

    0x28aef90: i32 = GlobalAddress<i32* @redefine_out_eicas_egt> 0 [ORD=3] [ID=-3]

    0x28af290: i32 = undef [ORD=3] [ID=-3]

  0x28af090: ch = store 0x2891968, 0x28af790, 0x28aef90, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=-3]


Legalized selection DAG: BB#0 'redefine_start2:redefine_start2.newName01'
SelectionDAG has 10 nodes:
  0x2891968: ch = EntryToken [ORD=3] [ID=0]

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3] [ID=1]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]

        0x28aed90: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=2]

      0x28af590: i32 = REDEFINEISD::Hi 0x28aed90

        0x28af690: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=3]

      0x28af490: i32 = REDEFINEISD::Lo 0x28af690

    0x28af390: i32 = add 0x28af590, 0x28af490

    0x28af290: i32 = undef [ORD=3] [ID=3]

  0x28af090: ch = store 0x2891968, 0x28af790, 0x28af390, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=5]


Optimized legalized selection DAG: BB#0 'redefine_start2:redefine_start2.newName01'
SelectionDAG has 10 nodes:
  0x2891968: ch = EntryToken [ORD=3] [ID=0]

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3] [ID=1]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]

        0x28aed90: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=2]

      0x28af590: i32 = REDEFINEISD::Hi 0x28aed90

        0x28af690: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=3]

      0x28af490: i32 = REDEFINEISD::Lo 0x28af690

    0x28af390: i32 = add 0x28af590, 0x28af490

    0x28af290: i32 = undef [ORD=3] [ID=3]

  0x28af090: ch = store 0x2891968, 0x28af790, 0x28af390, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=5]


===== Instruction selection begins: BB#0 'redefine_start2.newName01'
ISEL: Starting pattern match on root node: 0x28af090: ch = store 0x2891968, 0x28af790, 0x28af390, 0x28af290<ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=9]

  Initial Opcode index to 178
  Morphed node: 0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3]

ISEL: Match complete!
=> 0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3]

ISEL: Starting pattern match on root node: 0x28af390: i32 = add 0x28af590, 0x28af490 [ID=8]

  Initial Opcode index to 493
  Match failed at index 499
  Continuing at 516
  Morphed node: 0x28af390: i32 = ADD 0x28af490, 0x28af590

ISEL: Match complete!
=> 0x28af390: i32 = ADD 0x28af490, 0x28af590

ISEL: Starting pattern match on root node: 0x28af490: i32 = REDEFINEISD::Lo 0x28af690 [ID=7]

  Initial Opcode index to 1204
  Morphed node: 0x28af490: i32 = ADDI 0x28af290, 0x28af690

ISEL: Match complete!
=> 0x28af490: i32 = ADDI 0x28af290, 0x28af690

ISEL: Starting pattern match on root node: 0x28af590: i32 = REDEFINEISD::Hi 0x28aed90 [ID=6]

  Initial Opcode index to 1186
  Morphed node: 0x28af590: i32 = LUI 0x28aed90

ISEL: Match complete!
=> 0x28af590: i32 = LUI 0x28aed90

=> 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3]

=> 0x28af690: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=3]

=> 0x28aed90: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=2]

=> 0x28af890: i32 = Register %vreg0 [ORD=3]

=> 0x2891968: ch = EntryToken [ORD=3]

===== Instruction selection ends:
Selected selection DAG: BB#0 'redefine_start2:redefine_start2.newName01'
SelectionDAG has 11 nodes:
  0x2891968: ch = EntryToken [ORD=3]

      0x2891968: <multiple use>
      0x28af890: i32 = Register %vreg0 [ORD=3]

    0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3]

        0x28af290: i32 = Register %zero

        0x28af690: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=3]

      0x28af490: i32 = ADDI 0x28af290, 0x28af690

        0x28aed90: i32 = TargetGlobalAddress<i32* @redefine_out_eicas_egt> 0 [TF=2]

      0x28af590: i32 = LUI 0x28aed90

    0x28af390: i32 = ADD 0x28af490, 0x28af590

    0x28aef90: i32 = TargetConstant<0>

    0x2891968: <multiple use>
  0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3]


********** List Scheduling BB#0 'redefine_start2.newName01' **********
SU(0): 0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=0]

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
   val SU(4): Latency=1
   val SU(1): Latency=1

SU(1): 0x28af390: i32 = ADD 0x28af490, 0x28af590 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
   val SU(3): Latency=1
   val SU(2): Latency=1
  Successors:
   val SU(0): Latency=1

SU(2): 0x28af590: i32 = LUI 0x28aed90 [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(3): 0x28af490: i32 = ADDI 0x28af290, 0x28af690 [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=0]


*** Scheduling [0]: SU(0): 0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=0]


Examining Available:
Height 1: SU(1): 0x28af390: i32 = ADD 0x28af490, 0x28af590 [ID=1]

Height 1: SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]


*** Scheduling [1]: SU(1): 0x28af390: i32 = ADD 0x28af490, 0x28af590 [ID=1]


Examining Available:
Height 2: SU(3): 0x28af490: i32 = ADDI 0x28af290, 0x28af690 [ID=3]

Height 2: SU(2): 0x28af590: i32 = LUI 0x28aed90 [ID=2]

Height 1: SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]


*** Scheduling [2]: SU(3): 0x28af490: i32 = ADDI 0x28af290, 0x28af690 [ID=3]


Examining Available:
Height 2: SU(2): 0x28af590: i32 = LUI 0x28aed90 [ID=2]

Height 1: SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]


*** Scheduling [3]: SU(2): 0x28af590: i32 = LUI 0x28aed90 [ID=2]


Examining Available:
Height 1: SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]


*** Scheduling [4]: SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]

*** Final schedule ***
SU(4): 0x28af790: i32,ch = CopyFromReg 0x2891968, 0x28af890 [ORD=3] [ID=4]

SU(2): 0x28af590: i32 = LUI 0x28aed90 [ID=2]

SU(3): 0x28af490: i32 = ADDI 0x28af290, 0x28af690 [ID=3]

SU(1): 0x28af390: i32 = ADD 0x28af490, 0x28af590 [ID=1]

SU(0): 0x28af090: ch = SW 0x28af790, 0x28af390, 0x28aef90, 0x2891968<Mem:ST4[@redefine_out_eicas_egt]> [ORD=3] [ID=0]


Total amount of phi nodes to update: 0
Initial selection DAG: BB#1 'redefine_start2:redefine_start2.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken


Optimized lowered selection DAG: BB#1 'redefine_start2:redefine_start2.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken


Legally typed node: 0x2891968: ch = EntryToken [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x2891968 [ID=0]

Type-legalized selection DAG: BB#1 'redefine_start2:redefine_start2.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken [ID=-3]


Legalized selection DAG: BB#1 'redefine_start2:redefine_start2.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken [ID=0]


Optimized legalized selection DAG: BB#1 'redefine_start2:redefine_start2.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken [ID=0]


===== Instruction selection begins: BB#1 'redefine_start2.return'
=> 0x2891968: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#1 'redefine_start2:redefine_start2.return'
SelectionDAG has 1 nodes:
  0x2891968: ch = EntryToken


********** List Scheduling BB#1 'redefine_start2.return' **********
*** Final schedule ***

Total amount of phi nodes to update: 0

*** Tail-duplicating BB#1

Merging into block: BB#0: derived from LLVM BB %redefine_start2.newName01
    Live Ins: %ra
	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
	%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
	%vreg3<def> = ADD %vreg2<kill>, %vreg1<kill>; GR32Bit:%vreg3,%vreg2,%vreg1
	SW %vreg0, %vreg3<kill>, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
    Successors according to CFG: BB#1
From MBB: BB#1: derived from LLVM BB %redefine_start2.return
    Predecessors according to CFG: BB#0

Removing MBB: BB#1: derived from LLVM BB %redefine_start2.return
# Machine code for function redefine_start2: SSA
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %redefine_start2.newName01
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra; GR32Bit:%vreg0
32B		%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
48B		%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
64B		%vreg3<def> = ADD %vreg2<kill>, %vreg1<kill>; GR32Bit:%vreg3,%vreg2,%vreg1
80B		SW %vreg0, %vreg3<kill>, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3

# End machine code for function redefine_start2.

********** Stack Coloring **********
********** Function: redefine_start2
******** Pre-regalloc Machine LICM: redefine_start2 ********
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: redefine_start2
********** PROCESS IMPLICIT DEFS **********
********** Function: redefine_start2
********** REWRITING TWO-ADDR INSTRS **********
********** Function: redefine_start2
# Machine code for function redefine_start2: Post SSA
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %redefine_start2.newName01
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra<kill>; GR32Bit:%vreg0
32B		%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
48B		%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
64B		%vreg3<def> = ADD %vreg2<kill>, %vreg1<kill>; GR32Bit:%vreg3,%vreg2,%vreg1
80B		SW %vreg0<kill>, %vreg3<kill>, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3

# End machine code for function redefine_start2.

Computing live-in reg-units in ABI blocks.
0B	BB#0 ra#0
Created 1 new intervals.
********** INTERVALS **********
ra = [0B,16r:0)  0@0B-phi
%vreg0 = [16r,80r:0)  0@16r
%vreg1 = [32r,64r:0)  0@32r
%vreg2 = [48r,64r:0)  0@48r
%vreg3 = [64r,80r:0)  0@64r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function redefine_start2: Post SSA
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %redefine_start2.newName01
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra; GR32Bit:%vreg0
32B		%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
48B		%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
64B		%vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
80B		SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3

# End machine code for function redefine_start2.

********** SIMPLE REGISTER COALESCING **********
********** Function: redefine_start2
********** JOINING INTERVALS ***********
redefine_start2.newName01:
16B	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	Considering merging %vreg0 with %ra
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
ra = [0B,16r:0)  0@0B-phi
%vreg0 = [16r,80r:0)  0@16r
%vreg1 = [32r,64r:0)  0@32r
%vreg2 = [48r,64r:0)  0@48r
%vreg3 = [64r,80r:0)  0@64r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function redefine_start2: Post SSA
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %redefine_start2.newName01
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra; GR32Bit:%vreg0
32B		%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
48B		%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
64B		%vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
80B		SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3

# End machine code for function redefine_start2.

Before MISched:
# Machine code for function redefine_start2: Post SSA
Function Live Ins: %ra in %vreg0

BB#0: derived from LLVM BB %redefine_start2.newName01
    Live Ins: %ra
	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
	%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
	%vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
	SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3

# End machine code for function redefine_start2.


-------------
Starting new basic block BB#0
********** MI Scheduling **********
redefine_start2:BB#0 redefine_start2.newName01
  From: %vreg0<def> = COPY %ra; GR32Bit:%vreg0
    To: End Remaining: 0
Max Pressure: GR32Bit=3
Live In: %gp 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 3
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 0
  SU(3) in tree 0
  SU(4) in tree 0
SU(0):   %vreg0<def> = COPY %ra; GR32Bit:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   val SU(4): Latency=0 Reg=%vreg0

SU(1):   %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
   val SU(3): Latency=5 Reg=%vreg1

SU(2):   %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
   val SU(3): Latency=5 Reg=%vreg2

SU(3):   %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 5
  Height             : 5
  Predecessors:
   val SU(2): Latency=5 Reg=%vreg2
   val SU(1): Latency=5 Reg=%vreg1
  Successors:
   val SU(4): Latency=5 Reg=%vreg3

SU(4):   SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 10
  Height             : 0
  Predecessors:
   val SU(3): Latency=5 Reg=%vreg3
   val SU(0): Latency=0 Reg=%vreg0
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg0<def> = COPY %ra; GR32Bit:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   val SU(4): Latency=0 Reg=%vreg0

SU(1):   %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
   val SU(3): Latency=5 Reg=%vreg1

SU(2):   %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 10
  Successors:
   val SU(3): Latency=5 Reg=%vreg2

SU(3):   %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 5
  Height             : 5
  Predecessors:
   val SU(2): Latency=5 Reg=%vreg2
   val SU(1): Latency=5 Reg=%vreg1
  Successors:
   val SU(4): Latency=5 Reg=%vreg3

SU(4):   SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 10
  Height             : 0
  Predecessors:
   val SU(3): Latency=5 Reg=%vreg3
   val SU(0): Latency=0 Reg=%vreg0
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(2)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
handleMove 48B -> 8B: %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
     %vreg2:	[48r,64r:0)  0@48r
        -->	[8r,64r:0)  0@8r
     zero:	EMPTY
        -->	EMPTY
Pick node SU(1)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
handleMove 32B -> 12B: %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
     %vreg1:	[32r,64r:0)  0@32r
        -->	[12r,64r:0)  0@12r
Pick node SU(3)  ILP: 3 / 6 = 0.5 Tree: 0 @0
Scheduling %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1

*** Renumbered SlotIndexes 12-28 ***
handleMove 64B -> 20B: %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
     %vreg3:	[64r,80r:0)  0@64r
        -->	[20r,80r:0)  0@20r
     %vreg2:	[8r,64r:0)  0@8r
        -->	[8r,20r:0)  0@8r
     %vreg1:	[12r,64r:0)  0@12r
        -->	[12r,20r:0)  0@12r
Pick node SU(0)  ILP: 0 / 1 = 0 Tree: 0 @0
Scheduling %vreg0<def> = COPY %ra; GR32Bit:%vreg0
Pick node SU(4)  ILP: 4 / 11 = 0.363636 Tree: 0 @0
Scheduling SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
*** Final schedule for BB#0 ***
SU(2):   %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
SU(1):   %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
SU(3):   %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
SU(0):   %vreg0<def> = COPY %ra; GR32Bit:%vreg0
SU(4):   SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3


*** Renumbered SlotIndexes 4-60 ***

*** Renumbered SlotIndexes 16-88 ***

*** Renumbered SlotIndexes 28-108 ***

*** Renumbered SlotIndexes 40-120 ***

*** Renumbered SlotIndexes 52-132 ***

*** Renumbered SlotIndexes 64-144 ***

*** Renumbered SlotIndexes 76-156 ***

*** Renumbered SlotIndexes 88-168 ***

*** Renumbered SlotIndexes 100-180 ***

*** Renumbered SlotIndexes 112-192 ***

*** Renumbered SlotIndexes 124-204 ***

*** Renumbered SlotIndexes 136-216 ***

*** Renumbered SlotIndexes 148-228 ***

*** Renumbered SlotIndexes 160-240 ***

*** Renumbered SlotIndexes 172-252 ***

*** Renumbered SlotIndexes 184-264 ***

*** Renumbered SlotIndexes 196-276 ***

*** Renumbered SlotIndexes 208-288 ***

*** Renumbered SlotIndexes 220-300 ***

*** Renumbered SlotIndexes 232-312 ***

*** Renumbered SlotIndexes 244-324 ***

*** Renumbered SlotIndexes 256-336 ***

*** Renumbered SlotIndexes 268-348 ***

*** Renumbered SlotIndexes 280-360 ***

*** Renumbered SlotIndexes 292-372 ***

*** Renumbered SlotIndexes 304-384 ***

*** Renumbered SlotIndexes 316-396 ***

*** Renumbered SlotIndexes 328-408 ***

*** Renumbered SlotIndexes 340-420 ***

*** Renumbered SlotIndexes 352-432 ***

*** Renumbered SlotIndexes 364-444 ***

*** Renumbered SlotIndexes 376-456 ***

*** Renumbered SlotIndexes 388-468 ***

*** Renumbered SlotIndexes 400-480 ***
Partitioning instructions of the region into multiple CEs
instr:  %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
instr:  %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
instr:  %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
instr:  %vreg0<def> = COPY %ra; GR32Bit:%vreg0
instr:  SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
before falloc, state of bb0:BB#0: derived from LLVM BB %redefine_start2.newName01
    Live Ins: %ra
	%vreg4<def> = ADD %t5, %zero; GR32Bit:%vreg4
	%vreg6<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg6
	%vreg7<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg7
	%vreg8<def> = SRLI %vreg7, 12; GR32Bit:%vreg8,%vreg7
	%vreg9<def> = ADD %vreg6, %vreg8; GR32Bit:%vreg9,%vreg6,%vreg8
	%vreg10<def> = ADDI %zero, 12; GR32Bit:%vreg10
	%vreg11<def> = SRLI %t5, 22; GR32Bit:%vreg11
	%vreg12<def> = SRLI %t5, 12; GR32Bit:%vreg12
	%vreg13<def> = ANDI %vreg12, 15; GR32Bit:%vreg13,%vreg12
	%vreg14<def> = SRLI %t5, 6; GR32Bit:%vreg14
	%vreg15<def> = ANDI %vreg14, 63; GR32Bit:%vreg15,%vreg14
	%vreg16<def> = ADDI %zero, 832; GR32Bit:%vreg16
	%vreg17<def> = MUL %vreg11, %vreg16; GR32Bit:%vreg17,%vreg11,%vreg16
	%vreg18<def> = ADDI %zero, 52; GR32Bit:%vreg18
	%vreg19<def> = MUL %vreg13, %vreg18; GR32Bit:%vreg19,%vreg13,%vreg18
	%vreg20<def> = ADD %vreg19, %vreg15; GR32Bit:%vreg20,%vreg19,%vreg15
	%vreg21<def> = ADD %vreg20, %vreg17; GR32Bit:%vreg21,%vreg20,%vreg17
	%vreg22<def> = MUL %vreg21, %vreg10; GR32Bit:%vreg22,%vreg21,%vreg10
	%vreg5<def> = ADD %vreg9, %vreg22; GR32Bit:%vreg5,%vreg9,%vreg22
	%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
	%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
	%vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
	%vreg23<def> = ADD %t5, %zero; GR32Bit:%vreg23
	%vreg25<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg25
	%vreg26<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg26
	%vreg27<def> = SRLI %vreg26, 12; GR32Bit:%vreg27,%vreg26
	%vreg28<def> = ADD %vreg25, %vreg27; GR32Bit:%vreg28,%vreg25,%vreg27
	%vreg29<def> = ADDI %zero, 12; GR32Bit:%vreg29
	%vreg30<def> = SRLI %t5, 22; GR32Bit:%vreg30
	%vreg31<def> = SRLI %t5, 12; GR32Bit:%vreg31
	%vreg32<def> = ANDI %vreg31, 15; GR32Bit:%vreg32,%vreg31
	%vreg33<def> = SRLI %t5, 6; GR32Bit:%vreg33
	%vreg34<def> = ANDI %vreg33, 63; GR32Bit:%vreg34,%vreg33
	%vreg35<def> = ADDI %zero, 832; GR32Bit:%vreg35
	%vreg36<def> = MUL %vreg30, %vreg35; GR32Bit:%vreg36,%vreg30,%vreg35
	%vreg37<def> = ADDI %zero, 52; GR32Bit:%vreg37
	%vreg38<def> = MUL %vreg32, %vreg37; GR32Bit:%vreg38,%vreg32,%vreg37
	%vreg39<def> = ADD %vreg38, %vreg34; GR32Bit:%vreg39,%vreg38,%vreg34
	%vreg40<def> = ADD %vreg39, %vreg36; GR32Bit:%vreg40,%vreg39,%vreg36
	%vreg41<def> = MUL %vreg40, %vreg29; GR32Bit:%vreg41,%vreg40,%vreg29
	%vreg24<def> = ADD %vreg28, %vreg41; GR32Bit:%vreg24,%vreg28,%vreg41
	%vreg42<def> = ADD %t5, %zero; GR32Bit:%vreg42
	%vreg44<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg44
	%vreg45<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg45
	%vreg46<def> = SRLI %vreg45, 12; GR32Bit:%vreg46,%vreg45
	%vreg47<def> = ADD %vreg44, %vreg46; GR32Bit:%vreg47,%vreg44,%vreg46
	%vreg48<def> = ADDI %zero, 12; GR32Bit:%vreg48
	%vreg49<def> = SRLI %t5, 22; GR32Bit:%vreg49
	%vreg50<def> = SRLI %t5, 12; GR32Bit:%vreg50
	%vreg51<def> = ANDI %vreg50, 15; GR32Bit:%vreg51,%vreg50
	%vreg52<def> = SRLI %t5, 6; GR32Bit:%vreg52
	%vreg53<def> = ANDI %vreg52, 63; GR32Bit:%vreg53,%vreg52
	%vreg54<def> = ADDI %zero, 832; GR32Bit:%vreg54
	%vreg55<def> = MUL %vreg49, %vreg54; GR32Bit:%vreg55,%vreg49,%vreg54
	%vreg56<def> = ADDI %zero, 52; GR32Bit:%vreg56
	%vreg57<def> = MUL %vreg51, %vreg56; GR32Bit:%vreg57,%vreg51,%vreg56
	%vreg58<def> = ADD %vreg57, %vreg53; GR32Bit:%vreg58,%vreg57,%vreg53
	%vreg59<def> = ADD %vreg58, %vreg55; GR32Bit:%vreg59,%vreg58,%vreg55
	%vreg60<def> = MUL %vreg59, %vreg48; GR32Bit:%vreg60,%vreg59,%vreg48
	%vreg43<def> = ADD %vreg47, %vreg60; GR32Bit:%vreg43,%vreg47,%vreg60
	%vreg61<def> = ADD %t5, %zero; GR32Bit:%vreg61
	%vreg63<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg63
	%vreg64<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg64
	%vreg65<def> = SRLI %vreg64, 12; GR32Bit:%vreg65,%vreg64
	%vreg66<def> = ADD %vreg63, %vreg65; GR32Bit:%vreg66,%vreg63,%vreg65
	%vreg67<def> = ADDI %zero, 12; GR32Bit:%vreg67
	%vreg68<def> = SRLI %t5, 22; GR32Bit:%vreg68
	%vreg69<def> = SRLI %t5, 12; GR32Bit:%vreg69
	%vreg70<def> = ANDI %vreg69, 15; GR32Bit:%vreg70,%vreg69
	%vreg71<def> = SRLI %t5, 6; GR32Bit:%vreg71
	%vreg72<def> = ANDI %vreg71, 63; GR32Bit:%vreg72,%vreg71
	%vreg73<def> = ADDI %zero, 832; GR32Bit:%vreg73
	%vreg74<def> = MUL %vreg68, %vreg73; GR32Bit:%vreg74,%vreg68,%vreg73
	%vreg75<def> = ADDI %zero, 52; GR32Bit:%vreg75
	%vreg76<def> = MUL %vreg70, %vreg75; GR32Bit:%vreg76,%vreg70,%vreg75
	%vreg77<def> = ADD %vreg76, %vreg72; GR32Bit:%vreg77,%vreg76,%vreg72
	%vreg78<def> = ADD %vreg77, %vreg74; GR32Bit:%vreg78,%vreg77,%vreg74
	%vreg79<def> = MUL %vreg78, %vreg67; GR32Bit:%vreg79,%vreg78,%vreg67
	%vreg62<def> = ADD %vreg66, %vreg79; GR32Bit:%vreg62,%vreg66,%vreg79
Adding all fallocs first to avoid stalls due to sequential fallocs and fbinds
Adding writecm(for writing sync count to context frames) and fbind instructions
live end of child is itself
live end of child is itself
Adding localref sw instructions to hyperOp redefine_start2
Adding writecm instructions to hyperOp redefine_start2
Adding writecmp and sync instructions
Adding endHyperOp instructions to each pHyperOp

*** Renumbered SlotIndexes 412-492 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 424-504 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 436-516 ***
  %zero<def> = ADDI %zero, 0
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 448-528 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 460-540 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 472-552 ***
  %zero<def> = ADDI %zero, 0
  %zero<def> = ADDI %zero, 0
After Shuffling regions of basic block, state of BB#0:
BB#0: derived from LLVM BB %redefine_start2.newName01
    Live Ins: %ra
	%vreg4<def> = ADD %t5, %zero; GR32Bit:%vreg4
	%vreg6<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg6
	%vreg7<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg7
	%vreg8<def> = SRLI %vreg7, 12; GR32Bit:%vreg8,%vreg7
	%vreg9<def> = ADD %vreg6, %vreg8; GR32Bit:%vreg9,%vreg6,%vreg8
	%vreg10<def> = ADDI %zero, 12; GR32Bit:%vreg10
	%vreg11<def> = SRLI %t5, 22; GR32Bit:%vreg11
	%vreg12<def> = SRLI %t5, 12; GR32Bit:%vreg12
	%vreg13<def> = ANDI %vreg12, 15; GR32Bit:%vreg13,%vreg12
	%vreg14<def> = SRLI %t5, 6; GR32Bit:%vreg14
	%vreg15<def> = ANDI %vreg14, 63; GR32Bit:%vreg15,%vreg14
	%vreg16<def> = ADDI %zero, 832; GR32Bit:%vreg16
	%vreg17<def> = MUL %vreg11, %vreg16; GR32Bit:%vreg17,%vreg11,%vreg16
	%vreg18<def> = ADDI %zero, 52; GR32Bit:%vreg18
	%vreg19<def> = MUL %vreg13, %vreg18; GR32Bit:%vreg19,%vreg13,%vreg18
	%vreg20<def> = ADD %vreg19, %vreg15; GR32Bit:%vreg20,%vreg19,%vreg15
	%vreg21<def> = ADD %vreg20, %vreg17; GR32Bit:%vreg21,%vreg20,%vreg17
	%vreg22<def> = MUL %vreg21, %vreg10; GR32Bit:%vreg22,%vreg21,%vreg10
	%vreg5<def> = ADD %vreg9, %vreg22; GR32Bit:%vreg5,%vreg9,%vreg22
	%vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
	%vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
	%vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
	FDELETE %t4, 0
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg23<def> = ADD %t5, %zero; GR32Bit:%vreg23
	%vreg25<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg25
	%vreg26<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg26
	%vreg27<def> = SRLI %vreg26, 12; GR32Bit:%vreg27,%vreg26
	%vreg28<def> = ADD %vreg25, %vreg27; GR32Bit:%vreg28,%vreg25,%vreg27
	%vreg29<def> = ADDI %zero, 12; GR32Bit:%vreg29
	%vreg30<def> = SRLI %t5, 22; GR32Bit:%vreg30
	%vreg31<def> = SRLI %t5, 12; GR32Bit:%vreg31
	%vreg32<def> = ANDI %vreg31, 15; GR32Bit:%vreg32,%vreg31
	%vreg33<def> = SRLI %t5, 6; GR32Bit:%vreg33
	%vreg34<def> = ANDI %vreg33, 63; GR32Bit:%vreg34,%vreg33
	%vreg35<def> = ADDI %zero, 832; GR32Bit:%vreg35
	%vreg36<def> = MUL %vreg30, %vreg35; GR32Bit:%vreg36,%vreg30,%vreg35
	%vreg37<def> = ADDI %zero, 52; GR32Bit:%vreg37
	%vreg38<def> = MUL %vreg32, %vreg37; GR32Bit:%vreg38,%vreg32,%vreg37
	%vreg39<def> = ADD %vreg38, %vreg34; GR32Bit:%vreg39,%vreg38,%vreg34
	%vreg40<def> = ADD %vreg39, %vreg36; GR32Bit:%vreg40,%vreg39,%vreg36
	%vreg41<def> = MUL %vreg40, %vreg29; GR32Bit:%vreg41,%vreg40,%vreg29
	%vreg24<def> = ADD %vreg28, %vreg41; GR32Bit:%vreg24,%vreg28,%vreg41
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg42<def> = ADD %t5, %zero; GR32Bit:%vreg42
	%vreg44<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg44
	%vreg45<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg45
	%vreg46<def> = SRLI %vreg45, 12; GR32Bit:%vreg46,%vreg45
	%vreg47<def> = ADD %vreg44, %vreg46; GR32Bit:%vreg47,%vreg44,%vreg46
	%vreg48<def> = ADDI %zero, 12; GR32Bit:%vreg48
	%vreg49<def> = SRLI %t5, 22; GR32Bit:%vreg49
	%vreg50<def> = SRLI %t5, 12; GR32Bit:%vreg50
	%vreg51<def> = ANDI %vreg50, 15; GR32Bit:%vreg51,%vreg50
	%vreg52<def> = SRLI %t5, 6; GR32Bit:%vreg52
	%vreg53<def> = ANDI %vreg52, 63; GR32Bit:%vreg53,%vreg52
	%vreg54<def> = ADDI %zero, 832; GR32Bit:%vreg54
	%vreg55<def> = MUL %vreg49, %vreg54; GR32Bit:%vreg55,%vreg49,%vreg54
	%vreg56<def> = ADDI %zero, 52; GR32Bit:%vreg56
	%vreg57<def> = MUL %vreg51, %vreg56; GR32Bit:%vreg57,%vreg51,%vreg56
	%vreg58<def> = ADD %vreg57, %vreg53; GR32Bit:%vreg58,%vreg57,%vreg53
	%vreg59<def> = ADD %vreg58, %vreg55; GR32Bit:%vreg59,%vreg58,%vreg55
	%vreg60<def> = MUL %vreg59, %vreg48; GR32Bit:%vreg60,%vreg59,%vreg48
	%vreg43<def> = ADD %vreg47, %vreg60; GR32Bit:%vreg43,%vreg47,%vreg60
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg61<def> = ADD %t5, %zero; GR32Bit:%vreg61
	%vreg63<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg63
	%vreg64<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg64
	%vreg65<def> = SRLI %vreg64, 12; GR32Bit:%vreg65,%vreg64
	%vreg66<def> = ADD %vreg63, %vreg65; GR32Bit:%vreg66,%vreg63,%vreg65
	%vreg67<def> = ADDI %zero, 12; GR32Bit:%vreg67
	%vreg68<def> = SRLI %t5, 22; GR32Bit:%vreg68
	%vreg69<def> = SRLI %t5, 12; GR32Bit:%vreg69
	%vreg70<def> = ANDI %vreg69, 15; GR32Bit:%vreg70,%vreg69
	%vreg71<def> = SRLI %t5, 6; GR32Bit:%vreg71
	%vreg72<def> = ANDI %vreg71, 63; GR32Bit:%vreg72,%vreg71
	%vreg73<def> = ADDI %zero, 832; GR32Bit:%vreg73
	%vreg74<def> = MUL %vreg68, %vreg73; GR32Bit:%vreg74,%vreg68,%vreg73
	%vreg75<def> = ADDI %zero, 52; GR32Bit:%vreg75
	%vreg76<def> = MUL %vreg70, %vreg75; GR32Bit:%vreg76,%vreg70,%vreg75
	%vreg77<def> = ADD %vreg76, %vreg72; GR32Bit:%vreg77,%vreg76,%vreg72
	%vreg78<def> = ADD %vreg77, %vreg74; GR32Bit:%vreg78,%vreg77,%vreg74
	%vreg79<def> = MUL %vreg78, %vreg67; GR32Bit:%vreg79,%vreg78,%vreg67
	%vreg62<def> = ADD %vreg66, %vreg79; GR32Bit:%vreg62,%vreg66,%vreg79
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 316-628 ***

*** Renumbered SlotIndexes 304-648 ***

*** Renumbered SlotIndexes 216-696 ***

*** Renumbered SlotIndexes 204-716 ***

*** Renumbered SlotIndexes 204-732 ***

*** Renumbered SlotIndexes 112-776 ***

*** Renumbered SlotIndexes 100-796 ***

*** Renumbered SlotIndexes 100-812 ***

*** Renumbered SlotIndexes 100-828 ***

*** Renumbered SlotIndexes 100-844 ***

*** Renumbered SlotIndexes 12-892 ***
Creating pHyperOp bundles for CEs for bb0
  %vreg23<def> = ADD %t5, %zero; GR32Bit:%vreg23
starting at   %vreg4<def> = ADD %t5, %zero; GR32Bit:%vreg4
  %vreg42<def> = ADD %t5, %zero; GR32Bit:%vreg42
starting at   %vreg23<def> = ADD %t5, %zero; GR32Bit:%vreg23
  %vreg61<def> = ADD %t5, %zero; GR32Bit:%vreg61
starting at   %vreg42<def> = ADD %t5, %zero; GR32Bit:%vreg42
starting at   %vreg61<def> = ADD %t5, %zero; GR32Bit:%vreg61
After bundling, state of BB0:BB#0: derived from LLVM BB %redefine_start2.newName01
    Live Ins: %ra
	%vreg4<def> = ADD %t5, %zero; GR32Bit:%vreg4
	  * %vreg6<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg6
	  * %vreg7<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg7
	  * %vreg8<def> = SRLI %vreg7, 12; GR32Bit:%vreg8,%vreg7
	  * %vreg9<def> = ADD %vreg6, %vreg8; GR32Bit:%vreg9,%vreg6,%vreg8
	  * %vreg10<def> = ADDI %zero, 12; GR32Bit:%vreg10
	  * %vreg11<def> = SRLI %t5, 22; GR32Bit:%vreg11
	  * %vreg12<def> = SRLI %t5, 12; GR32Bit:%vreg12
	  * %vreg13<def> = ANDI %vreg12, 15; GR32Bit:%vreg13,%vreg12
	  * %vreg14<def> = SRLI %t5, 6; GR32Bit:%vreg14
	  * %vreg15<def> = ANDI %vreg14, 63; GR32Bit:%vreg15,%vreg14
	  * %vreg16<def> = ADDI %zero, 832; GR32Bit:%vreg16
	  * %vreg17<def> = MUL %vreg11, %vreg16; GR32Bit:%vreg17,%vreg11,%vreg16
	  * %vreg18<def> = ADDI %zero, 52; GR32Bit:%vreg18
	  * %vreg19<def> = MUL %vreg13, %vreg18; GR32Bit:%vreg19,%vreg13,%vreg18
	  * %vreg20<def> = ADD %vreg19, %vreg15; GR32Bit:%vreg20,%vreg19,%vreg15
	  * %vreg21<def> = ADD %vreg20, %vreg17; GR32Bit:%vreg21,%vreg20,%vreg17
	  * %vreg22<def> = MUL %vreg21, %vreg10; GR32Bit:%vreg22,%vreg21,%vreg10
	  * %vreg5<def> = ADD %vreg9, %vreg22; GR32Bit:%vreg5,%vreg9,%vreg22
	  * %vreg2<def> = ADDI %zero, <ga:@redefine_out_eicas_egt>[TF=3]; GR32Bit:%vreg2
	  * %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
	  * %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
	  * %vreg0<def> = COPY %ra; GR32Bit:%vreg0
	  * SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
	  * FDELETE %t4, 0
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg23<def> = ADD %t5, %zero; GR32Bit:%vreg23
	  * %vreg25<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg25
	  * %vreg26<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg26
	  * %vreg27<def> = SRLI %vreg26, 12; GR32Bit:%vreg27,%vreg26
	  * %vreg28<def> = ADD %vreg25, %vreg27; GR32Bit:%vreg28,%vreg25,%vreg27
	  * %vreg29<def> = ADDI %zero, 12; GR32Bit:%vreg29
	  * %vreg30<def> = SRLI %t5, 22; GR32Bit:%vreg30
	  * %vreg31<def> = SRLI %t5, 12; GR32Bit:%vreg31
	  * %vreg32<def> = ANDI %vreg31, 15; GR32Bit:%vreg32,%vreg31
	  * %vreg33<def> = SRLI %t5, 6; GR32Bit:%vreg33
	  * %vreg34<def> = ANDI %vreg33, 63; GR32Bit:%vreg34,%vreg33
	  * %vreg35<def> = ADDI %zero, 832; GR32Bit:%vreg35
	  * %vreg36<def> = MUL %vreg30, %vreg35; GR32Bit:%vreg36,%vreg30,%vreg35
	  * %vreg37<def> = ADDI %zero, 52; GR32Bit:%vreg37
	  * %vreg38<def> = MUL %vreg32, %vreg37; GR32Bit:%vreg38,%vreg32,%vreg37
	  * %vreg39<def> = ADD %vreg38, %vreg34; GR32Bit:%vreg39,%vreg38,%vreg34
	  * %vreg40<def> = ADD %vreg39, %vreg36; GR32Bit:%vreg40,%vreg39,%vreg36
	  * %vreg41<def> = MUL %vreg40, %vreg29; GR32Bit:%vreg41,%vreg40,%vreg29
	  * %vreg24<def> = ADD %vreg28, %vreg41; GR32Bit:%vreg24,%vreg28,%vreg41
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg42<def> = ADD %t5, %zero; GR32Bit:%vreg42
	  * %vreg44<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg44
	  * %vreg45<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg45
	  * %vreg46<def> = SRLI %vreg45, 12; GR32Bit:%vreg46,%vreg45
	  * %vreg47<def> = ADD %vreg44, %vreg46; GR32Bit:%vreg47,%vreg44,%vreg46
	  * %vreg48<def> = ADDI %zero, 12; GR32Bit:%vreg48
	  * %vreg49<def> = SRLI %t5, 22; GR32Bit:%vreg49
	  * %vreg50<def> = SRLI %t5, 12; GR32Bit:%vreg50
	  * %vreg51<def> = ANDI %vreg50, 15; GR32Bit:%vreg51,%vreg50
	  * %vreg52<def> = SRLI %t5, 6; GR32Bit:%vreg52
	  * %vreg53<def> = ANDI %vreg52, 63; GR32Bit:%vreg53,%vreg52
	  * %vreg54<def> = ADDI %zero, 832; GR32Bit:%vreg54
	  * %vreg55<def> = MUL %vreg49, %vreg54; GR32Bit:%vreg55,%vreg49,%vreg54
	  * %vreg56<def> = ADDI %zero, 52; GR32Bit:%vreg56
	  * %vreg57<def> = MUL %vreg51, %vreg56; GR32Bit:%vreg57,%vreg51,%vreg56
	  * %vreg58<def> = ADD %vreg57, %vreg53; GR32Bit:%vreg58,%vreg57,%vreg53
	  * %vreg59<def> = ADD %vreg58, %vreg55; GR32Bit:%vreg59,%vreg58,%vreg55
	  * %vreg60<def> = MUL %vreg59, %vreg48; GR32Bit:%vreg60,%vreg59,%vreg48
	  * %vreg43<def> = ADD %vreg47, %vreg60; GR32Bit:%vreg43,%vreg47,%vreg60
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg61<def> = ADD %t5, %zero; GR32Bit:%vreg61
	  * %vreg63<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg63
	  * %vreg64<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg64
	  * %vreg65<def> = SRLI %vreg64, 12; GR32Bit:%vreg65,%vreg64
	  * %vreg66<def> = ADD %vreg63, %vreg65; GR32Bit:%vreg66,%vreg63,%vreg65
	  * %vreg67<def> = ADDI %zero, 12; GR32Bit:%vreg67
	  * %vreg68<def> = SRLI %t5, 22; GR32Bit:%vreg68
	  * %vreg69<def> = SRLI %t5, 12; GR32Bit:%vreg69
	  * %vreg70<def> = ANDI %vreg69, 15; GR32Bit:%vreg70,%vreg69
	  * %vreg71<def> = SRLI %t5, 6; GR32Bit:%vreg71
	  * %vreg72<def> = ANDI %vreg71, 63; GR32Bit:%vreg72,%vreg71
	  * %vreg73<def> = ADDI %zero, 832; GR32Bit:%vreg73
	  * %vreg74<def> = MUL %vreg68, %vreg73; GR32Bit:%vreg74,%vreg68,%vreg73
	  * %vreg75<def> = ADDI %zero, 52; GR32Bit:%vreg75
	  * %vreg76<def> = MUL %vreg70, %vreg75; GR32Bit:%vreg76,%vreg70,%vreg75
	  * %vreg77<def> = ADD %vreg76, %vreg72; GR32Bit:%vreg77,%vreg76,%vreg72
	  * %vreg78<def> = ADD %vreg77, %vreg74; GR32Bit:%vreg78,%vreg77,%vreg74
	  * %vreg79<def> = MUL %vreg78, %vreg67; GR32Bit:%vreg79,%vreg78,%vreg67
	  * %vreg62<def> = ADD %vreg66, %vreg79; GR32Bit:%vreg62,%vreg66,%vreg79
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
%physreg43,Patching the instructions that are supposed to use the physical registers r30 and r31
Computing live-in reg-units in ABI blocks.
0B	BB#0 ra#0
Created 0 new intervals.

*** Renumbered SlotIndexes 8-912 ***
********** INTERVALS **********
ra = [0B,872r:0)  0@0B-phi
zero = EMPTY
%vreg0 = [192r,200r:0)  0@192r
%vreg1 = [176r,184r:0)  0@176r
%vreg2 = [168r,184r:0)  0@168r
%vreg3 = [184r,200r:0)  0@184r
%vreg4 = [4r,4d:0)  0@4r
%vreg5 = [160r,160d:0)  0@160r
%vreg6 = [24r,48r:0)  0@24r
%vreg7 = [32r,40r:0)  0@32r
%vreg8 = [40r,48r:0)  0@40r
%vreg9 = [48r,160r:0)  0@48r
%vreg10 = [56r,152r:0)  0@56r
%vreg11 = [64r,112r:0)  0@64r
%vreg12 = [72r,80r:0)  0@72r
%vreg13 = [80r,128r:0)  0@80r
%vreg14 = [88r,96r:0)  0@88r
%vreg15 = [96r,136r:0)  0@96r
%vreg16 = [104r,112r:0)  0@104r
%vreg17 = [112r,144r:0)  0@112r
%vreg18 = [120r,128r:0)  0@120r
%vreg19 = [128r,136r:0)  0@128r
%vreg20 = [136r,144r:0)  0@136r
%vreg21 = [144r,152r:0)  0@144r
%vreg22 = [152r,160r:0)  0@152r
%vreg23 = [240r,240d:0)  0@240r
%vreg24 = [384r,384d:0)  0@384r
%vreg25 = [248r,272r:0)  0@248r
%vreg26 = [256r,264r:0)  0@256r
%vreg27 = [264r,272r:0)  0@264r
%vreg28 = [272r,384r:0)  0@272r
%vreg29 = [280r,376r:0)  0@280r
%vreg30 = [288r,336r:0)  0@288r
%vreg31 = [296r,304r:0)  0@296r
%vreg32 = [304r,352r:0)  0@304r
%vreg33 = [312r,320r:0)  0@312r
%vreg34 = [320r,360r:0)  0@320r
%vreg35 = [328r,336r:0)  0@328r
%vreg36 = [336r,368r:0)  0@336r
%vreg37 = [344r,352r:0)  0@344r
%vreg38 = [352r,360r:0)  0@352r
%vreg39 = [360r,368r:0)  0@360r
%vreg40 = [368r,376r:0)  0@368r
%vreg41 = [376r,384r:0)  0@376r
%vreg42 = [416r,416d:0)  0@416r
%vreg43 = [560r,560d:0)  0@560r
%vreg44 = [424r,448r:0)  0@424r
%vreg45 = [432r,440r:0)  0@432r
%vreg46 = [440r,448r:0)  0@440r
%vreg47 = [448r,560r:0)  0@448r
%vreg48 = [456r,552r:0)  0@456r
%vreg49 = [464r,512r:0)  0@464r
%vreg50 = [472r,480r:0)  0@472r
%vreg51 = [480r,528r:0)  0@480r
%vreg52 = [488r,496r:0)  0@488r
%vreg53 = [496r,536r:0)  0@496r
%vreg54 = [504r,512r:0)  0@504r
%vreg55 = [512r,544r:0)  0@512r
%vreg56 = [520r,528r:0)  0@520r
%vreg57 = [528r,536r:0)  0@528r
%vreg58 = [536r,544r:0)  0@536r
%vreg59 = [544r,552r:0)  0@544r
%vreg60 = [552r,560r:0)  0@552r
%vreg61 = [592r,592d:0)  0@592r
%vreg62 = [736r,736d:0)  0@736r
%vreg63 = [600r,624r:0)  0@600r
%vreg64 = [608r,616r:0)  0@608r
%vreg65 = [616r,624r:0)  0@616r
%vreg66 = [624r,736r:0)  0@624r
%vreg67 = [632r,728r:0)  0@632r
%vreg68 = [640r,688r:0)  0@640r
%vreg69 = [648r,656r:0)  0@648r
%vreg70 = [656r,704r:0)  0@656r
%vreg71 = [664r,672r:0)  0@664r
%vreg72 = [672r,712r:0)  0@672r
%vreg73 = [680r,688r:0)  0@680r
%vreg74 = [688r,720r:0)  0@688r
%vreg75 = [696r,704r:0)  0@696r
%vreg76 = [704r,712r:0)  0@704r
%vreg77 = [712r,720r:0)  0@712r
%vreg78 = [720r,728r:0)  0@720r
%vreg79 = [728r,736r:0)  0@728r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function redefine_start2: Post SSA
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %redefine_start2.newName01
	    Live Ins: %ra
4B		%t4<def> = ADD %t5, %zero
4B		  * %vreg6<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg6
4B		  * %vreg7<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg7
4B		  * %vreg8<def> = SRLI %vreg7, 12; GR32Bit:%vreg8,%vreg7
4B		  * %vreg9<def> = ADD %vreg6, %vreg8; GR32Bit:%vreg9,%vreg6,%vreg8
4B		  * %vreg10<def> = ADDI %zero, 12; GR32Bit:%vreg10
4B		  * %vreg11<def> = SRLI %t5, 22; GR32Bit:%vreg11
4B		  * %vreg12<def> = SRLI %t5, 12; GR32Bit:%vreg12
4B		  * %vreg13<def> = ANDI %vreg12, 15; GR32Bit:%vreg13,%vreg12
4B		  * %vreg14<def> = SRLI %t5, 6; GR32Bit:%vreg14
4B		  * %vreg15<def> = ANDI %vreg14, 63; GR32Bit:%vreg15,%vreg14
4B		  * %vreg16<def> = ADDI %zero, 832; GR32Bit:%vreg16
4B		  * %vreg17<def> = MUL %vreg11, %vreg16; GR32Bit:%vreg17,%vreg11,%vreg16
4B		  * %vreg18<def> = ADDI %zero, 52; GR32Bit:%vreg18
4B		  * %vreg19<def> = MUL %vreg13, %vreg18; GR32Bit:%vreg19,%vreg13,%vreg18
4B		  * %vreg20<def> = ADD %vreg19, %vreg15; GR32Bit:%vreg20,%vreg19,%vreg15
4B		  * %vreg21<def> = ADD %vreg20, %vreg17; GR32Bit:%vreg21,%vreg20,%vreg17
4B		  * %vreg22<def> = MUL %vreg21, %vreg10; GR32Bit:%vreg22,%vreg21,%vreg10
4B		  * %t5<def> = ADD %vreg9, %vreg22; GR32Bit:%vreg9,%vreg22
4B		  * %vreg2<def> = LUI <MCSym="%lo("ga#256")">; GR32Bit:%vreg2
4B		  * SRLI %vreg2, %vreg2, 12; GR32Bit:%vreg2
4B		  * %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
4B		  * %vreg3<def> = ADD %vreg2, %vreg1; GR32Bit:%vreg3,%vreg2,%vreg1
4B		  * %vreg0<def> = COPY %ra; GR32Bit:%vreg0
4B		  * SW %vreg0, %vreg3, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
4B		  * FDELETE %t4, 0
4B		  * END 0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
240B		%t4<def> = ADD %t5, %zero
240B		  * %vreg25<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg25
240B		  * %vreg26<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg26
240B		  * %vreg27<def> = SRLI %vreg26, 12; GR32Bit:%vreg27,%vreg26
240B		  * %vreg28<def> = ADD %vreg25, %vreg27; GR32Bit:%vreg28,%vreg25,%vreg27
240B		  * %vreg29<def> = ADDI %zero, 12; GR32Bit:%vreg29
240B		  * %vreg30<def> = SRLI %t5, 22; GR32Bit:%vreg30
240B		  * %vreg31<def> = SRLI %t5, 12; GR32Bit:%vreg31
240B		  * %vreg32<def> = ANDI %vreg31, 15; GR32Bit:%vreg32,%vreg31
240B		  * %vreg33<def> = SRLI %t5, 6; GR32Bit:%vreg33
240B		  * %vreg34<def> = ANDI %vreg33, 63; GR32Bit:%vreg34,%vreg33
240B		  * %vreg35<def> = ADDI %zero, 832; GR32Bit:%vreg35
240B		  * %vreg36<def> = MUL %vreg30, %vreg35; GR32Bit:%vreg36,%vreg30,%vreg35
240B		  * %vreg37<def> = ADDI %zero, 52; GR32Bit:%vreg37
240B		  * %vreg38<def> = MUL %vreg32, %vreg37; GR32Bit:%vreg38,%vreg32,%vreg37
240B		  * %vreg39<def> = ADD %vreg38, %vreg34; GR32Bit:%vreg39,%vreg38,%vreg34
240B		  * %vreg40<def> = ADD %vreg39, %vreg36; GR32Bit:%vreg40,%vreg39,%vreg36
240B		  * %vreg41<def> = MUL %vreg40, %vreg29; GR32Bit:%vreg41,%vreg40,%vreg29
240B		  * %t5<def> = ADD %vreg28, %vreg41; GR32Bit:%vreg28,%vreg41
240B		  * END 0
240B		  * %zero<def> = ADDI %zero, 0
240B		  * %zero<def> = ADDI %zero, 0
416B		%t4<def> = ADD %t5, %zero
416B		  * %vreg44<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg44
416B		  * %vreg45<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg45
416B		  * %vreg46<def> = SRLI %vreg45, 12; GR32Bit:%vreg46,%vreg45
416B		  * %vreg47<def> = ADD %vreg44, %vreg46; GR32Bit:%vreg47,%vreg44,%vreg46
416B		  * %vreg48<def> = ADDI %zero, 12; GR32Bit:%vreg48
416B		  * %vreg49<def> = SRLI %t5, 22; GR32Bit:%vreg49
416B		  * %vreg50<def> = SRLI %t5, 12; GR32Bit:%vreg50
416B		  * %vreg51<def> = ANDI %vreg50, 15; GR32Bit:%vreg51,%vreg50
416B		  * %vreg52<def> = SRLI %t5, 6; GR32Bit:%vreg52
416B		  * %vreg53<def> = ANDI %vreg52, 63; GR32Bit:%vreg53,%vreg52
416B		  * %vreg54<def> = ADDI %zero, 832; GR32Bit:%vreg54
416B		  * %vreg55<def> = MUL %vreg49, %vreg54; GR32Bit:%vreg55,%vreg49,%vreg54
416B		  * %vreg56<def> = ADDI %zero, 52; GR32Bit:%vreg56
416B		  * %vreg57<def> = MUL %vreg51, %vreg56; GR32Bit:%vreg57,%vreg51,%vreg56
416B		  * %vreg58<def> = ADD %vreg57, %vreg53; GR32Bit:%vreg58,%vreg57,%vreg53
416B		  * %vreg59<def> = ADD %vreg58, %vreg55; GR32Bit:%vreg59,%vreg58,%vreg55
416B		  * %vreg60<def> = MUL %vreg59, %vreg48; GR32Bit:%vreg60,%vreg59,%vreg48
416B		  * %t5<def> = ADD %vreg47, %vreg60; GR32Bit:%vreg47,%vreg60
416B		  * END 0
416B		  * %zero<def> = ADDI %zero, 0
416B		  * %zero<def> = ADDI %zero, 0
592B		%t4<def> = ADD %t5, %zero
592B		  * %vreg63<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg63
592B		  * %vreg64<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg64
592B		  * %vreg65<def> = SRLI %vreg64, 12; GR32Bit:%vreg65,%vreg64
592B		  * %vreg66<def> = ADD %vreg63, %vreg65; GR32Bit:%vreg66,%vreg63,%vreg65
592B		  * %vreg67<def> = ADDI %zero, 12; GR32Bit:%vreg67
592B		  * %vreg68<def> = SRLI %t5, 22; GR32Bit:%vreg68
592B		  * %vreg69<def> = SRLI %t5, 12; GR32Bit:%vreg69
592B		  * %vreg70<def> = ANDI %vreg69, 15; GR32Bit:%vreg70,%vreg69
592B		  * %vreg71<def> = SRLI %t5, 6; GR32Bit:%vreg71
592B		  * %vreg72<def> = ANDI %vreg71, 63; GR32Bit:%vreg72,%vreg71
592B		  * %vreg73<def> = ADDI %zero, 832; GR32Bit:%vreg73
592B		  * %vreg74<def> = MUL %vreg68, %vreg73; GR32Bit:%vreg74,%vreg68,%vreg73
592B		  * %vreg75<def> = ADDI %zero, 52; GR32Bit:%vreg75
592B		  * %vreg76<def> = MUL %vreg70, %vreg75; GR32Bit:%vreg76,%vreg70,%vreg75
592B		  * %vreg77<def> = ADD %vreg76, %vreg72; GR32Bit:%vreg77,%vreg76,%vreg72
592B		  * %vreg78<def> = ADD %vreg77, %vreg74; GR32Bit:%vreg78,%vreg77,%vreg74
592B		  * %vreg79<def> = MUL %vreg78, %vreg67; GR32Bit:%vreg79,%vreg78,%vreg67
592B		  * %t5<def> = ADD %vreg66, %vreg79; GR32Bit:%vreg66,%vreg79
592B		  * END 0
592B		  * %zero<def> = ADDI %zero, 0
592B		  * %zero<def> = ADDI %zero, 0

# End machine code for function redefine_start2.

********** COMPUTING LIVE DEBUG VARIABLES: redefine_start2 **********
********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: redefine_start2
********** GREEDY REGISTER ALLOCATION **********
********** Function: redefine_start2
Replacing 43 with 43 for instruction%vreg0<def> = COPY %ra; GR32Bit:%vreg0

selectOrSplit GR32Bit:%vreg0 [192r,200r:0)  0@192r
hints: %ra
reg 2147483648 that was live-in gets phys reg:43 instead of phys reg:43
assigning %vreg0 to %ra: ra

selectOrSplit GR32Bit:%vreg9 [48r,160r:0)  0@48r
assigning %vreg9 to %t0: t0

selectOrSplit GR32Bit:%vreg28 [272r,384r:0)  0@272r
assigning %vreg28 to %t0: t0

selectOrSplit GR32Bit:%vreg47 [448r,560r:0)  0@448r
assigning %vreg47 to %t0: t0

selectOrSplit GR32Bit:%vreg66 [624r,736r:0)  0@624r
assigning %vreg66 to %t0: t0

selectOrSplit GR32Bit:%vreg10 [56r,152r:0)  0@56r
assigning %vreg10 to %t1: t1

selectOrSplit GR32Bit:%vreg29 [280r,376r:0)  0@280r
assigning %vreg29 to %t1: t1

selectOrSplit GR32Bit:%vreg48 [456r,552r:0)  0@456r
assigning %vreg48 to %t1: t1

selectOrSplit GR32Bit:%vreg67 [632r,728r:0)  0@632r
assigning %vreg67 to %t1: t1

selectOrSplit GR32Bit:%vreg11 [64r,112r:0)  0@64r
assigning %vreg11 to %t2: t2

selectOrSplit GR32Bit:%vreg13 [80r,128r:0)  0@80r
assigning %vreg13 to %fp: fp

selectOrSplit GR32Bit:%vreg30 [288r,336r:0)  0@288r
assigning %vreg30 to %t2: t2

selectOrSplit GR32Bit:%vreg32 [304r,352r:0)  0@304r
assigning %vreg32 to %fp: fp

selectOrSplit GR32Bit:%vreg49 [464r,512r:0)  0@464r
assigning %vreg49 to %t2: t2

selectOrSplit GR32Bit:%vreg51 [480r,528r:0)  0@480r
assigning %vreg51 to %fp: fp

selectOrSplit GR32Bit:%vreg68 [640r,688r:0)  0@640r
assigning %vreg68 to %t2: t2

selectOrSplit GR32Bit:%vreg70 [656r,704r:0)  0@656r
assigning %vreg70 to %fp: fp

selectOrSplit GR32Bit:%vreg15 [96r,136r:0)  0@96r
assigning %vreg15 to %a0: a0

selectOrSplit GR32Bit:%vreg34 [320r,360r:0)  0@320r
assigning %vreg34 to %a0: a0

selectOrSplit GR32Bit:%vreg53 [496r,536r:0)  0@496r
assigning %vreg53 to %a0: a0

selectOrSplit GR32Bit:%vreg72 [672r,712r:0)  0@672r
assigning %vreg72 to %a0: a0

selectOrSplit GR32Bit:%vreg17 [112r,144r:0)  0@112r
assigning %vreg17 to %t2: t2

selectOrSplit GR32Bit:%vreg36 [336r,368r:0)  0@336r
assigning %vreg36 to %t2: t2

selectOrSplit GR32Bit:%vreg55 [512r,544r:0)  0@512r
assigning %vreg55 to %t2: t2

selectOrSplit GR32Bit:%vreg74 [688r,720r:0)  0@688r
assigning %vreg74 to %t2: t2

selectOrSplit GR32Bit:%vreg6 [24r,48r:0)  0@24r
assigning %vreg6 to %t0: t0

selectOrSplit GR32Bit:%vreg25 [248r,272r:0)  0@248r
assigning %vreg25 to %t0: t0

selectOrSplit GR32Bit:%vreg44 [424r,448r:0)  0@424r
assigning %vreg44 to %t0: t0

selectOrSplit GR32Bit:%vreg63 [600r,624r:0)  0@600r
assigning %vreg63 to %t0: t0

selectOrSplit GR32Bit:%vreg2 [168r,184r:0)  0@168r
assigning %vreg2 to %t0: t0

selectOrSplit GR32Bit:%vreg3 [184r,200r:0)  0@184r
assigning %vreg3 to %t0: t0

selectOrSplit GR32Bit:%vreg1 [176r,184r:0)  0@176r
assigning %vreg1 to %t1: t1

selectOrSplit GR32Bit:%vreg7 [32r,40r:0)  0@32r
assigning %vreg7 to %t1: t1

selectOrSplit GR32Bit:%vreg8 [40r,48r:0)  0@40r
assigning %vreg8 to %t1: t1

selectOrSplit GR32Bit:%vreg12 [72r,80r:0)  0@72r
assigning %vreg12 to %fp: fp

selectOrSplit GR32Bit:%vreg14 [88r,96r:0)  0@88r
assigning %vreg14 to %a0: a0

selectOrSplit GR32Bit:%vreg16 [104r,112r:0)  0@104r
assigning %vreg16 to %a1: a1

selectOrSplit GR32Bit:%vreg18 [120r,128r:0)  0@120r
assigning %vreg18 to %a1: a1

selectOrSplit GR32Bit:%vreg19 [128r,136r:0)  0@128r
assigning %vreg19 to %fp: fp

selectOrSplit GR32Bit:%vreg20 [136r,144r:0)  0@136r
assigning %vreg20 to %fp: fp

selectOrSplit GR32Bit:%vreg21 [144r,152r:0)  0@144r
assigning %vreg21 to %t2: t2

selectOrSplit GR32Bit:%vreg22 [152r,160r:0)  0@152r
assigning %vreg22 to %t1: t1

selectOrSplit GR32Bit:%vreg26 [256r,264r:0)  0@256r
assigning %vreg26 to %t1: t1

selectOrSplit GR32Bit:%vreg27 [264r,272r:0)  0@264r
assigning %vreg27 to %t1: t1

selectOrSplit GR32Bit:%vreg31 [296r,304r:0)  0@296r
assigning %vreg31 to %fp: fp

selectOrSplit GR32Bit:%vreg33 [312r,320r:0)  0@312r
assigning %vreg33 to %a0: a0

selectOrSplit GR32Bit:%vreg35 [328r,336r:0)  0@328r
assigning %vreg35 to %a1: a1

selectOrSplit GR32Bit:%vreg37 [344r,352r:0)  0@344r
assigning %vreg37 to %a1: a1

selectOrSplit GR32Bit:%vreg38 [352r,360r:0)  0@352r
assigning %vreg38 to %fp: fp

selectOrSplit GR32Bit:%vreg39 [360r,368r:0)  0@360r
assigning %vreg39 to %fp: fp

selectOrSplit GR32Bit:%vreg40 [368r,376r:0)  0@368r
assigning %vreg40 to %t2: t2

selectOrSplit GR32Bit:%vreg41 [376r,384r:0)  0@376r
assigning %vreg41 to %t1: t1

selectOrSplit GR32Bit:%vreg45 [432r,440r:0)  0@432r
assigning %vreg45 to %t1: t1

selectOrSplit GR32Bit:%vreg46 [440r,448r:0)  0@440r
assigning %vreg46 to %t1: t1

selectOrSplit GR32Bit:%vreg50 [472r,480r:0)  0@472r
assigning %vreg50 to %fp: fp

selectOrSplit GR32Bit:%vreg52 [488r,496r:0)  0@488r
assigning %vreg52 to %a0: a0

selectOrSplit GR32Bit:%vreg54 [504r,512r:0)  0@504r
assigning %vreg54 to %a1: a1

selectOrSplit GR32Bit:%vreg56 [520r,528r:0)  0@520r
assigning %vreg56 to %a1: a1

selectOrSplit GR32Bit:%vreg57 [528r,536r:0)  0@528r
assigning %vreg57 to %fp: fp

selectOrSplit GR32Bit:%vreg58 [536r,544r:0)  0@536r
assigning %vreg58 to %fp: fp

selectOrSplit GR32Bit:%vreg59 [544r,552r:0)  0@544r
assigning %vreg59 to %t2: t2

selectOrSplit GR32Bit:%vreg60 [552r,560r:0)  0@552r
assigning %vreg60 to %t1: t1

selectOrSplit GR32Bit:%vreg64 [608r,616r:0)  0@608r
assigning %vreg64 to %t1: t1

selectOrSplit GR32Bit:%vreg65 [616r,624r:0)  0@616r
assigning %vreg65 to %t1: t1

selectOrSplit GR32Bit:%vreg69 [648r,656r:0)  0@648r
assigning %vreg69 to %fp: fp

selectOrSplit GR32Bit:%vreg71 [664r,672r:0)  0@664r
assigning %vreg71 to %a0: a0

selectOrSplit GR32Bit:%vreg73 [680r,688r:0)  0@680r
assigning %vreg73 to %a1: a1

selectOrSplit GR32Bit:%vreg75 [696r,704r:0)  0@696r
assigning %vreg75 to %a1: a1

selectOrSplit GR32Bit:%vreg76 [704r,712r:0)  0@704r
assigning %vreg76 to %fp: fp

selectOrSplit GR32Bit:%vreg77 [712r,720r:0)  0@712r
assigning %vreg77 to %fp: fp

selectOrSplit GR32Bit:%vreg78 [720r,728r:0)  0@720r
assigning %vreg78 to %t2: t2

selectOrSplit GR32Bit:%vreg79 [728r,736r:0)  0@728r
assigning %vreg79 to %t1: t1
********** REWRITE VIRTUAL REGISTERS **********
********** Function: redefine_start2
********** REGISTER MAP **********
[%vreg0 -> %ra] GR32Bit
[%vreg1 -> %t1] GR32Bit
[%vreg2 -> %t0] GR32Bit
[%vreg3 -> %t0] GR32Bit
[%vreg6 -> %t0] GR32Bit
[%vreg7 -> %t1] GR32Bit
[%vreg8 -> %t1] GR32Bit
[%vreg9 -> %t0] GR32Bit
[%vreg10 -> %t1] GR32Bit
[%vreg11 -> %t2] GR32Bit
[%vreg12 -> %fp] GR32Bit
[%vreg13 -> %fp] GR32Bit
[%vreg14 -> %a0] GR32Bit
[%vreg15 -> %a0] GR32Bit
[%vreg16 -> %a1] GR32Bit
[%vreg17 -> %t2] GR32Bit
[%vreg18 -> %a1] GR32Bit
[%vreg19 -> %fp] GR32Bit
[%vreg20 -> %fp] GR32Bit
[%vreg21 -> %t2] GR32Bit
[%vreg22 -> %t1] GR32Bit
[%vreg25 -> %t0] GR32Bit
[%vreg26 -> %t1] GR32Bit
[%vreg27 -> %t1] GR32Bit
[%vreg28 -> %t0] GR32Bit
[%vreg29 -> %t1] GR32Bit
[%vreg30 -> %t2] GR32Bit
[%vreg31 -> %fp] GR32Bit
[%vreg32 -> %fp] GR32Bit
[%vreg33 -> %a0] GR32Bit
[%vreg34 -> %a0] GR32Bit
[%vreg35 -> %a1] GR32Bit
[%vreg36 -> %t2] GR32Bit
[%vreg37 -> %a1] GR32Bit
[%vreg38 -> %fp] GR32Bit
[%vreg39 -> %fp] GR32Bit
[%vreg40 -> %t2] GR32Bit
[%vreg41 -> %t1] GR32Bit
[%vreg44 -> %t0] GR32Bit
[%vreg45 -> %t1] GR32Bit
[%vreg46 -> %t1] GR32Bit
[%vreg47 -> %t0] GR32Bit
[%vreg48 -> %t1] GR32Bit
[%vreg49 -> %t2] GR32Bit
[%vreg50 -> %fp] GR32Bit
[%vreg51 -> %fp] GR32Bit
[%vreg52 -> %a0] GR32Bit
[%vreg53 -> %a0] GR32Bit
[%vreg54 -> %a1] GR32Bit
[%vreg55 -> %t2] GR32Bit
[%vreg56 -> %a1] GR32Bit
[%vreg57 -> %fp] GR32Bit
[%vreg58 -> %fp] GR32Bit
[%vreg59 -> %t2] GR32Bit
[%vreg60 -> %t1] GR32Bit
[%vreg63 -> %t0] GR32Bit
[%vreg64 -> %t1] GR32Bit
[%vreg65 -> %t1] GR32Bit
[%vreg66 -> %t0] GR32Bit
[%vreg67 -> %t1] GR32Bit
[%vreg68 -> %t2] GR32Bit
[%vreg69 -> %fp] GR32Bit
[%vreg70 -> %fp] GR32Bit
[%vreg71 -> %a0] GR32Bit
[%vreg72 -> %a0] GR32Bit
[%vreg73 -> %a1] GR32Bit
[%vreg74 -> %t2] GR32Bit
[%vreg75 -> %a1] GR32Bit
[%vreg76 -> %fp] GR32Bit
[%vreg77 -> %fp] GR32Bit
[%vreg78 -> %t2] GR32Bit
[%vreg79 -> %t1] GR32Bit

0B	BB#0: derived from LLVM BB %redefine_start2.newName01
	    Live Ins: %ra
4B		%t4<def> = ADD %t5, %zero
4B		  * %vreg6<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg6
4B		  * %vreg7<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg7
4B		  * %vreg8<def> = SRLI %vreg7<kill>, 12; GR32Bit:%vreg8,%vreg7
4B		  * %vreg9<def> = ADD %vreg6<kill>, %vreg8<kill>; GR32Bit:%vreg9,%vreg6,%vreg8
4B		  * %vreg10<def> = ADDI %zero, 12; GR32Bit:%vreg10
4B		  * %vreg11<def> = SRLI %t5, 22; GR32Bit:%vreg11
4B		  * %vreg12<def> = SRLI %t5, 12; GR32Bit:%vreg12
4B		  * %vreg13<def> = ANDI %vreg12<kill>, 15; GR32Bit:%vreg13,%vreg12
4B		  * %vreg14<def> = SRLI %t5, 6; GR32Bit:%vreg14
4B		  * %vreg15<def> = ANDI %vreg14<kill>, 63; GR32Bit:%vreg15,%vreg14
4B		  * %vreg16<def> = ADDI %zero, 832; GR32Bit:%vreg16
4B		  * %vreg17<def> = MUL %vreg11<kill>, %vreg16<kill>; GR32Bit:%vreg17,%vreg11,%vreg16
4B		  * %vreg18<def> = ADDI %zero, 52; GR32Bit:%vreg18
4B		  * %vreg19<def> = MUL %vreg13<kill>, %vreg18<kill>; GR32Bit:%vreg19,%vreg13,%vreg18
4B		  * %vreg20<def> = ADD %vreg19<kill>, %vreg15<kill>; GR32Bit:%vreg20,%vreg19,%vreg15
4B		  * %vreg21<def> = ADD %vreg20<kill>, %vreg17<kill>; GR32Bit:%vreg21,%vreg20,%vreg17
4B		  * %vreg22<def> = MUL %vreg21<kill>, %vreg10<kill>; GR32Bit:%vreg22,%vreg21,%vreg10
4B		  * %t5<def> = ADD %vreg9<kill>, %vreg22<kill>; GR32Bit:%vreg9,%vreg22
4B		  * %vreg2<def> = LUI <MCSym="%lo("ga#256")">; GR32Bit:%vreg2
4B		  * SRLI %vreg2, %vreg2, 12; GR32Bit:%vreg2
4B		  * %vreg1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]; GR32Bit:%vreg1
4B		  * %vreg3<def> = ADD %vreg2<kill>, %vreg1<kill>; GR32Bit:%vreg3,%vreg2,%vreg1
4B		  * %vreg0<def> = COPY %ra; GR32Bit:%vreg0
4B		  * SW %vreg0, %vreg3<kill>, 0; mem:ST4[@redefine_out_eicas_egt] GR32Bit:%vreg0,%vreg3
4B		  * FDELETE %t4, 0
4B		  * END 0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
240B		%t4<def> = ADD %t5, %zero
240B		  * %vreg25<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg25
240B		  * %vreg26<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg26
240B		  * %vreg27<def> = SRLI %vreg26<kill>, 12; GR32Bit:%vreg27,%vreg26
240B		  * %vreg28<def> = ADD %vreg25<kill>, %vreg27<kill>; GR32Bit:%vreg28,%vreg25,%vreg27
240B		  * %vreg29<def> = ADDI %zero, 12; GR32Bit:%vreg29
240B		  * %vreg30<def> = SRLI %t5, 22; GR32Bit:%vreg30
240B		  * %vreg31<def> = SRLI %t5, 12; GR32Bit:%vreg31
240B		  * %vreg32<def> = ANDI %vreg31<kill>, 15; GR32Bit:%vreg32,%vreg31
240B		  * %vreg33<def> = SRLI %t5, 6; GR32Bit:%vreg33
240B		  * %vreg34<def> = ANDI %vreg33<kill>, 63; GR32Bit:%vreg34,%vreg33
240B		  * %vreg35<def> = ADDI %zero, 832; GR32Bit:%vreg35
240B		  * %vreg36<def> = MUL %vreg30<kill>, %vreg35<kill>; GR32Bit:%vreg36,%vreg30,%vreg35
240B		  * %vreg37<def> = ADDI %zero, 52; GR32Bit:%vreg37
240B		  * %vreg38<def> = MUL %vreg32<kill>, %vreg37<kill>; GR32Bit:%vreg38,%vreg32,%vreg37
240B		  * %vreg39<def> = ADD %vreg38<kill>, %vreg34<kill>; GR32Bit:%vreg39,%vreg38,%vreg34
240B		  * %vreg40<def> = ADD %vreg39<kill>, %vreg36<kill>; GR32Bit:%vreg40,%vreg39,%vreg36
240B		  * %vreg41<def> = MUL %vreg40<kill>, %vreg29<kill>; GR32Bit:%vreg41,%vreg40,%vreg29
240B		  * %t5<def> = ADD %vreg28<kill>, %vreg41<kill>; GR32Bit:%vreg28,%vreg41
240B		  * END 0
240B		  * %zero<def> = ADDI %zero, 0
240B		  * %zero<def> = ADDI %zero, 0
416B		%t4<def> = ADD %t5, %zero
416B		  * %vreg44<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg44
416B		  * %vreg45<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg45
416B		  * %vreg46<def> = SRLI %vreg45<kill>, 12; GR32Bit:%vreg46,%vreg45
416B		  * %vreg47<def> = ADD %vreg44<kill>, %vreg46<kill>; GR32Bit:%vreg47,%vreg44,%vreg46
416B		  * %vreg48<def> = ADDI %zero, 12; GR32Bit:%vreg48
416B		  * %vreg49<def> = SRLI %t5, 22; GR32Bit:%vreg49
416B		  * %vreg50<def> = SRLI %t5, 12; GR32Bit:%vreg50
416B		  * %vreg51<def> = ANDI %vreg50<kill>, 15; GR32Bit:%vreg51,%vreg50
416B		  * %vreg52<def> = SRLI %t5, 6; GR32Bit:%vreg52
416B		  * %vreg53<def> = ANDI %vreg52<kill>, 63; GR32Bit:%vreg53,%vreg52
416B		  * %vreg54<def> = ADDI %zero, 832; GR32Bit:%vreg54
416B		  * %vreg55<def> = MUL %vreg49<kill>, %vreg54<kill>; GR32Bit:%vreg55,%vreg49,%vreg54
416B		  * %vreg56<def> = ADDI %zero, 52; GR32Bit:%vreg56
416B		  * %vreg57<def> = MUL %vreg51<kill>, %vreg56<kill>; GR32Bit:%vreg57,%vreg51,%vreg56
416B		  * %vreg58<def> = ADD %vreg57<kill>, %vreg53<kill>; GR32Bit:%vreg58,%vreg57,%vreg53
416B		  * %vreg59<def> = ADD %vreg58<kill>, %vreg55<kill>; GR32Bit:%vreg59,%vreg58,%vreg55
416B		  * %vreg60<def> = MUL %vreg59<kill>, %vreg48<kill>; GR32Bit:%vreg60,%vreg59,%vreg48
416B		  * %t5<def> = ADD %vreg47<kill>, %vreg60<kill>; GR32Bit:%vreg47,%vreg60
416B		  * END 0
416B		  * %zero<def> = ADDI %zero, 0
416B		  * %zero<def> = ADDI %zero, 0
592B		%t4<def> = ADD %t5, %zero
592B		  * %vreg63<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg63
592B		  * %vreg64<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg64
592B		  * %vreg65<def> = SRLI %vreg64<kill>, 12; GR32Bit:%vreg65,%vreg64
592B		  * %vreg66<def> = ADD %vreg63<kill>, %vreg65<kill>; GR32Bit:%vreg66,%vreg63,%vreg65
592B		  * %vreg67<def> = ADDI %zero, 12; GR32Bit:%vreg67
592B		  * %vreg68<def> = SRLI %t5, 22; GR32Bit:%vreg68
592B		  * %vreg69<def> = SRLI %t5, 12; GR32Bit:%vreg69
592B		  * %vreg70<def> = ANDI %vreg69<kill>, 15; GR32Bit:%vreg70,%vreg69
592B		  * %vreg71<def> = SRLI %t5, 6; GR32Bit:%vreg71
592B		  * %vreg72<def> = ANDI %vreg71<kill>, 63; GR32Bit:%vreg72,%vreg71
592B		  * %vreg73<def> = ADDI %zero, 832; GR32Bit:%vreg73
592B		  * %vreg74<def> = MUL %vreg68<kill>, %vreg73<kill>; GR32Bit:%vreg74,%vreg68,%vreg73
592B		  * %vreg75<def> = ADDI %zero, 52; GR32Bit:%vreg75
592B		  * %vreg76<def> = MUL %vreg70<kill>, %vreg75<kill>; GR32Bit:%vreg76,%vreg70,%vreg75
592B		  * %vreg77<def> = ADD %vreg76<kill>, %vreg72<kill>; GR32Bit:%vreg77,%vreg76,%vreg72
592B		  * %vreg78<def> = ADD %vreg77<kill>, %vreg74<kill>; GR32Bit:%vreg78,%vreg77,%vreg74
592B		  * %vreg79<def> = MUL %vreg78<kill>, %vreg67<kill>; GR32Bit:%vreg79,%vreg78,%vreg67
592B		  * %t5<def> = ADD %vreg66<kill>, %vreg79<kill>; GR32Bit:%vreg66,%vreg79
592B		  * END 0
592B		  * %zero<def> = ADDI %zero, 0
592B		  * %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> %t0<def> = LUI <MCSym="%lo("ga#256")">
> SRLI %t0, %t0, 12
> %t1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %ra<def> = COPY %ra
Deleting identity copy.
> SW %ra, %t0<kill>, 0; mem:ST4[@redefine_out_eicas_egt]
> FDELETE %t4, 0
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
********** EMITTING LIVE DEBUG VARIABLES **********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: redefine_start2
current state of mf:# Machine code for function redefine_start2: Post SSA
Function Live Ins: %ra in %vreg0

BB#0: derived from LLVM BB %redefine_start2.newName01
    Live Ins: %ra
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * %t0<def> = LUI <MCSym="%lo("ga#256")">
	  * SRLI %t0, %t0, 12
	  * %t1<def> = LUI <ga:@redefine_out_eicas_egt>[TF=2]
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * SW %ra, %t0<kill>, 0; mem:ST4[@redefine_out_eicas_egt]
	  * FDELETE %t4, 0
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0

# End machine code for function redefine_start2.

MERGING MOSTLY EMPTY BLOCKS - BEFORE:

eicas_calculator3.if.end:                         ; preds = %eicas_calculator3.if.else3, %eicas_calculator3.if.then2
  br label %eicas_calculator3.if.end4

eicas_calculator3.if.end4:                        ; preds = %eicas_calculator3.if.end, %eicas_calculator3.if.then
  %9 = load i32* %3, align 4
  store i32 %9, i32* %1, align 4
  br label %eicas_calculator3.return
AFTER:

eicas_calculator3.if.end4:                        ; preds = %eicas_calculator3.if.then2, %eicas_calculator3.if.else3, %eicas_calculator3.if.then
  %9 = load i32* %3, align 4
  store i32 %9, i32* %1, align 4
  br label %eicas_calculator3.return



CGP: Found      local addrmode: [Base:%2]
CGP: Found      local addrmode: [Base:%2]
CGP: Found      local addrmode: [Base:%2]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%2]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%1]
To merge:

eicas_calculator3.if.end4:                        ; preds = %eicas_calculator3.if.then2, %eicas_calculator3.if.else3, %eicas_calculator3.if.then
  %9 = load i32* %3, align 4
  store i32 %9, i32* %1, align 4
  br label %eicas_calculator3.return



Computing probabilities for eicas_calculator3.return
Computing probabilities for eicas_calculator3.if.then
Computing probabilities for eicas_calculator3.if.then2
Computing probabilities for eicas_calculator3.if.else3
Computing probabilities for eicas_calculator3.if.else
Computing probabilities for eicas_calculator3.entry
set edge eicas_calculator3.entry -> 1 successor weight to 20
set edge eicas_calculator3.entry -> 0 successor weight to 12



=== eicas_calculator3
store visit is after?  store i32 %0, i32* %2, align 4
I was here to add   %2 = alloca i32, align 4
whats in dag after store?SelectionDAG has 7 nodes:
  0x2891968: ch = EntryToken [ORD=4]

  0x28af390: i32 = Constant<0>

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af290: i32 = Register %vreg0 [ORD=4]

    0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

    0x28af090: i32 = FrameIndex<1> [ORD=4]

    0x28af490: i32 = undef [ORD=4]

  0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4]


visiting load instruction   %4 = load i32* %2, align 4
with I type i32and sd value :0x28af090: i32 = FrameIndex<1>
new load?0x28af790: i32,ch = load 0x28af590, 0x28af090, 0x28af490<LD4[%2]>
dag after load is dealt with?SelectionDAG has 8 nodes:
  0x2891968: ch = EntryToken [ORD=4]

  0x28af090: i32 = FrameIndex<1> [ORD=4]

  0x28af390: i32 = Constant<0>

  0x28af490: i32 = undef [ORD=4]

      0x2891968: <multiple use>
        0x2891968: <multiple use>
        0x28af290: i32 = Register %vreg0 [ORD=4]

      0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

      0x28af090: <multiple use>
      0x28af490: <multiple use>
    0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4]

    0x28af090: <multiple use>
    0x28af490: <multiple use>
  0x28af790: i32,ch = load 0x28af590, 0x28af090, 0x28af490<LD4[%2]>

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af290: i32 = Register %vreg0 [ORD=4]

    0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

    0x28af090: <multiple use>
    0x28af490: <multiple use>
  0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4]


I was here to add i32 0
Initial selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 14 nodes:
  0x2891968: ch = EntryToken [ORD=4]

  0x28af090: i32 = FrameIndex<1> [ORD=4]

  0x28af490: i32 = undef [ORD=4]

    0x2891968: <multiple use>
      0x2891968: <multiple use>
      0x28af290: i32 = Register %vreg0 [ORD=4]

    0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

    0x28af090: <multiple use>
    0x28af490: <multiple use>
  0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4]

      0x28af590: <multiple use>
          0x28af590: <multiple use>
          0x28af090: <multiple use>
          0x28af490: <multiple use>
        0x28af790: i32,ch = load 0x28af590, 0x28af090, 0x28af490<LD4[%2]> [ORD=5]

        0x28af390: i32 = Constant<0> [ORD=6]

        0x28af690: ch = setlt [ORD=6]

      0x28aed90: i1 = setcc 0x28af790, 0x28af390, 0x28af690 [ORD=6]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680>

    0x28aee90: ch = brcond 0x28af590, 0x28aed90, 0x28af890

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470>

  0x28af990: ch = br 0x28aee90, 0x28af190



Replacing.1 0x28af790: i32,ch = load 0x28af590, 0x28af090, 0x28af490<LD4[%2]> [ORD=5]

With: 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]
 and 1 other values
Optimized lowered selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=4]

    0x2891968: <multiple use>
    0x28af290: i32 = Register %vreg0 [ORD=4]

  0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

        0x2891968: <multiple use>
        0x28aef90: <multiple use>
        0x28af090: i32 = FrameIndex<1> [ORD=4]

        0x28af490: i32 = undef [ORD=4]

      0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4]

        0x28aef90: <multiple use>
        0x28af390: i32 = Constant<0> [ORD=6]

        0x28af690: ch = setlt [ORD=6]

      0x28aed90: i1 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680>

    0x28aee90: ch = brcond 0x28af590, 0x28aed90, 0x28af890

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470>

  0x28af990: ch = br 0x28aee90, 0x28af190


Legally typed node: 0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470> [ID=0]

Legally typed node: 0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680> [ID=0]

Legally typed node: 0x28af690: ch = setlt [ORD=6] [ID=0]

Legally typed node: 0x28af490: i32 = undef [ORD=4] [ID=0]

Legally typed node: 0x28af390: i32 = Constant<0> [ORD=6] [ID=0]

Legally typed node: 0x28af090: i32 = FrameIndex<1> [ORD=4] [ID=0]

Legally typed node: 0x28af290: i32 = Register %vreg0 [ORD=4] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=4] [ID=0]

Legally typed node: 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=0]

Legally typed node: 0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4] [ID=0]

Promote integer result: 0x28aed90: i1 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=0]

Promote integer operand: 0x28aee90: ch = brcond 0x28af590, 0x28aed90, 0x28af890 [ID=0]

Promote integer operand: 0x28afa90: i32 = zero_extend 0x28aed90 [ID=0]

Legally typed node: 0x28afb90: i32 = Constant<1> [ID=0]

Legally typed node: 0x28af790: i32 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=0]

Legally typed node: 0x28bfc60: i32 = and 0x28af790, 0x28afb90 [ID=0]

Legally typed node: 0x28aee90: ch = brcond 0x28af590, 0x28bfc60, 0x28af890 [ID=0]

Legally typed node: 0x28af990: ch = br 0x28aee90, 0x28af190 [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28af990 [ID=0]

Type-legalized selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 15 nodes:
  0x2891968: ch = EntryToken [ORD=4] [ID=-3]

    0x2891968: <multiple use>
    0x28af290: i32 = Register %vreg0 [ORD=4] [ID=-3]

  0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=-3]

        0x2891968: <multiple use>
        0x28aef90: <multiple use>
        0x28af090: i32 = FrameIndex<1> [ORD=4] [ID=-3]

        0x28af490: i32 = undef [ORD=4] [ID=-3]

      0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4] [ID=-3]

          0x28aef90: <multiple use>
          0x28af390: i32 = Constant<0> [ORD=6] [ID=-3]

          0x28af690: ch = setlt [ORD=6] [ID=-3]

        0x28af790: i32 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=-3]

        0x28afb90: i32 = Constant<1> [ID=-3]

      0x28bfc60: i32 = and 0x28af790, 0x28afb90 [ID=-3]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680> [ID=-3]

    0x28aee90: ch = brcond 0x28af590, 0x28bfc60, 0x28af890 [ID=-3]

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470> [ID=-3]

  0x28af990: ch = br 0x28aee90, 0x28af190 [ID=-3]



Replacing.2 0x28bfc60: i32 = and 0x28af790, 0x28afb90 [ID=-3]

With: 0x28af790: i32 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=-3]

Optimized type-legalized selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=4] [ID=-3]

    0x2891968: <multiple use>
    0x28af290: i32 = Register %vreg0 [ORD=4] [ID=-3]

  0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=-3]

        0x2891968: <multiple use>
        0x28aef90: <multiple use>
        0x28af090: i32 = FrameIndex<1> [ORD=4] [ID=-3]

        0x28af490: i32 = undef [ORD=4] [ID=-3]

      0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4] [ID=-3]

        0x28aef90: <multiple use>
        0x28af390: i32 = Constant<0> [ORD=6] [ID=-3]

        0x28af690: ch = setlt [ORD=6] [ID=-3]

      0x28af790: i32 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=-3]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680> [ID=-3]

    0x28aee90: ch = brcond 0x28af590, 0x28af790, 0x28af890 [ID=-3]

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470> [ID=-3]

  0x28af990: ch = br 0x28aee90, 0x28af190 [ID=-3]


Legalized selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=4] [ID=0]

    0x2891968: <multiple use>
    0x28af290: i32 = Register %vreg0 [ORD=4] [ID=1]

  0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=8]

        0x2891968: <multiple use>
        0x28aef90: <multiple use>
        0x28af090: i32 = FrameIndex<1> [ORD=4] [ID=2]

        0x28af490: i32 = undef [ORD=4] [ID=4]

      0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4] [ID=10]

        0x28aef90: <multiple use>
        0x28af390: i32 = Constant<0> [ORD=6] [ID=3]

        0x28af690: ch = setlt [ORD=6] [ID=5]

      0x28af790: i32 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=9]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680> [ID=6]

    0x28aee90: ch = brcond 0x28af590, 0x28af790, 0x28af890 [ID=11]

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470> [ID=7]

  0x28af990: ch = br 0x28aee90, 0x28af190 [ID=12]


Optimized legalized selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=4] [ID=0]

    0x2891968: <multiple use>
    0x28af290: i32 = Register %vreg0 [ORD=4] [ID=1]

  0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=8]

        0x2891968: <multiple use>
        0x28aef90: <multiple use>
        0x28af090: i32 = FrameIndex<1> [ORD=4] [ID=2]

        0x28af490: i32 = undef [ORD=4] [ID=4]

      0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4] [ID=10]

        0x28aef90: <multiple use>
        0x28af390: i32 = Constant<0> [ORD=6] [ID=3]

        0x28af690: ch = setlt [ORD=6] [ID=5]

      0x28af790: i32 = setcc 0x28aef90, 0x28af390, 0x28af690 [ORD=6] [ID=9]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680> [ID=6]

    0x28aee90: ch = brcond 0x28af590, 0x28af790, 0x28af890 [ID=11]

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470> [ID=7]

  0x28af990: ch = br 0x28aee90, 0x28af190 [ID=12]


===== Instruction selection begins: BB#0 'eicas_calculator3.entry'
ISEL: Starting pattern match on root node: 0x28af990: ch = br 0x28aee90, 0x28af190 [ID=12]

  Initial Opcode index to 1938
  Morphed node: 0x28af990: ch = JAL 0x28af190, 0x28aee90

ISEL: Match complete!
=> 0x28af990: ch = JAL 0x28af190, 0x28aee90

ISEL: Starting pattern match on root node: 0x28aee90: ch = brcond 0x28af590, 0x28af790, 0x28af890 [ID=11]

  Initial Opcode index to 1439
  Skipped scope entry (due to false predicate) at index 1456, continuing at 1477
  Skipped scope entry (due to false predicate) at index 1478, continuing at 1499
  Morphed node: 0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af390, 0x28af590

ISEL: Match complete!
=> 0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af390, 0x28af590

ISEL: Starting pattern match on root node: 0x28af590: ch = store 0x2891968, 0x28aef90, 0x28af090, 0x28af490<ST4[%2]> [ORD=4] [ID=10]

  Initial Opcode index to 178
  Morphed node: 0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4]

ISEL: Match complete!
=> 0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4]

=> 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

=> 0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470>

=> 0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680>

ISEL: Starting pattern match on root node: 0x28af390: i32 = Constant<0> [ORD=6] [ID=3]

  Initial Opcode index to 1226
comparing 0 and 0 and returning value:1
ISEL: Match complete!
=> 0x28af390: i32 = Constant<0> [ORD=6] [ID=3]

=> 0x28af290: i32 = Register %vreg0 [ORD=4]

=> 0x2891968: ch = EntryToken [ORD=4]

===== Instruction selection ends:
Selected selection DAG: BB#0 'eicas_calculator3:eicas_calculator3.entry'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=4]

    0x2891968: <multiple use>
    0x28af290: i32 = Register %vreg0 [ORD=4]

  0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4]

    0x28af190: ch = BasicBlock<eicas_calculator3.if.else 0x28bd470>

      0x28af890: ch = BasicBlock<eicas_calculator3.if.then 0x28bd680>

      0x28aef90: <multiple use>
      0x28af490: i32 = Register %zero

        0x28aef90: <multiple use>
          0x28af390: i32 = Register %t5

          0x28af790: i32 = TargetFrameIndex<1>

        0x28af090: i32 = ADDI 0x28af390, 0x28af790 [ORD=4]

        0x28af690: i32 = TargetConstant<0>

        0x2891968: <multiple use>
      0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4]

    0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af490, 0x28af590

  0x28af990: ch = JAL 0x28af190, 0x28aee90


********** List Scheduling BB#0 'eicas_calculator3.entry' **********
SU(0): 0x28af990: ch = JAL 0x28af190, 0x28aee90 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af490, 0x28af590 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(4): Latency=1
   ch  SU(2): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4] [ID=2]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
   val SU(3): Latency=1
  Successors:
   ch  SU(1): Latency=1

SU(3): 0x28af090: i32 = ADDI 0x28af390, 0x28af790 [ORD=4] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(2): Latency=1

SU(4): 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=4]

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(1): Latency=1
   val SU(2): Latency=1


Examining Available:
Height 0: SU(0): 0x28af990: ch = JAL 0x28af190, 0x28aee90 [ID=0]


*** Scheduling [0]: SU(0): 0x28af990: ch = JAL 0x28af190, 0x28aee90 [ID=0]


Examining Available:
Height 1: SU(1): 0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af490, 0x28af590 [ID=1]


*** Scheduling [1]: SU(1): 0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af490, 0x28af590 [ID=1]


Examining Available:
Height 2: SU(2): 0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4] [ID=2]


*** Scheduling [2]: SU(2): 0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4] [ID=2]


Examining Available:
Height 3: SU(4): 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=4]

Height 3: SU(3): 0x28af090: i32 = ADDI 0x28af390, 0x28af790 [ORD=4] [ID=3]


*** Scheduling [3]: SU(4): 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=4]


Examining Available:
Height 3: SU(3): 0x28af090: i32 = ADDI 0x28af390, 0x28af790 [ORD=4] [ID=3]


*** Scheduling [4]: SU(3): 0x28af090: i32 = ADDI 0x28af390, 0x28af790 [ORD=4] [ID=3]

*** Final schedule ***
SU(3): 0x28af090: i32 = ADDI 0x28af390, 0x28af790 [ORD=4] [ID=3]

SU(4): 0x28aef90: i32,ch = CopyFromReg 0x2891968, 0x28af290 [ORD=4] [ID=4]

SU(2): 0x28af590: ch = SW 0x28aef90, 0x28af090, 0x28af690, 0x2891968<Mem:ST4[%2]> [ORD=4] [ID=2]

SU(1): 0x28aee90: ch = BLT 0x28af890, 0x28aef90, 0x28af490, 0x28af590 [ID=1]

SU(0): 0x28af990: ch = JAL 0x28af190, 0x28aee90 [ID=0]


Total amount of phi nodes to update: 0
visiting load instruction   %6 = load i32* %2, align 4
I was here to add   %2 = alloca i32, align 4
with I type i32and sd value :0x28af790: i32 = FrameIndex<1>
new load?0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]>
dag after load is dealt with?SelectionDAG has 5 nodes:
  0x28af390: i32 = Constant<0>

    0x2891968: ch = EntryToken

    0x28af790: i32 = FrameIndex<1>

    0x28af490: i32 = undef

  0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]>

  0x2891968: ch = EntryToken


I was here to add i32 65535
Initial selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 14 nodes:
  0x2891968: ch = EntryToken [ORD=7]

  0x28af390: i32 = Constant<0>

      0x2891968: <multiple use>
            0x2891968: <multiple use>
            0x28af790: i32 = FrameIndex<1> [ORD=7]

            0x28af490: i32 = undef [ORD=7]

          0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7]

          0x28af990: i32 = Constant<65535> [ORD=8]

          0x28aee90: ch = setgt [ORD=8]

        0x28af590: i1 = setcc 0x28af690, 0x28af990, 0x28aee90 [ORD=8]

        0x28aef90: i1 = Constant<-1>

      0x28af190: i1 = xor 0x28af590, 0x28aef90

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0>

    0x28af090: ch = brcond 0x2891968, 0x28af190, 0x28af890

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520>

  0x28afb90: ch = br 0x28af090, 0x28af290



Replacing.3 0x28af190: i1 = xor 0x28af590, 0x28aef90

With: 0x28aed90: i1 = setcc 0x28af690, 0x28af990, 0x28bfc60


Replacing.3 0x28aed90: i1 = setcc 0x28af690, 0x28af990, 0x28bfc60

With: 0x28aef90: i1 = setcc 0x28af690, 0x28aee90, 0x28af590

Optimized lowered selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 11 nodes:
  0x2891968: ch = EntryToken [ORD=7]

      0x2891968: <multiple use>
          0x2891968: <multiple use>
          0x28af790: i32 = FrameIndex<1> [ORD=7]

          0x28af490: i32 = undef [ORD=7]

        0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7]

        0x28aee90: i32 = Constant<65536>

        0x28af590: ch = setlt

      0x28aef90: i1 = setcc 0x28af690, 0x28aee90, 0x28af590

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0>

    0x28af090: ch = brcond 0x2891968, 0x28aef90, 0x28af890

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520>

  0x28afb90: ch = br 0x28af090, 0x28af290


Legally typed node: 0x28af590: ch = setlt [ID=0]

Legally typed node: 0x28aee90: i32 = Constant<65536> [ID=0]

Legally typed node: 0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520> [ID=0]

Legally typed node: 0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0> [ID=0]

Legally typed node: 0x28af490: i32 = undef [ORD=7] [ID=0]

Legally typed node: 0x28af790: i32 = FrameIndex<1> [ORD=7] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=7] [ID=0]

Legally typed node: 0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7] [ID=0]

Promote integer result: 0x28aef90: i1 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=0]

Promote integer operand: 0x28af090: ch = brcond 0x2891968, 0x28aef90, 0x28af890 [ID=0]

Promote integer operand: 0x28af990: i32 = zero_extend 0x28aef90 [ID=0]

Legally typed node: 0x28bfc60: i32 = Constant<1> [ID=0]

Legally typed node: 0x28af390: i32 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=0]

Legally typed node: 0x28aed90: i32 = and 0x28af390, 0x28bfc60 [ID=0]

Legally typed node: 0x28af090: ch = brcond 0x2891968, 0x28aed90, 0x28af890 [ID=0]

Legally typed node: 0x28afb90: ch = br 0x28af090, 0x28af290 [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28afb90 [ID=0]

Type-legalized selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=7] [ID=-3]

      0x2891968: <multiple use>
            0x2891968: <multiple use>
            0x28af790: i32 = FrameIndex<1> [ORD=7] [ID=-3]

            0x28af490: i32 = undef [ORD=7] [ID=-3]

          0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7] [ID=-3]

          0x28aee90: i32 = Constant<65536> [ID=-3]

          0x28af590: ch = setlt [ID=-3]

        0x28af390: i32 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=-3]

        0x28bfc60: i32 = Constant<1> [ID=-3]

      0x28aed90: i32 = and 0x28af390, 0x28bfc60 [ID=-3]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0> [ID=-3]

    0x28af090: ch = brcond 0x2891968, 0x28aed90, 0x28af890 [ID=-3]

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520> [ID=-3]

  0x28afb90: ch = br 0x28af090, 0x28af290 [ID=-3]



Replacing.2 0x28aed90: i32 = and 0x28af390, 0x28bfc60 [ID=-3]

With: 0x28af390: i32 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=-3]

Optimized type-legalized selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 11 nodes:
  0x2891968: ch = EntryToken [ORD=7] [ID=-3]

      0x2891968: <multiple use>
          0x2891968: <multiple use>
          0x28af790: i32 = FrameIndex<1> [ORD=7] [ID=-3]

          0x28af490: i32 = undef [ORD=7] [ID=-3]

        0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7] [ID=-3]

        0x28aee90: i32 = Constant<65536> [ID=-3]

        0x28af590: ch = setlt [ID=-3]

      0x28af390: i32 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=-3]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0> [ID=-3]

    0x28af090: ch = brcond 0x2891968, 0x28af390, 0x28af890 [ID=-3]

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520> [ID=-3]

  0x28afb90: ch = br 0x28af090, 0x28af290 [ID=-3]


Legalized selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 11 nodes:
  0x2891968: ch = EntryToken [ORD=7] [ID=0]

      0x2891968: <multiple use>
          0x2891968: <multiple use>
          0x28af790: i32 = FrameIndex<1> [ORD=7] [ID=1]

          0x28af490: i32 = undef [ORD=7] [ID=2]

        0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7] [ID=7]

        0x28aee90: i32 = Constant<65536> [ID=5]

        0x28af590: ch = setlt [ID=6]

      0x28af390: i32 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=8]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0> [ID=3]

    0x28af090: ch = brcond 0x2891968, 0x28af390, 0x28af890 [ID=9]

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520> [ID=4]

  0x28afb90: ch = br 0x28af090, 0x28af290 [ID=10]


Optimized legalized selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 11 nodes:
  0x2891968: ch = EntryToken [ORD=7] [ID=0]

      0x2891968: <multiple use>
          0x2891968: <multiple use>
          0x28af790: i32 = FrameIndex<1> [ORD=7] [ID=1]

          0x28af490: i32 = undef [ORD=7] [ID=2]

        0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7] [ID=7]

        0x28aee90: i32 = Constant<65536> [ID=5]

        0x28af590: ch = setlt [ID=6]

      0x28af390: i32 = setcc 0x28af690, 0x28aee90, 0x28af590 [ID=8]

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0> [ID=3]

    0x28af090: ch = brcond 0x2891968, 0x28af390, 0x28af890 [ID=9]

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520> [ID=4]

  0x28afb90: ch = br 0x28af090, 0x28af290 [ID=10]


===== Instruction selection begins: BB#1 'eicas_calculator3.if.else'
ISEL: Starting pattern match on root node: 0x28afb90: ch = br 0x28af090, 0x28af290 [ID=10]

  Initial Opcode index to 1938
  Morphed node: 0x28afb90: ch = JAL 0x28af290, 0x28af090

ISEL: Match complete!
=> 0x28afb90: ch = JAL 0x28af290, 0x28af090

ISEL: Starting pattern match on root node: 0x28af090: ch = brcond 0x2891968, 0x28af390, 0x28af890 [ID=9]

  Initial Opcode index to 1439
  Skipped scope entry (due to false predicate) at index 1456, continuing at 1477
  Skipped scope entry (due to false predicate) at index 1478, continuing at 1499
  Morphed node: 0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968

ISEL: Match complete!
=> 0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968

ISEL: Starting pattern match on root node: 0x28af690: i32,ch = load 0x2891968, 0x28af790, 0x28af490<LD4[%2]> [ORD=7] [ID=7]

  Initial Opcode index to 5
  TypeSwitch[i32] from 10 to 14
  Morphed node: 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7]

ISEL: Match complete!
=> 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7]

ISEL: Starting pattern match on root node: 0x28aee90: i32 = Constant<65536> [ID=5]

  Initial Opcode index to 1226
comparing 0 and 65536 and returning value:0
  Skipped scope entry (due to false predicate) at index 1228, continuing at 1236
  Skipped scope entry (due to false predicate) at index 1240, continuing at 1256
  Morphed node: 0x28aee90: i32 = ADDI 0x28af490, 0x28af390

ISEL: Match complete!
=> 0x28aee90: i32 = ADDI 0x28af490, 0x28af390

=> 0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520>

=> 0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0>

=> 0x2891968: ch = EntryToken [ORD=7]

===== Instruction selection ends:
Selected selection DAG: BB#1 'eicas_calculator3:eicas_calculator3.if.else'
SelectionDAG has 13 nodes:
  0x2891968: ch = EntryToken [ORD=7]

    0x28af290: ch = BasicBlock<eicas_calculator3.if.then2 0x28bd520>

      0x28af890: ch = BasicBlock<eicas_calculator3.if.else3 0x28bd5d0>

          0x28bfc60: i32 = Register %t5

          0x28aed90: i32 = TargetFrameIndex<1>

        0x28af790: i32 = ADDI 0x28bfc60, 0x28aed90 [ORD=7]

        0x28af590: i32 = TargetConstant<0>

        0x2891968: <multiple use>
      0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7]

        0x28af490: i32 = Register %zero

        0x28af390: i32 = TargetConstant<65536>

      0x28aee90: i32 = ADDI 0x28af490, 0x28af390

      0x2891968: <multiple use>
    0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968

  0x28afb90: ch = JAL 0x28af290, 0x28af090


********** List Scheduling BB#1 'eicas_calculator3.if.else' **********
SU(0): 0x28afb90: ch = JAL 0x28af290, 0x28af090 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968 [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(3): Latency=1
   val SU(2): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x28aee90: i32 = ADDI 0x28af490, 0x28af390 [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(3): 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7] [ID=3]

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
  Successors:
   val SU(1): Latency=1

SU(4): 0x28af790: i32 = ADDI 0x28bfc60, 0x28aed90 [ORD=7] [ID=4]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(3): Latency=1


Examining Available:
Height 0: SU(0): 0x28afb90: ch = JAL 0x28af290, 0x28af090 [ID=0]


*** Scheduling [0]: SU(0): 0x28afb90: ch = JAL 0x28af290, 0x28af090 [ID=0]


Examining Available:
Height 1: SU(1): 0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968 [ID=1]


*** Scheduling [1]: SU(1): 0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968 [ID=1]


Examining Available:
Height 2: SU(2): 0x28aee90: i32 = ADDI 0x28af490, 0x28af390 [ID=2]

Height 2: SU(3): 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7] [ID=3]


*** Scheduling [2]: SU(2): 0x28aee90: i32 = ADDI 0x28af490, 0x28af390 [ID=2]


Examining Available:
Height 2: SU(3): 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7] [ID=3]


*** Scheduling [3]: SU(3): 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7] [ID=3]


Examining Available:
Height 4: SU(4): 0x28af790: i32 = ADDI 0x28bfc60, 0x28aed90 [ORD=7] [ID=4]


*** Scheduling [4]: SU(4): 0x28af790: i32 = ADDI 0x28bfc60, 0x28aed90 [ORD=7] [ID=4]

*** Final schedule ***
SU(4): 0x28af790: i32 = ADDI 0x28bfc60, 0x28aed90 [ORD=7] [ID=4]

SU(3): 0x28af690: i32,ch = LW 0x28af790, 0x28af590, 0x2891968<Mem:LD4[%2]> [ORD=7] [ID=3]

SU(2): 0x28aee90: i32 = ADDI 0x28af490, 0x28af390 [ID=2]

SU(1): 0x28af090: ch = BLT 0x28af890, 0x28af690, 0x28aee90, 0x2891968 [ID=1]

SU(0): 0x28afb90: ch = JAL 0x28af290, 0x28af090 [ID=0]


Total amount of phi nodes to update: 0
visiting load instruction   %8 = load i32* %2, align 4
I was here to add   %2 = alloca i32, align 4
with I type i32and sd value :0x28aed90: i32 = FrameIndex<1>
new load?0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]>
dag after load is dealt with?SelectionDAG has 5 nodes:
  0x28bfc60: i32 = Constant<0>

    0x2891968: ch = EntryToken

    0x28aed90: i32 = FrameIndex<1>

    0x28af390: i32 = undef

  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]>

  0x2891968: ch = EntryToken


store visit is after?  store i32 %8, i32* %3, align 4
I was here to add   %3 = alloca i32, align 4
whats in dag after store?SelectionDAG has 7 nodes:
  0x28bfc60: i32 = Constant<0>

  0x28af390: i32 = undef [ORD=9]

    0x2891968: ch = EntryToken [ORD=9]

    0x28aed90: i32 = FrameIndex<1> [ORD=9]

    0x28af390: <multiple use>
  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9]

    0x28af490: <multiple use>
    0x28af490: <multiple use>
    0x28af590: i32 = FrameIndex<2> [ORD=10]

    0x28af390: <multiple use>
  0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10]


Initial selection DAG: BB#3 'eicas_calculator3:eicas_calculator3.if.else3'
SelectionDAG has 9 nodes:
  0x28bfc60: i32 = Constant<0>

  0x28af390: i32 = undef [ORD=9]

    0x2891968: ch = EntryToken [ORD=9]

    0x28aed90: i32 = FrameIndex<1> [ORD=9]

    0x28af390: <multiple use>
  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9]

      0x28af490: <multiple use>
      0x28af490: <multiple use>
      0x28af590: i32 = FrameIndex<2> [ORD=10]

      0x28af390: <multiple use>
    0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10]

    0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

  0x28af690: ch = br 0x28afb90, 0x28af090


Optimized lowered selection DAG: BB#3 'eicas_calculator3:eicas_calculator3.if.else3'
SelectionDAG has 8 nodes:
  0x28af390: i32 = undef [ORD=9]

    0x2891968: ch = EntryToken [ORD=9]

    0x28aed90: i32 = FrameIndex<1> [ORD=9]

    0x28af390: <multiple use>
  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9]

      0x28af490: <multiple use>
      0x28af490: <multiple use>
      0x28af590: i32 = FrameIndex<2> [ORD=10]

      0x28af390: <multiple use>
    0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10]

    0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

  0x28af690: ch = br 0x28afb90, 0x28af090


Legally typed node: 0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=0]

Legally typed node: 0x28af590: i32 = FrameIndex<2> [ORD=10] [ID=0]

Legally typed node: 0x28af390: i32 = undef [ORD=9] [ID=0]

Legally typed node: 0x28aed90: i32 = FrameIndex<1> [ORD=9] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=9] [ID=0]

Legally typed node: 0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9] [ID=0]

Legally typed node: 0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10] [ID=0]

Legally typed node: 0x28af690: ch = br 0x28afb90, 0x28af090 [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28af690 [ID=0]

Type-legalized selection DAG: BB#3 'eicas_calculator3:eicas_calculator3.if.else3'
SelectionDAG has 8 nodes:
  0x28af390: i32 = undef [ORD=9] [ID=-3]

    0x2891968: ch = EntryToken [ORD=9] [ID=-3]

    0x28aed90: i32 = FrameIndex<1> [ORD=9] [ID=-3]

    0x28af390: <multiple use>
  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9] [ID=-3]

      0x28af490: <multiple use>
      0x28af490: <multiple use>
      0x28af590: i32 = FrameIndex<2> [ORD=10] [ID=-3]

      0x28af390: <multiple use>
    0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10] [ID=-3]

    0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=-3]

  0x28af690: ch = br 0x28afb90, 0x28af090 [ID=-3]


Legalized selection DAG: BB#3 'eicas_calculator3:eicas_calculator3.if.else3'
SelectionDAG has 8 nodes:
  0x28af390: i32 = undef [ORD=9] [ID=2]

    0x2891968: ch = EntryToken [ORD=9] [ID=0]

    0x28aed90: i32 = FrameIndex<1> [ORD=9] [ID=1]

    0x28af390: <multiple use>
  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9] [ID=5]

      0x28af490: <multiple use>
      0x28af490: <multiple use>
      0x28af590: i32 = FrameIndex<2> [ORD=10] [ID=3]

      0x28af390: <multiple use>
    0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10] [ID=6]

    0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=4]

  0x28af690: ch = br 0x28afb90, 0x28af090 [ID=7]


Optimized legalized selection DAG: BB#3 'eicas_calculator3:eicas_calculator3.if.else3'
SelectionDAG has 8 nodes:
  0x28af390: i32 = undef [ORD=9] [ID=2]

    0x2891968: ch = EntryToken [ORD=9] [ID=0]

    0x28aed90: i32 = FrameIndex<1> [ORD=9] [ID=1]

    0x28af390: <multiple use>
  0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9] [ID=5]

      0x28af490: <multiple use>
      0x28af490: <multiple use>
      0x28af590: i32 = FrameIndex<2> [ORD=10] [ID=3]

      0x28af390: <multiple use>
    0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10] [ID=6]

    0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=4]

  0x28af690: ch = br 0x28afb90, 0x28af090 [ID=7]


===== Instruction selection begins: BB#3 'eicas_calculator3.if.else3'
ISEL: Starting pattern match on root node: 0x28af690: ch = br 0x28afb90, 0x28af090 [ID=7]

  Initial Opcode index to 1938
  Morphed node: 0x28af690: ch = JAL 0x28af090, 0x28afb90

ISEL: Match complete!
=> 0x28af690: ch = JAL 0x28af090, 0x28afb90

ISEL: Starting pattern match on root node: 0x28afb90: ch = store 0x28af490:1, 0x28af490, 0x28af590, 0x28af390<ST4[%3]> [ORD=10] [ID=6]

  Initial Opcode index to 178
  Morphed node: 0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10]

ISEL: Match complete!
=> 0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10]

ISEL: Starting pattern match on root node: 0x28af490: i32,ch = load 0x2891968, 0x28aed90, 0x28af390<LD4[%2]> [ORD=9] [ID=5]

  Initial Opcode index to 5
  TypeSwitch[i32] from 10 to 14
  Morphed node: 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9]

ISEL: Match complete!
=> 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9]

=> 0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

=> 0x2891968: ch = EntryToken [ORD=9]

===== Instruction selection ends:
Selected selection DAG: BB#3 'eicas_calculator3:eicas_calculator3.if.else3'
SelectionDAG has 11 nodes:
      0x28af390: <multiple use>
      0x28af290: i32 = TargetFrameIndex<1>

    0x28aed90: i32 = ADDI 0x28af390, 0x28af290 [ORD=9]

    0x28bfc60: <multiple use>
    0x2891968: ch = EntryToken [ORD=9]

  0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9]

  0x28bfc60: i32 = TargetConstant<0>

  0x28af390: i32 = Register %t5

    0x28af090: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

      0x28af490: <multiple use>
        0x28af390: <multiple use>
        0x28aee90: i32 = TargetFrameIndex<2>

      0x28af590: i32 = ADDI 0x28af390, 0x28aee90 [ORD=10]

      0x28bfc60: <multiple use>
      0x28af490: <multiple use>
    0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10]

  0x28af690: ch = JAL 0x28af090, 0x28afb90


********** List Scheduling BB#3 'eicas_calculator3.if.else3' **********
SU(0): 0x28af690: ch = JAL 0x28af090, 0x28afb90 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10] [ID=1]

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
   val SU(3): Latency=1
   val SU(2): Latency=1
   ch  SU(3): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x28af590: i32 = ADDI 0x28af390, 0x28aee90 [ORD=10] [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(3): 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9] [ID=3]

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
   val SU(4): Latency=1
  Successors:
   val SU(1): Latency=1
   ch  SU(1): Latency=1

SU(4): 0x28aed90: i32 = ADDI 0x28af390, 0x28af290 [ORD=9] [ID=4]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
   val SU(3): Latency=1


Examining Available:
Height 0: SU(0): 0x28af690: ch = JAL 0x28af090, 0x28afb90 [ID=0]


*** Scheduling [0]: SU(0): 0x28af690: ch = JAL 0x28af090, 0x28afb90 [ID=0]


Examining Available:
Height 1: SU(1): 0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10] [ID=1]


*** Scheduling [1]: SU(1): 0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10] [ID=1]


Examining Available:
Height 2: SU(2): 0x28af590: i32 = ADDI 0x28af390, 0x28aee90 [ORD=10] [ID=2]

Height 2: SU(3): 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9] [ID=3]


*** Scheduling [2]: SU(2): 0x28af590: i32 = ADDI 0x28af390, 0x28aee90 [ORD=10] [ID=2]


Examining Available:
Height 2: SU(3): 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9] [ID=3]


*** Scheduling [3]: SU(3): 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9] [ID=3]


Examining Available:
Height 4: SU(4): 0x28aed90: i32 = ADDI 0x28af390, 0x28af290 [ORD=9] [ID=4]


*** Scheduling [4]: SU(4): 0x28aed90: i32 = ADDI 0x28af390, 0x28af290 [ORD=9] [ID=4]

*** Final schedule ***
SU(4): 0x28aed90: i32 = ADDI 0x28af390, 0x28af290 [ORD=9] [ID=4]

SU(3): 0x28af490: i32,ch = LW 0x28aed90, 0x28bfc60, 0x2891968<Mem:LD4[%2]> [ORD=9] [ID=3]

SU(2): 0x28af590: i32 = ADDI 0x28af390, 0x28aee90 [ORD=10] [ID=2]

SU(1): 0x28afb90: ch = SW 0x28af490, 0x28af590, 0x28bfc60, 0x28af490:1<Mem:ST4[%3]> [ORD=10] [ID=1]

SU(0): 0x28af690: ch = JAL 0x28af090, 0x28afb90 [ID=0]


Total amount of phi nodes to update: 0
store visit is after?  store i32 65535, i32* %3, align 4
I was here to add i32 65535
I was here to add   %3 = alloca i32, align 4
whats in dag after store?SelectionDAG has 6 nodes:
  0x28af390: i32 = Constant<0>

    0x2891968: ch = EntryToken [ORD=11]

    0x28af290: i32 = Constant<65535> [ORD=11]

    0x28aee90: i32 = FrameIndex<2> [ORD=11]

    0x28bfc60: i32 = undef [ORD=11]

  0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11]


Initial selection DAG: BB#2 'eicas_calculator3:eicas_calculator3.if.then2'
SelectionDAG has 8 nodes:
  0x28af390: i32 = Constant<0>

      0x2891968: ch = EntryToken [ORD=11]

      0x28af290: i32 = Constant<65535> [ORD=11]

      0x28aee90: i32 = FrameIndex<2> [ORD=11]

      0x28bfc60: i32 = undef [ORD=11]

    0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11]

    0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

  0x28af490: ch = br 0x28af690, 0x28afb90


Optimized lowered selection DAG: BB#2 'eicas_calculator3:eicas_calculator3.if.then2'
SelectionDAG has 7 nodes:
      0x2891968: ch = EntryToken [ORD=11]

      0x28af290: i32 = Constant<65535> [ORD=11]

      0x28aee90: i32 = FrameIndex<2> [ORD=11]

      0x28bfc60: i32 = undef [ORD=11]

    0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11]

    0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

  0x28af490: ch = br 0x28af690, 0x28afb90


Legally typed node: 0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=0]

Legally typed node: 0x28bfc60: i32 = undef [ORD=11] [ID=0]

Legally typed node: 0x28aee90: i32 = FrameIndex<2> [ORD=11] [ID=0]

Legally typed node: 0x28af290: i32 = Constant<65535> [ORD=11] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=11] [ID=0]

Legally typed node: 0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11] [ID=0]

Legally typed node: 0x28af490: ch = br 0x28af690, 0x28afb90 [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28af490 [ID=0]

Type-legalized selection DAG: BB#2 'eicas_calculator3:eicas_calculator3.if.then2'
SelectionDAG has 7 nodes:
      0x2891968: ch = EntryToken [ORD=11] [ID=-3]

      0x28af290: i32 = Constant<65535> [ORD=11] [ID=-3]

      0x28aee90: i32 = FrameIndex<2> [ORD=11] [ID=-3]

      0x28bfc60: i32 = undef [ORD=11] [ID=-3]

    0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11] [ID=-3]

    0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=-3]

  0x28af490: ch = br 0x28af690, 0x28afb90 [ID=-3]


Legalized selection DAG: BB#2 'eicas_calculator3:eicas_calculator3.if.then2'
SelectionDAG has 7 nodes:
      0x2891968: ch = EntryToken [ORD=11] [ID=0]

      0x28af290: i32 = Constant<65535> [ORD=11] [ID=1]

      0x28aee90: i32 = FrameIndex<2> [ORD=11] [ID=2]

      0x28bfc60: i32 = undef [ORD=11] [ID=3]

    0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11] [ID=5]

    0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=4]

  0x28af490: ch = br 0x28af690, 0x28afb90 [ID=6]


Optimized legalized selection DAG: BB#2 'eicas_calculator3:eicas_calculator3.if.then2'
SelectionDAG has 7 nodes:
      0x2891968: ch = EntryToken [ORD=11] [ID=0]

      0x28af290: i32 = Constant<65535> [ORD=11] [ID=1]

      0x28aee90: i32 = FrameIndex<2> [ORD=11] [ID=2]

      0x28bfc60: i32 = undef [ORD=11] [ID=3]

    0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11] [ID=5]

    0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730> [ID=4]

  0x28af490: ch = br 0x28af690, 0x28afb90 [ID=6]


===== Instruction selection begins: BB#2 'eicas_calculator3.if.then2'
ISEL: Starting pattern match on root node: 0x28af490: ch = br 0x28af690, 0x28afb90 [ID=6]

  Initial Opcode index to 1938
  Morphed node: 0x28af490: ch = JAL 0x28afb90, 0x28af690

ISEL: Match complete!
=> 0x28af490: ch = JAL 0x28afb90, 0x28af690

ISEL: Starting pattern match on root node: 0x28af690: ch = store 0x2891968, 0x28af290, 0x28aee90, 0x28bfc60<ST4[%3]> [ORD=11] [ID=5]

  Initial Opcode index to 178
  Morphed node: 0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11]

ISEL: Match complete!
=> 0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11]

=> 0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

ISEL: Starting pattern match on root node: 0x28af290: i32 = Constant<65535> [ORD=11] [ID=1]

  Initial Opcode index to 1226
comparing 0 and 65535 and returning value:0
  Skipped scope entry (due to false predicate) at index 1228, continuing at 1236
  Skipped scope entry (due to false predicate) at index 1240, continuing at 1256
  Morphed node: 0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11]

ISEL: Match complete!
=> 0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11]

=> 0x2891968: ch = EntryToken [ORD=11]

===== Instruction selection ends:
Selected selection DAG: BB#2 'eicas_calculator3:eicas_calculator3.if.then2'
SelectionDAG has 11 nodes:
    0x28afb90: ch = BasicBlock<eicas_calculator3.return 0x28bd730>

        0x28af590: i32 = Register %zero

        0x28aed90: i32 = TargetConstant<65535>

      0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11]

        0x28bfc60: i32 = Register %t5

        0x28af090: i32 = TargetFrameIndex<2>

      0x28aee90: i32 = ADDI 0x28bfc60, 0x28af090 [ORD=11]

      0x28af390: i32 = TargetConstant<0>

      0x2891968: ch = EntryToken [ORD=11]

    0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11]

  0x28af490: ch = JAL 0x28afb90, 0x28af690


********** List Scheduling BB#2 'eicas_calculator3.if.then2' **********
SU(0): 0x28af490: ch = JAL 0x28afb90, 0x28af690 [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
   ch  SU(1): Latency=1

SU(1): 0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11] [ID=1]

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
   val SU(3): Latency=1
   val SU(2): Latency=1
  Successors:
   ch  SU(0): Latency=1

SU(2): 0x28aee90: i32 = ADDI 0x28bfc60, 0x28af090 [ORD=11] [ID=2]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1

SU(3): 0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(1): Latency=1


Examining Available:
Height 0: SU(0): 0x28af490: ch = JAL 0x28afb90, 0x28af690 [ID=0]


*** Scheduling [0]: SU(0): 0x28af490: ch = JAL 0x28afb90, 0x28af690 [ID=0]


Examining Available:
Height 1: SU(1): 0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11] [ID=1]


*** Scheduling [1]: SU(1): 0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11] [ID=1]


Examining Available:
Height 2: SU(3): 0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11] [ID=3]

Height 2: SU(2): 0x28aee90: i32 = ADDI 0x28bfc60, 0x28af090 [ORD=11] [ID=2]


*** Scheduling [2]: SU(3): 0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11] [ID=3]


Examining Available:
Height 2: SU(2): 0x28aee90: i32 = ADDI 0x28bfc60, 0x28af090 [ORD=11] [ID=2]


*** Scheduling [3]: SU(2): 0x28aee90: i32 = ADDI 0x28bfc60, 0x28af090 [ORD=11] [ID=2]

*** Final schedule ***
SU(2): 0x28aee90: i32 = ADDI 0x28bfc60, 0x28af090 [ORD=11] [ID=2]

SU(3): 0x28af290: i32 = ADDI 0x28af590, 0x28aed90 [ORD=11] [ID=3]

SU(1): 0x28af690: ch = SW 0x28af290, 0x28aee90, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=11] [ID=1]

SU(0): 0x28af490: ch = JAL 0x28afb90, 0x28af690 [ID=0]


Total amount of phi nodes to update: 0
store visit is after?  store i32 0, i32* %3, align 4
I was here to add i32 0
I was here to add   %3 = alloca i32, align 4
whats in dag after store?SelectionDAG has 5 nodes:
    0x2891968: ch = EntryToken [ORD=12]

    0x28aed90: i32 = Constant<0> [ORD=12]

    0x28af590: i32 = FrameIndex<2> [ORD=12]

    0x28af090: i32 = undef [ORD=12]

  0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12]


Initial selection DAG: BB#4 'eicas_calculator3:eicas_calculator3.if.then'
SelectionDAG has 5 nodes:
    0x2891968: ch = EntryToken [ORD=12]

    0x28aed90: i32 = Constant<0> [ORD=12]

    0x28af590: i32 = FrameIndex<2> [ORD=12]

    0x28af090: i32 = undef [ORD=12]

  0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12]


Optimized lowered selection DAG: BB#4 'eicas_calculator3:eicas_calculator3.if.then'
SelectionDAG has 5 nodes:
    0x2891968: ch = EntryToken [ORD=12]

    0x28aed90: i32 = Constant<0> [ORD=12]

    0x28af590: i32 = FrameIndex<2> [ORD=12]

    0x28af090: i32 = undef [ORD=12]

  0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12]


Legally typed node: 0x28af090: i32 = undef [ORD=12] [ID=0]

Legally typed node: 0x28af590: i32 = FrameIndex<2> [ORD=12] [ID=0]

Legally typed node: 0x28aed90: i32 = Constant<0> [ORD=12] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=12] [ID=0]

Legally typed node: 0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12] [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28bfc60 [ID=0]

Type-legalized selection DAG: BB#4 'eicas_calculator3:eicas_calculator3.if.then'
SelectionDAG has 5 nodes:
    0x2891968: ch = EntryToken [ORD=12] [ID=-3]

    0x28aed90: i32 = Constant<0> [ORD=12] [ID=-3]

    0x28af590: i32 = FrameIndex<2> [ORD=12] [ID=-3]

    0x28af090: i32 = undef [ORD=12] [ID=-3]

  0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12] [ID=-3]


Legalized selection DAG: BB#4 'eicas_calculator3:eicas_calculator3.if.then'
SelectionDAG has 5 nodes:
    0x2891968: ch = EntryToken [ORD=12] [ID=0]

    0x28aed90: i32 = Constant<0> [ORD=12] [ID=1]

    0x28af590: i32 = FrameIndex<2> [ORD=12] [ID=2]

    0x28af090: i32 = undef [ORD=12] [ID=3]

  0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12] [ID=4]


Optimized legalized selection DAG: BB#4 'eicas_calculator3:eicas_calculator3.if.then'
SelectionDAG has 5 nodes:
    0x2891968: ch = EntryToken [ORD=12] [ID=0]

    0x28aed90: i32 = Constant<0> [ORD=12] [ID=1]

    0x28af590: i32 = FrameIndex<2> [ORD=12] [ID=2]

    0x28af090: i32 = undef [ORD=12] [ID=3]

  0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12] [ID=4]


===== Instruction selection begins: BB#4 'eicas_calculator3.if.then'
ISEL: Starting pattern match on root node: 0x28bfc60: ch = store 0x2891968, 0x28aed90, 0x28af590, 0x28af090<ST4[%3]> [ORD=12] [ID=4]

  Initial Opcode index to 178
  Morphed node: 0x28bfc60: ch = SW 0x28aed90, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12]

ISEL: Match complete!
=> 0x28bfc60: ch = SW 0x28aed90, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12]

ISEL: Starting pattern match on root node: 0x28aed90: i32 = Constant<0> [ORD=12] [ID=1]

  Initial Opcode index to 1226
comparing 0 and 0 and returning value:1
ISEL: Match complete!
=> 0x28aed90: i32 = Constant<0> [ORD=12] [ID=1]

=> 0x2891968: ch = EntryToken [ORD=12]

===== Instruction selection ends:
Selected selection DAG: BB#4 'eicas_calculator3:eicas_calculator3.if.then'
SelectionDAG has 7 nodes:
    0x28af690: i32 = Register %zero

      0x28af090: i32 = Register %t5

      0x28af490: i32 = TargetFrameIndex<2>

    0x28af590: i32 = ADDI 0x28af090, 0x28af490 [ORD=12]

    0x28af390: i32 = TargetConstant<0>

    0x2891968: ch = EntryToken [ORD=12]

  0x28bfc60: ch = SW 0x28af690, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12]


********** List Scheduling BB#4 'eicas_calculator3.if.then' **********
SU(0): 0x28bfc60: ch = SW 0x28af690, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12] [ID=0]

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
   val SU(1): Latency=1

SU(1): 0x28af590: i32 = ADDI 0x28af090, 0x28af490 [ORD=12] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1


Examining Available:
Height 0: SU(0): 0x28bfc60: ch = SW 0x28af690, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12] [ID=0]


*** Scheduling [0]: SU(0): 0x28bfc60: ch = SW 0x28af690, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12] [ID=0]


Examining Available:
Height 1: SU(1): 0x28af590: i32 = ADDI 0x28af090, 0x28af490 [ORD=12] [ID=1]


*** Scheduling [1]: SU(1): 0x28af590: i32 = ADDI 0x28af090, 0x28af490 [ORD=12] [ID=1]

*** Final schedule ***
SU(1): 0x28af590: i32 = ADDI 0x28af090, 0x28af490 [ORD=12] [ID=1]

SU(0): 0x28bfc60: ch = SW 0x28af690, 0x28af590, 0x28af390, 0x2891968<Mem:ST4[%3]> [ORD=12] [ID=0]


Total amount of phi nodes to update: 0
visiting load instruction   %9 = load i32* %3, align 4
I was here to add   %3 = alloca i32, align 4
with I type i32and sd value :0x28af690: i32 = FrameIndex<2>
new load?0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]>
dag after load is dealt with?SelectionDAG has 5 nodes:
  0x28af490: i32 = Constant<0>

    0x2891968: ch = EntryToken

    0x28af690: i32 = FrameIndex<2>

    0x28af090: i32 = undef

  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]>

  0x2891968: ch = EntryToken


store visit is after?  store i32 %9, i32* %1, align 4
I was here to add   %1 = alloca i32, align 4, !ConsumedBy !6
whats in dag after store?SelectionDAG has 7 nodes:
  0x28af490: i32 = Constant<0>

  0x28af090: i32 = undef [ORD=13]

    0x2891968: ch = EntryToken [ORD=13]

    0x28af690: i32 = FrameIndex<2> [ORD=13]

    0x28af090: <multiple use>
  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13]

    0x28af390: <multiple use>
    0x28af390: <multiple use>
    0x28bfc60: i32 = FrameIndex<0> [ORD=14]

    0x28af090: <multiple use>
  0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14]


Initial selection DAG: BB#5 'eicas_calculator3:eicas_calculator3.return'
SelectionDAG has 7 nodes:
  0x28af490: i32 = Constant<0>

  0x28af090: i32 = undef [ORD=13]

    0x2891968: ch = EntryToken [ORD=13]

    0x28af690: i32 = FrameIndex<2> [ORD=13]

    0x28af090: <multiple use>
  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13]

    0x28af390: <multiple use>
    0x28af390: <multiple use>
    0x28bfc60: i32 = FrameIndex<0> [ORD=14]

    0x28af090: <multiple use>
  0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14]


Optimized lowered selection DAG: BB#5 'eicas_calculator3:eicas_calculator3.return'
SelectionDAG has 6 nodes:
  0x28af090: i32 = undef [ORD=13]

    0x2891968: ch = EntryToken [ORD=13]

    0x28af690: i32 = FrameIndex<2> [ORD=13]

    0x28af090: <multiple use>
  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13]

    0x28af390: <multiple use>
    0x28af390: <multiple use>
    0x28bfc60: i32 = FrameIndex<0> [ORD=14]

    0x28af090: <multiple use>
  0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14]


Legally typed node: 0x28bfc60: i32 = FrameIndex<0> [ORD=14] [ID=0]

Legally typed node: 0x28af090: i32 = undef [ORD=13] [ID=0]

Legally typed node: 0x28af690: i32 = FrameIndex<2> [ORD=13] [ID=0]

Legally typed node: 0x2891968: ch = EntryToken [ORD=13] [ID=0]

Legally typed node: 0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13] [ID=0]

Legally typed node: 0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14] [ID=0]

Legally typed node: 0x7fffcf703680: ch = handlenode 0x28af590 [ID=0]

Type-legalized selection DAG: BB#5 'eicas_calculator3:eicas_calculator3.return'
SelectionDAG has 6 nodes:
  0x28af090: i32 = undef [ORD=13] [ID=-3]

    0x2891968: ch = EntryToken [ORD=13] [ID=-3]

    0x28af690: i32 = FrameIndex<2> [ORD=13] [ID=-3]

    0x28af090: <multiple use>
  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13] [ID=-3]

    0x28af390: <multiple use>
    0x28af390: <multiple use>
    0x28bfc60: i32 = FrameIndex<0> [ORD=14] [ID=-3]

    0x28af090: <multiple use>
  0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14] [ID=-3]


Legalized selection DAG: BB#5 'eicas_calculator3:eicas_calculator3.return'
SelectionDAG has 6 nodes:
  0x28af090: i32 = undef [ORD=13] [ID=2]

    0x2891968: ch = EntryToken [ORD=13] [ID=0]

    0x28af690: i32 = FrameIndex<2> [ORD=13] [ID=1]

    0x28af090: <multiple use>
  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13] [ID=4]

    0x28af390: <multiple use>
    0x28af390: <multiple use>
    0x28bfc60: i32 = FrameIndex<0> [ORD=14] [ID=3]

    0x28af090: <multiple use>
  0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14] [ID=5]


Optimized legalized selection DAG: BB#5 'eicas_calculator3:eicas_calculator3.return'
SelectionDAG has 6 nodes:
  0x28af090: i32 = undef [ORD=13] [ID=2]

    0x2891968: ch = EntryToken [ORD=13] [ID=0]

    0x28af690: i32 = FrameIndex<2> [ORD=13] [ID=1]

    0x28af090: <multiple use>
  0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13] [ID=4]

    0x28af390: <multiple use>
    0x28af390: <multiple use>
    0x28bfc60: i32 = FrameIndex<0> [ORD=14] [ID=3]

    0x28af090: <multiple use>
  0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14] [ID=5]


===== Instruction selection begins: BB#5 'eicas_calculator3.return'
ISEL: Starting pattern match on root node: 0x28af590: ch = store 0x28af390:1, 0x28af390, 0x28bfc60, 0x28af090<ST4[%1]> [ORD=14] [ID=5]

  Initial Opcode index to 178
  Morphed node: 0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14]

ISEL: Match complete!
=> 0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14]

ISEL: Starting pattern match on root node: 0x28af390: i32,ch = load 0x2891968, 0x28af690, 0x28af090<LD4[%3]> [ORD=13] [ID=4]

  Initial Opcode index to 5
  TypeSwitch[i32] from 10 to 14
  Morphed node: 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13]

ISEL: Match complete!
=> 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13]

=> 0x2891968: ch = EntryToken [ORD=13]

===== Instruction selection ends:
Selected selection DAG: BB#5 'eicas_calculator3:eicas_calculator3.return'
SelectionDAG has 9 nodes:
      0x28af090: <multiple use>
      0x28afb90: i32 = TargetFrameIndex<2>

    0x28af690: i32 = ADDI 0x28af090, 0x28afb90 [ORD=13]

    0x28af490: <multiple use>
    0x2891968: ch = EntryToken [ORD=13]

  0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13]

  0x28af490: i32 = TargetConstant<0>

  0x28af090: i32 = Register %t5

    0x28af390: <multiple use>
      0x28af090: <multiple use>
      0x28aed90: i32 = TargetFrameIndex<0>

    0x28bfc60: i32 = ADDI 0x28af090, 0x28aed90 [ORD=14]

    0x28af490: <multiple use>
    0x28af390: <multiple use>
  0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14]


********** List Scheduling BB#5 'eicas_calculator3.return' **********
SU(0): 0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14] [ID=0]

  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
   val SU(2): Latency=1
   val SU(1): Latency=1
   ch  SU(2): Latency=1

SU(1): 0x28bfc60: i32 = ADDI 0x28af090, 0x28aed90 [ORD=14] [ID=1]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
   val SU(0): Latency=1

SU(2): 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13] [ID=2]

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
   val SU(3): Latency=1
  Successors:
   val SU(0): Latency=1
   ch  SU(0): Latency=1

SU(3): 0x28af690: i32 = ADDI 0x28af090, 0x28afb90 [ORD=13] [ID=3]

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
   val SU(2): Latency=1


Examining Available:
Height 0: SU(0): 0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14] [ID=0]


*** Scheduling [0]: SU(0): 0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14] [ID=0]


Examining Available:
Height 1: SU(1): 0x28bfc60: i32 = ADDI 0x28af090, 0x28aed90 [ORD=14] [ID=1]

Height 1: SU(2): 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13] [ID=2]


*** Scheduling [1]: SU(1): 0x28bfc60: i32 = ADDI 0x28af090, 0x28aed90 [ORD=14] [ID=1]


Examining Available:
Height 1: SU(2): 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13] [ID=2]


*** Scheduling [2]: SU(2): 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13] [ID=2]


Examining Available:
Height 3: SU(3): 0x28af690: i32 = ADDI 0x28af090, 0x28afb90 [ORD=13] [ID=3]


*** Scheduling [3]: SU(3): 0x28af690: i32 = ADDI 0x28af090, 0x28afb90 [ORD=13] [ID=3]

*** Final schedule ***
SU(3): 0x28af690: i32 = ADDI 0x28af090, 0x28afb90 [ORD=13] [ID=3]

SU(2): 0x28af390: i32,ch = LW 0x28af690, 0x28af490, 0x2891968<Mem:LD4[%3]> [ORD=13] [ID=2]

SU(1): 0x28bfc60: i32 = ADDI 0x28af090, 0x28aed90 [ORD=14] [ID=1]

SU(0): 0x28af590: ch = SW 0x28af390, 0x28bfc60, 0x28af490, 0x28af390:1<Mem:ST4[%1]> [ORD=14] [ID=0]


Total amount of phi nodes to update: 0
# Machine code for function eicas_calculator3: SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %eicas_calculator3.entry
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
48B		SW %vreg0, %vreg1<kill>, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
64B		BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
80B		JAL <BB#1>
	    Successors according to CFG: BB#4(12) BB#1(20)

96B	BB#1: derived from LLVM BB %eicas_calculator3.if.else
	    Predecessors according to CFG: BB#0
112B		%vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
128B		%vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
144B		%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
160B		BLT <BB#3>, %vreg3<kill>, %vreg4<kill>; GR32Bit:%vreg3,%vreg4
176B		JAL <BB#2>
	    Successors according to CFG: BB#2(16) BB#3(16)

192B	BB#2: derived from LLVM BB %eicas_calculator3.if.then2
	    Predecessors according to CFG: BB#1
208B		%vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
224B		%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
240B		SW %vreg9<kill>, %vreg8<kill>, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
256B		JAL <BB#5>
	    Successors according to CFG: BB#5

272B	BB#3: derived from LLVM BB %eicas_calculator3.if.else3
	    Predecessors according to CFG: BB#1
288B		%vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
304B		%vreg6<def> = LW %vreg5<kill>, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
320B		%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
336B		SW %vreg6<kill>, %vreg7<kill>, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
352B		JAL <BB#5>
	    Successors according to CFG: BB#5

368B	BB#4: derived from LLVM BB %eicas_calculator3.if.then
	    Predecessors according to CFG: BB#0
384B		%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
400B		SW %zero, %vreg10<kill>, 0; mem:ST4[%3] GR32Bit:%vreg10
	    Successors according to CFG: BB#5

416B	BB#5: derived from LLVM BB %eicas_calculator3.return
	    Predecessors according to CFG: BB#3 BB#2 BB#4
432B		%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
448B		%vreg12<def> = LW %vreg11<kill>, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
464B		%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
480B		SW %vreg12<kill>, %vreg13<kill>, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13

# End machine code for function eicas_calculator3.

********** Stack Coloring **********
********** Function: eicas_calculator3
Found 0 markers and 3 slots
Slot structure:
Slot #0 - 4 bytes.
Slot #1 - 4 bytes.
Slot #2 - 4 bytes.
Total Stack size: 12 bytes

Will not try to merge slots.
Removed 0 markers.
******** Pre-regalloc Machine LICM: eicas_calculator3 ********
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: eicas_calculator3
********** PROCESS IMPLICIT DEFS **********
********** Function: eicas_calculator3
********** REWRITING TWO-ADDR INSTRS **********
********** Function: eicas_calculator3
# Machine code for function eicas_calculator3: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %eicas_calculator3.entry
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra<kill>; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
48B		SW %vreg0, %vreg1<kill>, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
64B		BLT <BB#4>, %vreg0<kill>, %zero; GR32Bit:%vreg0
80B		JAL <BB#1>
	    Successors according to CFG: BB#4(12) BB#1(20)

96B	BB#1: derived from LLVM BB %eicas_calculator3.if.else
	    Predecessors according to CFG: BB#0
112B		%vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
128B		%vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
144B		%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
160B		BLT <BB#3>, %vreg3<kill>, %vreg4<kill>; GR32Bit:%vreg3,%vreg4
176B		JAL <BB#2>
	    Successors according to CFG: BB#2(16) BB#3(16)

192B	BB#2: derived from LLVM BB %eicas_calculator3.if.then2
	    Predecessors according to CFG: BB#1
208B		%vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
224B		%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
240B		SW %vreg9<kill>, %vreg8<kill>, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
256B		JAL <BB#5>
	    Successors according to CFG: BB#5

272B	BB#3: derived from LLVM BB %eicas_calculator3.if.else3
	    Predecessors according to CFG: BB#1
288B		%vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
304B		%vreg6<def> = LW %vreg5<kill>, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
320B		%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
336B		SW %vreg6<kill>, %vreg7<kill>, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
352B		JAL <BB#5>
	    Successors according to CFG: BB#5

368B	BB#4: derived from LLVM BB %eicas_calculator3.if.then
	    Predecessors according to CFG: BB#0
384B		%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
400B		SW %zero, %vreg10<kill>, 0; mem:ST4[%3] GR32Bit:%vreg10
	    Successors according to CFG: BB#5

416B	BB#5: derived from LLVM BB %eicas_calculator3.return
	    Predecessors according to CFG: BB#3 BB#2 BB#4
432B		%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
448B		%vreg12<def> = LW %vreg11<kill>, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
464B		%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
480B		SW %vreg12<kill>, %vreg13<kill>, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13

# End machine code for function eicas_calculator3.

Computing live-in reg-units in ABI blocks.
0B	BB#0 ra#0
Created 1 new intervals.
********** INTERVALS **********
ra = [0B,16r:0)  0@0B-phi
%vreg0 = [16r,64r:0)  0@16r
%vreg1 = [32r,48r:0)  0@32r
%vreg2 = [112r,128r:0)  0@112r
%vreg3 = [128r,160r:0)  0@128r
%vreg4 = [144r,160r:0)  0@144r
%vreg5 = [288r,304r:0)  0@288r
%vreg6 = [304r,336r:0)  0@304r
%vreg7 = [320r,336r:0)  0@320r
%vreg8 = [208r,240r:0)  0@208r
%vreg9 = [224r,240r:0)  0@224r
%vreg10 = [384r,400r:0)  0@384r
%vreg11 = [432r,448r:0)  0@432r
%vreg12 = [448r,480r:0)  0@448r
%vreg13 = [464r,480r:0)  0@464r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function eicas_calculator3: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %eicas_calculator3.entry
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
48B		SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
64B		BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
80B		JAL <BB#1>
	    Successors according to CFG: BB#4(12) BB#1(20)

96B	BB#1: derived from LLVM BB %eicas_calculator3.if.else
	    Predecessors according to CFG: BB#0
112B		%vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
128B		%vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
144B		%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
160B		BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
176B		JAL <BB#2>
	    Successors according to CFG: BB#2(16) BB#3(16)

192B	BB#2: derived from LLVM BB %eicas_calculator3.if.then2
	    Predecessors according to CFG: BB#1
208B		%vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
224B		%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
240B		SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
256B		JAL <BB#5>
	    Successors according to CFG: BB#5

272B	BB#3: derived from LLVM BB %eicas_calculator3.if.else3
	    Predecessors according to CFG: BB#1
288B		%vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
304B		%vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
320B		%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
336B		SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
352B		JAL <BB#5>
	    Successors according to CFG: BB#5

368B	BB#4: derived from LLVM BB %eicas_calculator3.if.then
	    Predecessors according to CFG: BB#0
384B		%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
400B		SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
	    Successors according to CFG: BB#5

416B	BB#5: derived from LLVM BB %eicas_calculator3.return
	    Predecessors according to CFG: BB#3 BB#2 BB#4
432B		%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
448B		%vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
464B		%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
480B		SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13

# End machine code for function eicas_calculator3.

********** SIMPLE REGISTER COALESCING **********
********** Function: eicas_calculator3
********** JOINING INTERVALS ***********
eicas_calculator3.if.else:
eicas_calculator3.return:
eicas_calculator3.entry:
16B	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	Considering merging %vreg0 with %ra
	Can only merge into reserved registers.
eicas_calculator3.if.then2:
eicas_calculator3.if.else3:
eicas_calculator3.if.then:
Trying to inflate 0 regs.
********** INTERVALS **********
ra = [0B,16r:0)  0@0B-phi
%vreg0 = [16r,64r:0)  0@16r
%vreg1 = [32r,48r:0)  0@32r
%vreg2 = [112r,128r:0)  0@112r
%vreg3 = [128r,160r:0)  0@128r
%vreg4 = [144r,160r:0)  0@144r
%vreg5 = [288r,304r:0)  0@288r
%vreg6 = [304r,336r:0)  0@304r
%vreg7 = [320r,336r:0)  0@320r
%vreg8 = [208r,240r:0)  0@208r
%vreg9 = [224r,240r:0)  0@224r
%vreg10 = [384r,400r:0)  0@384r
%vreg11 = [432r,448r:0)  0@432r
%vreg12 = [448r,480r:0)  0@448r
%vreg13 = [464r,480r:0)  0@464r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function eicas_calculator3: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %eicas_calculator3.entry
	    Live Ins: %ra
16B		%vreg0<def> = COPY %ra; GR32Bit:%vreg0
32B		%vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
48B		SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
64B		BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
80B		JAL <BB#1>
	    Successors according to CFG: BB#4(12) BB#1(20)

96B	BB#1: derived from LLVM BB %eicas_calculator3.if.else
	    Predecessors according to CFG: BB#0
112B		%vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
128B		%vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
144B		%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
160B		BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
176B		JAL <BB#2>
	    Successors according to CFG: BB#2(16) BB#3(16)

192B	BB#2: derived from LLVM BB %eicas_calculator3.if.then2
	    Predecessors according to CFG: BB#1
208B		%vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
224B		%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
240B		SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
256B		JAL <BB#5>
	    Successors according to CFG: BB#5

272B	BB#3: derived from LLVM BB %eicas_calculator3.if.else3
	    Predecessors according to CFG: BB#1
288B		%vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
304B		%vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
320B		%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
336B		SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
352B		JAL <BB#5>
	    Successors according to CFG: BB#5

368B	BB#4: derived from LLVM BB %eicas_calculator3.if.then
	    Predecessors according to CFG: BB#0
384B		%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
400B		SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
	    Successors according to CFG: BB#5

416B	BB#5: derived from LLVM BB %eicas_calculator3.return
	    Predecessors according to CFG: BB#3 BB#2 BB#4
432B		%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
448B		%vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
464B		%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
480B		SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13

# End machine code for function eicas_calculator3.

Before MISched:
# Machine code for function eicas_calculator3: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

BB#0: derived from LLVM BB %eicas_calculator3.entry
    Live Ins: %ra
	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	%vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
	SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
	BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
	JAL <BB#1>
    Successors according to CFG: BB#4(12) BB#1(20)

BB#1: derived from LLVM BB %eicas_calculator3.if.else
    Predecessors according to CFG: BB#0
	%vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
	%vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
	%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
	BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
	JAL <BB#2>
    Successors according to CFG: BB#2(16) BB#3(16)

BB#2: derived from LLVM BB %eicas_calculator3.if.then2
    Predecessors according to CFG: BB#1
	%vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
	%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
	SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
	JAL <BB#5>
    Successors according to CFG: BB#5

BB#3: derived from LLVM BB %eicas_calculator3.if.else3
    Predecessors according to CFG: BB#1
	%vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
	%vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
	%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
	SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
	JAL <BB#5>
    Successors according to CFG: BB#5

BB#4: derived from LLVM BB %eicas_calculator3.if.then
    Predecessors according to CFG: BB#0
	%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
	SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
    Successors according to CFG: BB#5

BB#5: derived from LLVM BB %eicas_calculator3.return
    Predecessors according to CFG: BB#3 BB#2 BB#4
	%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
	%vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
	%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
	SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13

# End machine code for function eicas_calculator3.


-------------
Starting new basic block BB#0
********** MI Scheduling **********
eicas_calculator3:BB#0 eicas_calculator3.entry
  From: JAL <BB#1>
    To: JAL <BB#1>
 Remaining: 4
Max Pressure: Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 0
Excess PSets: 
0 subtrees:
*** Final schedule for BB#0 ***

Partitioning instructions of the region into multiple CEs

*** Renumbered SlotIndexes 92-108 ***

*** Renumbered SlotIndexes 104-136 ***

*** Renumbered SlotIndexes 116-156 ***

*** Renumbered SlotIndexes 128-184 ***

*** Renumbered SlotIndexes 140-204 ***
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
********** MI Scheduling **********
eicas_calculator3:BB#0 eicas_calculator3.entry
  From: %vreg0<def> = COPY %ra; GR32Bit:%vreg0
    To: BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
 Remaining: 0
Max Pressure: GR32Bit=2
Live In: %gp 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 2
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 0
SU(0):   %vreg0<def> = COPY %ra; GR32Bit:%vreg0
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   val SU(4294967295): Latency=0 Reg=%vreg0
   val SU(2): Latency=0 Reg=%vreg0

SU(1):   %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(2): Latency=5 Reg=%vreg1

SU(2):   SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 5
  Height             : 0
  Predecessors:
   val SU(0): Latency=0 Reg=%vreg0
   val SU(1): Latency=5 Reg=%vreg1
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg0<def> = COPY %ra; GR32Bit:%vreg0
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
  Successors:
   val SU(4294967295): Latency=0 Reg=%vreg0
   val SU(2): Latency=0 Reg=%vreg0

SU(1):   %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(2): Latency=5 Reg=%vreg1

SU(2):   SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 5
  Height             : 0
  Predecessors:
   val SU(0): Latency=0 Reg=%vreg0
   val SU(1): Latency=5 Reg=%vreg1
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(1)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
handleMove 32B -> 8B: %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
     %vreg1:	[32r,48r:0)  0@32r
        -->	[8r,48r:0)  0@8r
     t5:	EMPTY
        -->	EMPTY
Pick node SU(0)  ILP: 0 / 1 = 0 Tree: 0 @0
Scheduling %vreg0<def> = COPY %ra; GR32Bit:%vreg0
Pick node SU(2)  ILP: 2 / 6 = 0.333333 Tree: 0 @0
Scheduling SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
*** Final schedule for BB#0 ***
SU(1):   %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
SU(0):   %vreg0<def> = COPY %ra; GR32Bit:%vreg0
SU(2):   SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1


*** Renumbered SlotIndexes 4-28 ***

*** Renumbered SlotIndexes 16-56 ***

*** Renumbered SlotIndexes 28-76 ***

*** Renumbered SlotIndexes 40-280 ***

*** Renumbered SlotIndexes 52-300 ***

*** Renumbered SlotIndexes 64-328 ***

*** Renumbered SlotIndexes 76-348 ***

*** Renumbered SlotIndexes 88-376 ***

*** Renumbered SlotIndexes 100-396 ***

*** Renumbered SlotIndexes 112-424 ***

*** Renumbered SlotIndexes 124-444 ***

*** Renumbered SlotIndexes 136-472 ***

*** Renumbered SlotIndexes 148-492 ***

*** Renumbered SlotIndexes 160-512 ***

*** Renumbered SlotIndexes 172-524 ***

*** Renumbered SlotIndexes 184-536 ***

*** Renumbered SlotIndexes 196-548 ***

*** Renumbered SlotIndexes 208-560 ***

*** Renumbered SlotIndexes 220-572 ***

*** Renumbered SlotIndexes 232-584 ***

*** Renumbered SlotIndexes 244-596 ***

*** Renumbered SlotIndexes 256-608 ***

*** Renumbered SlotIndexes 268-620 ***

*** Renumbered SlotIndexes 280-632 ***

*** Renumbered SlotIndexes 292-644 ***

*** Renumbered SlotIndexes 304-656 ***

*** Renumbered SlotIndexes 316-668 ***

*** Renumbered SlotIndexes 328-680 ***

*** Renumbered SlotIndexes 340-692 ***

*** Renumbered SlotIndexes 352-704 ***

*** Renumbered SlotIndexes 364-716 ***

*** Renumbered SlotIndexes 376-728 ***

*** Renumbered SlotIndexes 388-740 ***

*** Renumbered SlotIndexes 400-752 ***
Partitioning instructions of the region into multiple CEs
instr:  %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
instr:  %vreg0<def> = COPY %ra; GR32Bit:%vreg0
instr:  SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1

*** Renumbered SlotIndexes 444-764 ***

*** Renumbered SlotIndexes 456-776 ***

*** Renumbered SlotIndexes 468-788 ***

*** Renumbered SlotIndexes 480-800 ***

*** Renumbered SlotIndexes 492-812 ***

*** Renumbered SlotIndexes 504-824 ***

*** Renumbered SlotIndexes 524-836 ***

*** Renumbered SlotIndexes 536-848 ***

*** Renumbered SlotIndexes 548-860 ***

*** Renumbered SlotIndexes 560-872 ***

*** Renumbered SlotIndexes 572-884 ***
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs

renaming register of operand that belongs to ce 1 but was defined in0
%vreg0<def>creating new replacement

renaming register of operand that belongs to ce 2 but was defined in0
%vreg0<def>creating new replacement

renaming register of operand that belongs to ce 3 but was defined in0
%vreg0<def>creating new replacement

renaming register of operand that belongs to ce 1 but was defined in0
%vreg0
renaming register of operand that belongs to ce 2 but was defined in0
%vreg0
renaming register of operand that belongs to ce 3 but was defined in0
%vreg0After Shuffling regions of basic block, state of BB#0:
BB#0: derived from LLVM BB %eicas_calculator3.entry
    Live Ins: %ra
	%vreg14<def> = ADD %t5, %zero; GR32Bit:%vreg14
	%vreg16<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg16
	%vreg17<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg17
	%vreg18<def> = SRLI %vreg17, 12; GR32Bit:%vreg18,%vreg17
	%vreg19<def> = ADD %vreg16, %vreg18; GR32Bit:%vreg19,%vreg16,%vreg18
	%vreg20<def> = ADDI %zero, 12; GR32Bit:%vreg20
	%vreg21<def> = SRLI %t5, 22; GR32Bit:%vreg21
	%vreg22<def> = SRLI %t5, 12; GR32Bit:%vreg22
	%vreg23<def> = ANDI %vreg22, 15; GR32Bit:%vreg23,%vreg22
	%vreg24<def> = SRLI %t5, 6; GR32Bit:%vreg24
	%vreg25<def> = ANDI %vreg24, 63; GR32Bit:%vreg25,%vreg24
	%vreg26<def> = ADDI %zero, 832; GR32Bit:%vreg26
	%vreg27<def> = MUL %vreg21, %vreg26; GR32Bit:%vreg27,%vreg21,%vreg26
	%vreg28<def> = ADDI %zero, 52; GR32Bit:%vreg28
	%vreg29<def> = MUL %vreg23, %vreg28; GR32Bit:%vreg29,%vreg23,%vreg28
	%vreg30<def> = ADD %vreg29, %vreg25; GR32Bit:%vreg30,%vreg29,%vreg25
	%vreg31<def> = ADD %vreg30, %vreg27; GR32Bit:%vreg31,%vreg30,%vreg27
	%vreg32<def> = MUL %vreg31, %vreg20; GR32Bit:%vreg32,%vreg31,%vreg20
	%vreg15<def> = ADD %vreg19, %vreg32; GR32Bit:%vreg15,%vreg19,%vreg32
	%vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
	%vreg0<def> = COPY %ra; GR32Bit:%vreg0
	SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
	%vreg90<def> = LUI 1; GR32Bit:%vreg90
	WRITEPM %vreg90, %vreg0, 0; GR32Bit:%vreg90,%vreg0
	%vreg92<def> = LUI 2; GR32Bit:%vreg92
	WRITEPM %vreg92, %vreg0, 0; GR32Bit:%vreg92,%vreg0
	%vreg94<def> = LUI 3; GR32Bit:%vreg94
	WRITEPM %vreg94, %vreg0, 0; GR32Bit:%vreg94,%vreg0
	BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#1>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg33<def> = ADD %t5, %zero; GR32Bit:%vreg33
	%vreg35<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg35
	%vreg36<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg36
	%vreg37<def> = SRLI %vreg36, 12; GR32Bit:%vreg37,%vreg36
	%vreg38<def> = ADD %vreg35, %vreg37; GR32Bit:%vreg38,%vreg35,%vreg37
	%vreg39<def> = ADDI %zero, 12; GR32Bit:%vreg39
	%vreg40<def> = SRLI %t5, 22; GR32Bit:%vreg40
	%vreg41<def> = SRLI %t5, 12; GR32Bit:%vreg41
	%vreg42<def> = ANDI %vreg41, 15; GR32Bit:%vreg42,%vreg41
	%vreg43<def> = SRLI %t5, 6; GR32Bit:%vreg43
	%vreg44<def> = ANDI %vreg43, 63; GR32Bit:%vreg44,%vreg43
	%vreg45<def> = ADDI %zero, 832; GR32Bit:%vreg45
	%vreg46<def> = MUL %vreg40, %vreg45; GR32Bit:%vreg46,%vreg40,%vreg45
	%vreg47<def> = ADDI %zero, 52; GR32Bit:%vreg47
	%vreg48<def> = MUL %vreg42, %vreg47; GR32Bit:%vreg48,%vreg42,%vreg47
	%vreg49<def> = ADD %vreg48, %vreg44; GR32Bit:%vreg49,%vreg48,%vreg44
	%vreg50<def> = ADD %vreg49, %vreg46; GR32Bit:%vreg50,%vreg49,%vreg46
	%vreg51<def> = MUL %vreg50, %vreg39; GR32Bit:%vreg51,%vreg50,%vreg39
	%vreg34<def> = ADD %vreg38, %vreg51; GR32Bit:%vreg34,%vreg38,%vreg51
	%vreg91<def> = LUI 1; GR32Bit:%vreg91
	%vreg96<def> = DREADPM %vreg91, 0; GR32Bit:%vreg96,%vreg91
	BLT <BB#4>, %vreg96, %zero; GR32Bit:%vreg96
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#1>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg52<def> = ADD %t5, %zero; GR32Bit:%vreg52
	%vreg54<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg54
	%vreg55<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg55
	%vreg56<def> = SRLI %vreg55, 12; GR32Bit:%vreg56,%vreg55
	%vreg57<def> = ADD %vreg54, %vreg56; GR32Bit:%vreg57,%vreg54,%vreg56
	%vreg58<def> = ADDI %zero, 12; GR32Bit:%vreg58
	%vreg59<def> = SRLI %t5, 22; GR32Bit:%vreg59
	%vreg60<def> = SRLI %t5, 12; GR32Bit:%vreg60
	%vreg61<def> = ANDI %vreg60, 15; GR32Bit:%vreg61,%vreg60
	%vreg62<def> = SRLI %t5, 6; GR32Bit:%vreg62
	%vreg63<def> = ANDI %vreg62, 63; GR32Bit:%vreg63,%vreg62
	%vreg64<def> = ADDI %zero, 832; GR32Bit:%vreg64
	%vreg65<def> = MUL %vreg59, %vreg64; GR32Bit:%vreg65,%vreg59,%vreg64
	%vreg66<def> = ADDI %zero, 52; GR32Bit:%vreg66
	%vreg67<def> = MUL %vreg61, %vreg66; GR32Bit:%vreg67,%vreg61,%vreg66
	%vreg68<def> = ADD %vreg67, %vreg63; GR32Bit:%vreg68,%vreg67,%vreg63
	%vreg69<def> = ADD %vreg68, %vreg65; GR32Bit:%vreg69,%vreg68,%vreg65
	%vreg70<def> = MUL %vreg69, %vreg58; GR32Bit:%vreg70,%vreg69,%vreg58
	%vreg53<def> = ADD %vreg57, %vreg70; GR32Bit:%vreg53,%vreg57,%vreg70
	%vreg93<def> = LUI 2; GR32Bit:%vreg93
	%vreg97<def> = DREADPM %vreg93, 0; GR32Bit:%vreg97,%vreg93
	BLT <BB#4>, %vreg97, %zero; GR32Bit:%vreg97
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#1>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg71<def> = ADD %t5, %zero; GR32Bit:%vreg71
	%vreg73<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg73
	%vreg74<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg74
	%vreg75<def> = SRLI %vreg74, 12; GR32Bit:%vreg75,%vreg74
	%vreg76<def> = ADD %vreg73, %vreg75; GR32Bit:%vreg76,%vreg73,%vreg75
	%vreg77<def> = ADDI %zero, 12; GR32Bit:%vreg77
	%vreg78<def> = SRLI %t5, 22; GR32Bit:%vreg78
	%vreg79<def> = SRLI %t5, 12; GR32Bit:%vreg79
	%vreg80<def> = ANDI %vreg79, 15; GR32Bit:%vreg80,%vreg79
	%vreg81<def> = SRLI %t5, 6; GR32Bit:%vreg81
	%vreg82<def> = ANDI %vreg81, 63; GR32Bit:%vreg82,%vreg81
	%vreg83<def> = ADDI %zero, 832; GR32Bit:%vreg83
	%vreg84<def> = MUL %vreg78, %vreg83; GR32Bit:%vreg84,%vreg78,%vreg83
	%vreg85<def> = ADDI %zero, 52; GR32Bit:%vreg85
	%vreg86<def> = MUL %vreg80, %vreg85; GR32Bit:%vreg86,%vreg80,%vreg85
	%vreg87<def> = ADD %vreg86, %vreg82; GR32Bit:%vreg87,%vreg86,%vreg82
	%vreg88<def> = ADD %vreg87, %vreg84; GR32Bit:%vreg88,%vreg87,%vreg84
	%vreg89<def> = MUL %vreg88, %vreg77; GR32Bit:%vreg89,%vreg88,%vreg77
	%vreg72<def> = ADD %vreg76, %vreg89; GR32Bit:%vreg72,%vreg76,%vreg89
	%vreg95<def> = LUI 3; GR32Bit:%vreg95
	%vreg98<def> = DREADPM %vreg95, 0; GR32Bit:%vreg98,%vreg95
	BLT <BB#4>, %vreg98, %zero; GR32Bit:%vreg98
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#1>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#4(12) BB#1(20)

*** Renumbered SlotIndexes 316-980 ***

*** Renumbered SlotIndexes 304-1000 ***

*** Renumbered SlotIndexes 304-1016 ***

*** Renumbered SlotIndexes 304-1032 ***

*** Renumbered SlotIndexes 304-1048 ***

*** Renumbered SlotIndexes 216-1088 ***

*** Renumbered SlotIndexes 204-1108 ***

*** Renumbered SlotIndexes 204-1124 ***

*** Renumbered SlotIndexes 204-1140 ***

*** Renumbered SlotIndexes 204-1156 ***

*** Renumbered SlotIndexes 112-1208 ***

*** Renumbered SlotIndexes 100-1228 ***

*** Renumbered SlotIndexes 100-1244 ***

*** Renumbered SlotIndexes 100-1260 ***

*** Renumbered SlotIndexes 100-1276 ***

*** Renumbered SlotIndexes 100-1292 ***

*** Renumbered SlotIndexes 100-1308 ***

*** Renumbered SlotIndexes 100-1324 ***

*** Renumbered SlotIndexes 12-1372 ***
Creating pHyperOp bundles for CEs for bb0
  %vreg33<def> = ADD %t5, %zero; GR32Bit:%vreg33
starting at   %vreg14<def> = ADD %t5, %zero; GR32Bit:%vreg14
  %vreg52<def> = ADD %t5, %zero; GR32Bit:%vreg52
starting at   %vreg33<def> = ADD %t5, %zero; GR32Bit:%vreg33
  %vreg71<def> = ADD %t5, %zero; GR32Bit:%vreg71
starting at   %vreg52<def> = ADD %t5, %zero; GR32Bit:%vreg52
starting at   %vreg71<def> = ADD %t5, %zero; GR32Bit:%vreg71
After bundling, state of BB0:BB#0: derived from LLVM BB %eicas_calculator3.entry
    Live Ins: %ra
	%vreg14<def> = ADD %t5, %zero; GR32Bit:%vreg14
	  * %vreg16<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg16
	  * %vreg17<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg17
	  * %vreg18<def> = SRLI %vreg17, 12; GR32Bit:%vreg18,%vreg17
	  * %vreg19<def> = ADD %vreg16, %vreg18; GR32Bit:%vreg19,%vreg16,%vreg18
	  * %vreg20<def> = ADDI %zero, 12; GR32Bit:%vreg20
	  * %vreg21<def> = SRLI %t5, 22; GR32Bit:%vreg21
	  * %vreg22<def> = SRLI %t5, 12; GR32Bit:%vreg22
	  * %vreg23<def> = ANDI %vreg22, 15; GR32Bit:%vreg23,%vreg22
	  * %vreg24<def> = SRLI %t5, 6; GR32Bit:%vreg24
	  * %vreg25<def> = ANDI %vreg24, 63; GR32Bit:%vreg25,%vreg24
	  * %vreg26<def> = ADDI %zero, 832; GR32Bit:%vreg26
	  * %vreg27<def> = MUL %vreg21, %vreg26; GR32Bit:%vreg27,%vreg21,%vreg26
	  * %vreg28<def> = ADDI %zero, 52; GR32Bit:%vreg28
	  * %vreg29<def> = MUL %vreg23, %vreg28; GR32Bit:%vreg29,%vreg23,%vreg28
	  * %vreg30<def> = ADD %vreg29, %vreg25; GR32Bit:%vreg30,%vreg29,%vreg25
	  * %vreg31<def> = ADD %vreg30, %vreg27; GR32Bit:%vreg31,%vreg30,%vreg27
	  * %vreg32<def> = MUL %vreg31, %vreg20; GR32Bit:%vreg32,%vreg31,%vreg20
	  * %vreg15<def> = ADD %vreg19, %vreg32; GR32Bit:%vreg15,%vreg19,%vreg32
	  * %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
	  * %vreg0<def> = COPY %ra; GR32Bit:%vreg0
	  * SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
	  * %vreg90<def> = LUI 1; GR32Bit:%vreg90
	  * WRITEPM %vreg90, %vreg0, 0; GR32Bit:%vreg90,%vreg0
	  * %vreg92<def> = LUI 2; GR32Bit:%vreg92
	  * WRITEPM %vreg92, %vreg0, 0; GR32Bit:%vreg92,%vreg0
	  * %vreg94<def> = LUI 3; GR32Bit:%vreg94
	  * WRITEPM %vreg94, %vreg0, 0; GR32Bit:%vreg94,%vreg0
	  * BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg33<def> = ADD %t5, %zero; GR32Bit:%vreg33
	  * %vreg35<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg35
	  * %vreg36<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg36
	  * %vreg37<def> = SRLI %vreg36, 12; GR32Bit:%vreg37,%vreg36
	  * %vreg38<def> = ADD %vreg35, %vreg37; GR32Bit:%vreg38,%vreg35,%vreg37
	  * %vreg39<def> = ADDI %zero, 12; GR32Bit:%vreg39
	  * %vreg40<def> = SRLI %t5, 22; GR32Bit:%vreg40
	  * %vreg41<def> = SRLI %t5, 12; GR32Bit:%vreg41
	  * %vreg42<def> = ANDI %vreg41, 15; GR32Bit:%vreg42,%vreg41
	  * %vreg43<def> = SRLI %t5, 6; GR32Bit:%vreg43
	  * %vreg44<def> = ANDI %vreg43, 63; GR32Bit:%vreg44,%vreg43
	  * %vreg45<def> = ADDI %zero, 832; GR32Bit:%vreg45
	  * %vreg46<def> = MUL %vreg40, %vreg45; GR32Bit:%vreg46,%vreg40,%vreg45
	  * %vreg47<def> = ADDI %zero, 52; GR32Bit:%vreg47
	  * %vreg48<def> = MUL %vreg42, %vreg47; GR32Bit:%vreg48,%vreg42,%vreg47
	  * %vreg49<def> = ADD %vreg48, %vreg44; GR32Bit:%vreg49,%vreg48,%vreg44
	  * %vreg50<def> = ADD %vreg49, %vreg46; GR32Bit:%vreg50,%vreg49,%vreg46
	  * %vreg51<def> = MUL %vreg50, %vreg39; GR32Bit:%vreg51,%vreg50,%vreg39
	  * %vreg34<def> = ADD %vreg38, %vreg51; GR32Bit:%vreg34,%vreg38,%vreg51
	  * %vreg91<def> = LUI 1; GR32Bit:%vreg91
	  * %vreg96<def> = DREADPM %vreg91, 0; GR32Bit:%vreg96,%vreg91
	  * BLT <BB#4>, %vreg96, %zero; GR32Bit:%vreg96
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg52<def> = ADD %t5, %zero; GR32Bit:%vreg52
	  * %vreg54<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg54
	  * %vreg55<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg55
	  * %vreg56<def> = SRLI %vreg55, 12; GR32Bit:%vreg56,%vreg55
	  * %vreg57<def> = ADD %vreg54, %vreg56; GR32Bit:%vreg57,%vreg54,%vreg56
	  * %vreg58<def> = ADDI %zero, 12; GR32Bit:%vreg58
	  * %vreg59<def> = SRLI %t5, 22; GR32Bit:%vreg59
	  * %vreg60<def> = SRLI %t5, 12; GR32Bit:%vreg60
	  * %vreg61<def> = ANDI %vreg60, 15; GR32Bit:%vreg61,%vreg60
	  * %vreg62<def> = SRLI %t5, 6; GR32Bit:%vreg62
	  * %vreg63<def> = ANDI %vreg62, 63; GR32Bit:%vreg63,%vreg62
	  * %vreg64<def> = ADDI %zero, 832; GR32Bit:%vreg64
	  * %vreg65<def> = MUL %vreg59, %vreg64; GR32Bit:%vreg65,%vreg59,%vreg64
	  * %vreg66<def> = ADDI %zero, 52; GR32Bit:%vreg66
	  * %vreg67<def> = MUL %vreg61, %vreg66; GR32Bit:%vreg67,%vreg61,%vreg66
	  * %vreg68<def> = ADD %vreg67, %vreg63; GR32Bit:%vreg68,%vreg67,%vreg63
	  * %vreg69<def> = ADD %vreg68, %vreg65; GR32Bit:%vreg69,%vreg68,%vreg65
	  * %vreg70<def> = MUL %vreg69, %vreg58; GR32Bit:%vreg70,%vreg69,%vreg58
	  * %vreg53<def> = ADD %vreg57, %vreg70; GR32Bit:%vreg53,%vreg57,%vreg70
	  * %vreg93<def> = LUI 2; GR32Bit:%vreg93
	  * %vreg97<def> = DREADPM %vreg93, 0; GR32Bit:%vreg97,%vreg93
	  * BLT <BB#4>, %vreg97, %zero; GR32Bit:%vreg97
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg71<def> = ADD %t5, %zero; GR32Bit:%vreg71
	  * %vreg73<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg73
	  * %vreg74<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg74
	  * %vreg75<def> = SRLI %vreg74, 12; GR32Bit:%vreg75,%vreg74
	  * %vreg76<def> = ADD %vreg73, %vreg75; GR32Bit:%vreg76,%vreg73,%vreg75
	  * %vreg77<def> = ADDI %zero, 12; GR32Bit:%vreg77
	  * %vreg78<def> = SRLI %t5, 22; GR32Bit:%vreg78
	  * %vreg79<def> = SRLI %t5, 12; GR32Bit:%vreg79
	  * %vreg80<def> = ANDI %vreg79, 15; GR32Bit:%vreg80,%vreg79
	  * %vreg81<def> = SRLI %t5, 6; GR32Bit:%vreg81
	  * %vreg82<def> = ANDI %vreg81, 63; GR32Bit:%vreg82,%vreg81
	  * %vreg83<def> = ADDI %zero, 832; GR32Bit:%vreg83
	  * %vreg84<def> = MUL %vreg78, %vreg83; GR32Bit:%vreg84,%vreg78,%vreg83
	  * %vreg85<def> = ADDI %zero, 52; GR32Bit:%vreg85
	  * %vreg86<def> = MUL %vreg80, %vreg85; GR32Bit:%vreg86,%vreg80,%vreg85
	  * %vreg87<def> = ADD %vreg86, %vreg82; GR32Bit:%vreg87,%vreg86,%vreg82
	  * %vreg88<def> = ADD %vreg87, %vreg84; GR32Bit:%vreg88,%vreg87,%vreg84
	  * %vreg89<def> = MUL %vreg88, %vreg77; GR32Bit:%vreg89,%vreg88,%vreg77
	  * %vreg72<def> = ADD %vreg76, %vreg89; GR32Bit:%vreg72,%vreg76,%vreg89
	  * %vreg95<def> = LUI 3; GR32Bit:%vreg95
	  * %vreg98<def> = DREADPM %vreg95, 0; GR32Bit:%vreg98,%vreg95
	  * BLT <BB#4>, %vreg98, %zero; GR32Bit:%vreg98
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#4(12) BB#1(20)

-------------
Starting new basic block BB#1
********** MI Scheduling **********
eicas_calculator3:BB#1 eicas_calculator3.if.else
  From: JAL <BB#2>
    To: JAL <BB#2>
 Remaining: 4
Max Pressure: Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 0
Excess PSets: 
0 subtrees:
*** Final schedule for BB#1 ***

Partitioning instructions of the region into multiple CEs

*** Renumbered SlotIndexes 1216-1384 ***

*** Renumbered SlotIndexes 1228-1396 ***

*** Renumbered SlotIndexes 1240-1408 ***

*** Renumbered SlotIndexes 1252-1420 ***

*** Renumbered SlotIndexes 1264-1432 ***
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
********** MI Scheduling **********
eicas_calculator3:BB#1 eicas_calculator3.if.else
  From: %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
    To: BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
 Remaining: 0
Max Pressure: GR32Bit=2
Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 2
Excess PSets: 
2 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 1
SU(0):   %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 20
  Successors:
   val SU(1): Latency=5 Reg=%vreg2

SU(1):   %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 5
  Height             : 15
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg2
  Successors:
   val SU(4294967295): Latency=15 Reg=%vreg3

SU(2):   %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(4294967295): Latency=5 Reg=%vreg4

SU(0):   %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 20
  Successors:
   val SU(1): Latency=5 Reg=%vreg2

SU(1):   %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 14
  Depth              : 5
  Height             : 15
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg2
  Successors:
   val SU(4294967295): Latency=15 Reg=%vreg3

SU(2):   %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(4294967295): Latency=5 Reg=%vreg4

Pick node SU(2)  ILP: 1 / 1 = 1 Tree: 1 @0
Scheduling %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
handleMove 1196B -> 1176B: %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
     %vreg4:	[1196r,1204r:0)  0@1196r
        -->	[1176r,1204r:0)  0@1176r
     zero:	[4r,4d:11)[268r,268d:10)[484r,484d:9)[700r,700d:8)[1236r,1236d:7)[1240r,1240d:6)[1248r,1248d:5)[1252r,1252d:4)[1260r,1260d:3)[1264r,1264d:2)[1272r,1272d:1)[1276r,1276d:0)  0@1276r 1@1272r 2@1264r 3@1260r 4@1252r 5@1248r 6@1240r 7@1236r 8@700r 9@484r 10@268r 11@4r
        -->	[4r,4d:11)[268r,268d:10)[484r,484d:9)[700r,700d:8)[1236r,1236d:7)[1240r,1240d:6)[1248r,1248d:5)[1252r,1252d:4)[1260r,1260d:3)[1264r,1264d:2)[1272r,1272d:1)[1276r,1276d:0)  0@1276r 1@1272r 2@1264r 3@1260r 4@1252r 5@1248r 6@1240r 7@1236r 8@700r 9@484r 10@268r 11@4r
Pick node SU(0)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
Pick node SU(1)  ILP: 2 / 6 = 0.333333 Tree: 0 @0
Scheduling %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
*** Final schedule for BB#1 ***
SU(2):   %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
SU(0):   %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
SU(1):   %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2

Partitioning instructions of the region into multiple CEs
instr:  %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
instr:  %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
instr:  %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2

*** Renumbered SlotIndexes 1192-1472 ***

*** Renumbered SlotIndexes 1204-1484 ***

*** Renumbered SlotIndexes 1216-1496 ***

*** Renumbered SlotIndexes 1228-1508 ***

*** Renumbered SlotIndexes 1240-1520 ***

*** Renumbered SlotIndexes 1252-1532 ***

*** Renumbered SlotIndexes 1264-1544 ***

*** Renumbered SlotIndexes 1276-1556 ***

*** Renumbered SlotIndexes 1288-1568 ***

*** Renumbered SlotIndexes 1316-1580 ***

*** Renumbered SlotIndexes 1328-1592 ***

*** Renumbered SlotIndexes 1340-1604 ***

*** Renumbered SlotIndexes 1352-1616 ***

*** Renumbered SlotIndexes 1364-1628 ***
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs

renaming register of operand that belongs to ce 1 but was defined in0
%vreg3<def>creating new replacement

renaming register of operand that belongs to ce 2 but was defined in0
%vreg3<def>creating new replacement

renaming register of operand that belongs to ce 3 but was defined in0
%vreg3<def>creating new replacement

renaming register of operand that belongs to ce 1 but was defined in0
%vreg4<def>creating new replacement

renaming register of operand that belongs to ce 2 but was defined in0
%vreg4<def>creating new replacement

renaming register of operand that belongs to ce 3 but was defined in0
%vreg4<def>creating new replacement

renaming register of operand that belongs to ce 1 but was defined in0
%vreg3
renaming register of operand that belongs to ce 1 but was defined in0
%vreg4
renaming register of operand that belongs to ce 2 but was defined in0
%vreg3
renaming register of operand that belongs to ce 2 but was defined in0
%vreg4
renaming register of operand that belongs to ce 3 but was defined in0
%vreg3
renaming register of operand that belongs to ce 3 but was defined in0
%vreg4After Shuffling regions of basic block, state of BB#1:
BB#1: derived from LLVM BB %eicas_calculator3.if.else
    Predecessors according to CFG: BB#0
	%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
	%vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
	%vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
	%vreg99<def> = LUI 1; GR32Bit:%vreg99
	WRITEPM %vreg99, %vreg3, 0; GR32Bit:%vreg99,%vreg3
	%vreg101<def> = LUI 2; GR32Bit:%vreg101
	WRITEPM %vreg101, %vreg3, 0; GR32Bit:%vreg101,%vreg3
	%vreg103<def> = LUI 3; GR32Bit:%vreg103
	WRITEPM %vreg103, %vreg3, 0; GR32Bit:%vreg103,%vreg3
	WRITEPM %vreg99, %vreg4, 4; GR32Bit:%vreg99,%vreg4
	WRITEPM %vreg101, %vreg4, 4; GR32Bit:%vreg101,%vreg4
	WRITEPM %vreg103, %vreg4, 4; GR32Bit:%vreg103,%vreg4
	BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#2>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg100<def> = LUI 1; GR32Bit:%vreg100
	%vreg105<def> = DREADPM %vreg100, 0; GR32Bit:%vreg105,%vreg100
	%vreg108<def> = DREADPM %vreg100, 4; GR32Bit:%vreg108,%vreg100
	BLT <BB#3>, %vreg105, %vreg108; GR32Bit:%vreg105,%vreg108
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#2>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg102<def> = LUI 2; GR32Bit:%vreg102
	%vreg106<def> = DREADPM %vreg102, 0; GR32Bit:%vreg106,%vreg102
	%vreg109<def> = DREADPM %vreg102, 4; GR32Bit:%vreg109,%vreg102
	BLT <BB#3>, %vreg106, %vreg109; GR32Bit:%vreg106,%vreg109
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#2>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%vreg104<def> = LUI 3; GR32Bit:%vreg104
	%vreg107<def> = DREADPM %vreg104, 0; GR32Bit:%vreg107,%vreg104
	%vreg110<def> = DREADPM %vreg104, 4; GR32Bit:%vreg110,%vreg104
	BLT <BB#3>, %vreg107, %vreg110; GR32Bit:%vreg107,%vreg110
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#2>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#2(16) BB#3(16)

*** Renumbered SlotIndexes 1236-1684 ***

*** Renumbered SlotIndexes 1236-1700 ***

*** Renumbered SlotIndexes 1236-1716 ***

*** Renumbered SlotIndexes 1236-1732 ***

*** Renumbered SlotIndexes 1212-1748 ***

*** Renumbered SlotIndexes 1212-1764 ***

*** Renumbered SlotIndexes 1212-1780 ***

*** Renumbered SlotIndexes 1212-1796 ***

*** Renumbered SlotIndexes 1192-1816 ***

*** Renumbered SlotIndexes 1192-1832 ***

*** Renumbered SlotIndexes 1192-1848 ***

*** Renumbered SlotIndexes 1192-1864 ***

*** Renumbered SlotIndexes 1192-1880 ***

*** Renumbered SlotIndexes 1192-1896 ***

*** Renumbered SlotIndexes 1192-1912 ***
Creating pHyperOp bundles for CEs for bb1
  %vreg100<def> = LUI 1; GR32Bit:%vreg100
starting at   %vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
  %vreg102<def> = LUI 2; GR32Bit:%vreg102
starting at   %vreg100<def> = LUI 1; GR32Bit:%vreg100
  %vreg104<def> = LUI 3; GR32Bit:%vreg104
starting at   %vreg102<def> = LUI 2; GR32Bit:%vreg102
starting at   %vreg104<def> = LUI 3; GR32Bit:%vreg104
After bundling, state of BB1:BB#1: derived from LLVM BB %eicas_calculator3.if.else
    Predecessors according to CFG: BB#0
	%vreg4<def> = ADDI %zero, 65536; GR32Bit:%vreg4
	  * %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
	  * %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
	  * %vreg99<def> = LUI 1; GR32Bit:%vreg99
	  * WRITEPM %vreg99, %vreg3, 0; GR32Bit:%vreg99,%vreg3
	  * %vreg101<def> = LUI 2; GR32Bit:%vreg101
	  * WRITEPM %vreg101, %vreg3, 0; GR32Bit:%vreg101,%vreg3
	  * %vreg103<def> = LUI 3; GR32Bit:%vreg103
	  * WRITEPM %vreg103, %vreg3, 0; GR32Bit:%vreg103,%vreg3
	  * WRITEPM %vreg99, %vreg4, 4; GR32Bit:%vreg99,%vreg4
	  * WRITEPM %vreg101, %vreg4, 4; GR32Bit:%vreg101,%vreg4
	  * WRITEPM %vreg103, %vreg4, 4; GR32Bit:%vreg103,%vreg4
	  * BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg100<def> = LUI 1; GR32Bit:%vreg100
	  * %vreg105<def> = DREADPM %vreg100, 0; GR32Bit:%vreg105,%vreg100
	  * %vreg108<def> = DREADPM %vreg100, 4; GR32Bit:%vreg108,%vreg100
	  * BLT <BB#3>, %vreg105, %vreg108; GR32Bit:%vreg105,%vreg108
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg102<def> = LUI 2; GR32Bit:%vreg102
	  * %vreg106<def> = DREADPM %vreg102, 0; GR32Bit:%vreg106,%vreg102
	  * %vreg109<def> = DREADPM %vreg102, 4; GR32Bit:%vreg109,%vreg102
	  * BLT <BB#3>, %vreg106, %vreg109; GR32Bit:%vreg106,%vreg109
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%vreg104<def> = LUI 3; GR32Bit:%vreg104
	  * %vreg107<def> = DREADPM %vreg104, 0; GR32Bit:%vreg107,%vreg104
	  * %vreg110<def> = DREADPM %vreg104, 4; GR32Bit:%vreg110,%vreg104
	  * BLT <BB#3>, %vreg107, %vreg110; GR32Bit:%vreg107,%vreg110
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#2(16) BB#3(16)

-------------
Starting new basic block BB#2
********** MI Scheduling **********
eicas_calculator3:BB#2 eicas_calculator3.if.then2
  From: %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
    To: JAL <BB#5>
 Remaining: 0
Max Pressure: GR32Bit=2
Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 2
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 0
SU(0):   %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(2): Latency=5 Reg=%vreg8

SU(1):   %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
   val SU(2): Latency=4 Reg=%vreg9

SU(2):   SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 5
  Height             : 0
  Predecessors:
   val SU(1): Latency=4 Reg=%vreg9
   val SU(0): Latency=5 Reg=%vreg8
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(2): Latency=5 Reg=%vreg8

SU(1):   %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 4
  Successors:
   val SU(2): Latency=4 Reg=%vreg9

SU(2):   SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 5
  Height             : 0
  Predecessors:
   val SU(1): Latency=4 Reg=%vreg9
   val SU(0): Latency=5 Reg=%vreg8
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(1)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
handleMove 1776B -> 1764B: %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
     %vreg9:	[1776r,1784r:0)  0@1776r
        -->	[1764r,1784r:0)  0@1764r
     zero:	[4r,4d:11)[268r,268d:10)[484r,484d:9)[700r,700d:8)[1696r,1696d:7)[1704r,1704d:6)[1712r,1712d:5)[1720r,1720d:4)[1728r,1728d:3)[1736r,1736d:2)[1744r,1744d:1)[1752r,1752d:0)  0@1752r 1@1744r 2@1736r 3@1728r 4@1720r 5@1712r 6@1704r 7@1696r 8@700r 9@484r 10@268r 11@4r
        -->	[4r,4d:11)[268r,268d:10)[484r,484d:9)[700r,700d:8)[1696r,1696d:7)[1704r,1704d:6)[1712r,1712d:5)[1720r,1720d:4)[1728r,1728d:3)[1736r,1736d:2)[1744r,1744d:1)[1752r,1752d:0)  0@1752r 1@1744r 2@1736r 3@1728r 4@1720r 5@1712r 6@1704r 7@1696r 8@700r 9@484r 10@268r 11@4r
Pick node SU(0)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
Pick node SU(2)  ILP: 3 / 6 = 0.5 Tree: 0 @0
Scheduling SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
*** Final schedule for BB#2 ***
SU(1):   %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
SU(0):   %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
SU(2):   SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8

Partitioning instructions of the region into multiple CEs
instr:  %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
instr:  %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
instr:  SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8

*** Renumbered SlotIndexes 1796-1924 ***

*** Renumbered SlotIndexes 1808-1936 ***

*** Renumbered SlotIndexes 1820-1948 ***

*** Renumbered SlotIndexes 1832-1960 ***

*** Renumbered SlotIndexes 1844-1972 ***
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
After Shuffling regions of basic block, state of BB#2:
BB#2: derived from LLVM BB %eicas_calculator3.if.then2
    Predecessors according to CFG: BB#1
	%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
	%vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
	SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

*** Renumbered SlotIndexes 1804-2004 ***

*** Renumbered SlotIndexes 1796-2028 ***

*** Renumbered SlotIndexes 1792-2040 ***
Creating pHyperOp bundles for CEs for bb2
  JAL <BB#5>
starting at   %vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
  JAL <BB#5>
starting at   JAL <BB#5>
  JAL <BB#5>
starting at   JAL <BB#5>
starting at   JAL <BB#5>
After bundling, state of BB2:BB#2: derived from LLVM BB %eicas_calculator3.if.then2
    Predecessors according to CFG: BB#1
	%vreg9<def> = ADDI %zero, 65535; GR32Bit:%vreg9
	  * %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
	  * SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
	  * JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

-------------
Starting new basic block BB#3
********** MI Scheduling **********
eicas_calculator3:BB#3 eicas_calculator3.if.else3
  From: %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
    To: JAL <BB#5>
 Remaining: 0
Max Pressure: GR32Bit=2
Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 2
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 0
  SU(3) in tree 0
SU(0):   %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 7
  Successors:
   val SU(1): Latency=5 Reg=%vreg5

SU(1):   %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 5
  Height             : 2
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg5
  Successors:
   val SU(3): Latency=2 Reg=%vreg6

SU(2):   %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(3): Latency=5 Reg=%vreg7

SU(3):   SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 7
  Height             : 0
  Predecessors:
   val SU(1): Latency=2 Reg=%vreg6
   val SU(2): Latency=5 Reg=%vreg7
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 7
  Successors:
   val SU(1): Latency=5 Reg=%vreg5

SU(1):   %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 5
  Height             : 2
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg5
  Successors:
   val SU(3): Latency=2 Reg=%vreg6

SU(2):   %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(3): Latency=5 Reg=%vreg7

SU(3):   SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 7
  Height             : 0
  Predecessors:
   val SU(1): Latency=2 Reg=%vreg6
   val SU(2): Latency=5 Reg=%vreg7
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(2)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
handleMove 1952B -> 1932B: %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
     %vreg7:	[1952r,1960r:0)  0@1952r
        -->	[1932r,1960r:0)  0@1932r
     t5:	EMPTY
        -->	EMPTY
Pick node SU(0)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
Pick node SU(1)  ILP: 2 / 6 = 0.333333 Tree: 0 @0
Scheduling %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
Pick node SU(3)  ILP: 4 / 8 = 0.5 Tree: 0 @0
Scheduling SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
*** Final schedule for BB#3 ***
SU(2):   %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
SU(0):   %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
SU(1):   %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
SU(3):   SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7

Partitioning instructions of the region into multiple CEs
instr:  %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
instr:  %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
instr:  %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
instr:  SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7

*** Renumbered SlotIndexes 1972-2052 ***

*** Renumbered SlotIndexes 1984-2064 ***

*** Renumbered SlotIndexes 1996-2076 ***

*** Renumbered SlotIndexes 2008-2088 ***

*** Renumbered SlotIndexes 2020-2100 ***
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
After Shuffling regions of basic block, state of BB#3:
BB#3: derived from LLVM BB %eicas_calculator3.if.else3
    Predecessors according to CFG: BB#1
	%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
	%vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
	%vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
	SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	JAL <BB#5>
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

*** Renumbered SlotIndexes 1980-2132 ***

*** Renumbered SlotIndexes 1972-2156 ***

*** Renumbered SlotIndexes 1968-2168 ***
Creating pHyperOp bundles for CEs for bb3
  JAL <BB#5>
starting at   %vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
  JAL <BB#5>
starting at   JAL <BB#5>
  JAL <BB#5>
starting at   JAL <BB#5>
starting at   JAL <BB#5>
After bundling, state of BB3:BB#3: derived from LLVM BB %eicas_calculator3.if.else3
    Predecessors according to CFG: BB#1
	%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
	  * %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
	  * %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
	  * SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
	  * JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

-------------
Starting new basic block BB#4
********** MI Scheduling **********
eicas_calculator3:BB#4 eicas_calculator3.if.then
  From: %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
    To: End Remaining: 0
Max Pressure: GR32Bit=1
Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 1
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
SU(0):   %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(1): Latency=5 Reg=%vreg10

SU(1):   SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 5
  Height             : 0
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg10
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(1): Latency=5 Reg=%vreg10

SU(1):   SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 5
  Height             : 0
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg10
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(0)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
Pick node SU(1)  ILP: 2 / 6 = 0.333333 Tree: 0 @0
Scheduling SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
*** Final schedule for BB#4 ***
SU(0):   %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
SU(1):   SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10

Partitioning instructions of the region into multiple CEs
instr:  %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
instr:  SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
After Shuffling regions of basic block, state of BB#4:
BB#4: derived from LLVM BB %eicas_calculator3.if.then
    Predecessors according to CFG: BB#0
	%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
	SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
    Successors according to CFG: BB#5
Creating pHyperOp bundles for CEs for bb4
starting at   %vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
starting at   %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2116-2180 ***
starting at   %zero<def> = ADDI %zero, 0
starting at   %zero<def> = ADDI %zero, 0
After bundling, state of BB4:BB#4: derived from LLVM BB %eicas_calculator3.if.then
    Predecessors according to CFG: BB#0
	%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
	  * SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

-------------
Starting new basic block BB#5
********** MI Scheduling **********
eicas_calculator3:BB#5 eicas_calculator3.return
  From: %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
    To: End Remaining: 0
Max Pressure: GR32Bit=2
Live In: 
Live Out: 
FP32BitLimit 32 Actual 0
GR32BitLimit 32 Actual 2
Excess PSets: 
1 subtrees:
  SU(0) in tree 0
  SU(1) in tree 0
  SU(2) in tree 0
  SU(3) in tree 0
SU(0):   %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 7
  Successors:
   val SU(1): Latency=5 Reg=%vreg11

SU(1):   %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 5
  Height             : 2
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg11
  Successors:
   val SU(3): Latency=2 Reg=%vreg12

SU(2):   %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(3): Latency=5 Reg=%vreg13

SU(3):   SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 13
  Depth              : 7
  Height             : 0
  Predecessors:
   val SU(1): Latency=2 Reg=%vreg12
   val SU(2): Latency=5 Reg=%vreg13
  Successors:
   ch  SU(4294967295) *: Latency=0

SU(0):   %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 7
  Successors:
   val SU(1): Latency=5 Reg=%vreg11

SU(1):   %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 14
  Depth              : 5
  Height             : 2
  Predecessors:
   val SU(0): Latency=5 Reg=%vreg11
  Successors:
   val SU(3): Latency=2 Reg=%vreg12

SU(2):   %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 4
  Depth              : 0
  Height             : 5
  Successors:
   val SU(3): Latency=5 Reg=%vreg13

SU(3):   SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 13
  Depth              : 7
  Height             : 0
  Predecessors:
   val SU(1): Latency=2 Reg=%vreg12
   val SU(2): Latency=5 Reg=%vreg13
  Successors:
   ch  SU(4294967295) *: Latency=0

Pick node SU(2)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
handleMove 2164B -> 2144B: %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
     %vreg13:	[2164r,2172r:0)  0@2164r
        -->	[2144r,2172r:0)  0@2144r
     t5:	EMPTY
        -->	EMPTY
Pick node SU(0)  ILP: 1 / 1 = 1 Tree: 0 @0
Scheduling %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
Pick node SU(1)  ILP: 2 / 6 = 0.333333 Tree: 0 @0
Scheduling %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
Pick node SU(3)  ILP: 4 / 8 = 0.5 Tree: 0 @0
Scheduling SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
*** Final schedule for BB#5 ***
SU(2):   %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
SU(0):   %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
SU(1):   %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
SU(3):   SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13

Partitioning instructions of the region into multiple CEs
instr:  %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
instr:  %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
instr:  %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
instr:  SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
Shuffling instructions within the region such that successive instructions belong to the same pHyperOp to ease bundle creation
Renaming registers used across CEs
before falloc, state of bb5:BB#5: derived from LLVM BB %eicas_calculator3.return
    Predecessors according to CFG: BB#3 BB#2 BB#4
	%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
	%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
	%vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
	SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
Adding all fallocs first to avoid stalls due to sequential fallocs and fbinds
Adding writecm(for writing sync count to context frames) and fbind instructions
live end of child is itself
live end of child is itself
Adding localref sw instructions to hyperOp eicas_calculator3
Adding writecm instructions to hyperOp eicas_calculator3

*** Renumbered SlotIndexes 2176-2192 ***
Adding writecmp and sync instructions
Adding endHyperOp instructions to each pHyperOp

*** Renumbered SlotIndexes 2188-2204 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2200-2216 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2212-2228 ***
  %zero<def> = ADDI %zero, 0
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2224-2240 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2236-2252 ***
  %zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2248-2264 ***
  %zero<def> = ADDI %zero, 0
  %zero<def> = ADDI %zero, 0
After Shuffling regions of basic block, state of BB#5:
BB#5: derived from LLVM BB %eicas_calculator3.return
    Predecessors according to CFG: BB#3 BB#2 BB#4
	%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
	%vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
	%vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
	SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
	%vreg111<def> = ADDI %zero, 128; GR32Bit:%vreg111
	%vreg112<def> = LW %t5, <fi#0>; GR32Bit:%vreg112
	WRITECM %vreg111, %vreg112, 0; GR32Bit:%vreg111,%vreg112
	FDELETE %t4, 0
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	END 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0

*** Renumbered SlotIndexes 2172-2308 ***
Creating pHyperOp bundles for CEs for bb5
  END 0
starting at   %vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
  END 0
starting at   END 0
  END 0
starting at   END 0
starting at   END 0
After bundling, state of BB5:BB#5: derived from LLVM BB %eicas_calculator3.return
    Predecessors according to CFG: BB#3 BB#2 BB#4
	%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
	  * %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
	  * %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
	  * SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
	  * %vreg111<def> = ADDI %zero, 128; GR32Bit:%vreg111
	  * %vreg112<def> = LW %t5, <fi#0>; GR32Bit:%vreg112
	  * WRITECM %vreg111, %vreg112, 0; GR32Bit:%vreg111,%vreg112
	  * FDELETE %t4, 0
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
%physreg43,Patching the instructions that are supposed to use the physical registers r30 and r31
Computing live-in reg-units in ABI blocks.
0B	BB#0 ra#0
Created 0 new intervals.

*** Renumbered SlotIndexes 1172-2380 ***

*** Renumbered SlotIndexes 1184-2392 ***

*** Renumbered SlotIndexes 1204-2404 ***
********** INTERVALS **********
ra = [0B,860r:0)  0@0B-phi
t5 = EMPTY
zero = [4r,4d:11)[268r,268d:10)[484r,484d:9)[700r,700d:8)[1740r,1740d:7)[1748r,1748d:6)[1756r,1756d:5)[1764r,1764d:4)[1772r,1772d:3)[1780r,1780d:2)[1788r,1788d:1)[1796r,1796d:0)  0@1796r 1@1788r 2@1780r 3@1772r 4@1764r 5@1756r 6@1748r 7@1740r 8@700r 9@484r 10@268r 11@4r
%vreg0 = [156r,220r:0)  0@156r
%vreg1 = [148r,164r:0)  0@148r
%vreg2 = [1220r,1228r:0)  0@1220r
%vreg3 = [1228r,1308r:0)  0@1228r
%vreg4 = [1200r,1308r:0)  0@1200r
%vreg5 = [2004r,2012r:0)  0@2004r
%vreg6 = [2012r,2028r:0)  0@2012r
%vreg7 = [1996r,2028r:0)  0@1996r
%vreg8 = [1820r,1836r:0)  0@1820r
%vreg9 = [1812r,1836r:0)  0@1812r
%vreg10 = [2188r,2220r:0)  0@2188r
%vreg11 = [2244r,2252r:0)  0@2244r
%vreg12 = [2252r,2268r:0)  0@2252r
%vreg13 = [2236r,2268r:0)  0@2236r
%vreg14 = [4r,4d:0)  0@4r
%vreg15 = [140r,140d:0)  0@140r
%vreg16 = [12r,28r:0)  0@12r
%vreg17 = [16r,20r:0)  0@16r
%vreg18 = [20r,28r:0)  0@20r
%vreg19 = [28r,140r:0)  0@28r
%vreg20 = [36r,132r:0)  0@36r
%vreg21 = [44r,92r:0)  0@44r
%vreg22 = [52r,60r:0)  0@52r
%vreg23 = [60r,108r:0)  0@60r
%vreg24 = [68r,76r:0)  0@68r
%vreg25 = [76r,116r:0)  0@76r
%vreg26 = [84r,92r:0)  0@84r
%vreg27 = [92r,124r:0)  0@92r
%vreg28 = [100r,108r:0)  0@100r
%vreg29 = [108r,116r:0)  0@108r
%vreg30 = [116r,124r:0)  0@116r
%vreg31 = [124r,132r:0)  0@124r
%vreg32 = [132r,140r:0)  0@132r
%vreg33 = [268r,268d:0)  0@268r
%vreg34 = [412r,412d:0)  0@412r
%vreg35 = [276r,300r:0)  0@276r
%vreg36 = [284r,292r:0)  0@284r
%vreg37 = [292r,300r:0)  0@292r
%vreg38 = [300r,412r:0)  0@300r
%vreg39 = [308r,404r:0)  0@308r
%vreg40 = [316r,364r:0)  0@316r
%vreg41 = [324r,332r:0)  0@324r
%vreg42 = [332r,380r:0)  0@332r
%vreg43 = [340r,348r:0)  0@340r
%vreg44 = [348r,388r:0)  0@348r
%vreg45 = [356r,364r:0)  0@356r
%vreg46 = [364r,396r:0)  0@364r
%vreg47 = [372r,380r:0)  0@372r
%vreg48 = [380r,388r:0)  0@380r
%vreg49 = [388r,396r:0)  0@388r
%vreg50 = [396r,404r:0)  0@396r
%vreg51 = [404r,412r:0)  0@404r
%vreg52 = [484r,484d:0)  0@484r
%vreg53 = [628r,628d:0)  0@628r
%vreg54 = [492r,516r:0)  0@492r
%vreg55 = [500r,508r:0)  0@500r
%vreg56 = [508r,516r:0)  0@508r
%vreg57 = [516r,628r:0)  0@516r
%vreg58 = [524r,620r:0)  0@524r
%vreg59 = [532r,580r:0)  0@532r
%vreg60 = [540r,548r:0)  0@540r
%vreg61 = [548r,596r:0)  0@548r
%vreg62 = [556r,564r:0)  0@556r
%vreg63 = [564r,604r:0)  0@564r
%vreg64 = [572r,580r:0)  0@572r
%vreg65 = [580r,612r:0)  0@580r
%vreg66 = [588r,596r:0)  0@588r
%vreg67 = [596r,604r:0)  0@596r
%vreg68 = [604r,612r:0)  0@604r
%vreg69 = [612r,620r:0)  0@612r
%vreg70 = [620r,628r:0)  0@620r
%vreg71 = [700r,700d:0)  0@700r
%vreg72 = [844r,844d:0)  0@844r
%vreg73 = [708r,732r:0)  0@708r
%vreg74 = [716r,724r:0)  0@716r
%vreg75 = [724r,732r:0)  0@724r
%vreg76 = [732r,844r:0)  0@732r
%vreg77 = [740r,836r:0)  0@740r
%vreg78 = [748r,796r:0)  0@748r
%vreg79 = [756r,764r:0)  0@756r
%vreg80 = [764r,812r:0)  0@764r
%vreg81 = [772r,780r:0)  0@772r
%vreg82 = [780r,820r:0)  0@780r
%vreg83 = [788r,796r:0)  0@788r
%vreg84 = [796r,828r:0)  0@796r
%vreg85 = [804r,812r:0)  0@804r
%vreg86 = [812r,820r:0)  0@812r
%vreg87 = [820r,828r:0)  0@820r
%vreg88 = [828r,836r:0)  0@828r
%vreg89 = [836r,844r:0)  0@836r
%vreg90 = [172r,180r:0)  0@172r
%vreg91 = [420r,428r:0)  0@420r
%vreg92 = [188r,196r:0)  0@188r
%vreg93 = [636r,644r:0)  0@636r
%vreg94 = [204r,212r:0)  0@204r
%vreg95 = [956r,972r:0)  0@956r
%vreg96 = [428r,436r:0)  0@428r
%vreg97 = [644r,652r:0)  0@644r
%vreg98 = [972r,1004r:0)  0@972r
%vreg99 = [1236r,1284r:0)  0@1236r
%vreg100 = [1356r,1380r:0)  0@1356r
%vreg101 = [1252r,1292r:0)  0@1252r
%vreg102 = [1444r,1468r:0)  0@1444r
%vreg103 = [1268r,1300r:0)  0@1268r
%vreg104 = [1532r,1596r:0)  0@1532r
%vreg105 = [1372r,1388r:0)  0@1372r
%vreg106 = [1460r,1476r:0)  0@1460r
%vreg107 = [1548r,1636r:0)  0@1548r
%vreg108 = [1380r,1388r:0)  0@1380r
%vreg109 = [1468r,1476r:0)  0@1468r
%vreg110 = [1596r,1636r:0)  0@1596r
%vreg111 = [2276r,2292r:0)  0@2276r
%vreg112 = [2284r,2292r:0)  0@2284r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function eicas_calculator3: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

0B	BB#0: derived from LLVM BB %eicas_calculator3.entry
	    Live Ins: %ra
4B		%t4<def> = ADD %t5, %zero
4B		  * %vreg16<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg16
4B		  * %vreg17<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg17
4B		  * %vreg18<def> = SRLI %vreg17, 12; GR32Bit:%vreg18,%vreg17
4B		  * %vreg19<def> = ADD %vreg16, %vreg18; GR32Bit:%vreg19,%vreg16,%vreg18
4B		  * %vreg20<def> = ADDI %zero, 12; GR32Bit:%vreg20
4B		  * %vreg21<def> = SRLI %t5, 22; GR32Bit:%vreg21
4B		  * %vreg22<def> = SRLI %t5, 12; GR32Bit:%vreg22
4B		  * %vreg23<def> = ANDI %vreg22, 15; GR32Bit:%vreg23,%vreg22
4B		  * %vreg24<def> = SRLI %t5, 6; GR32Bit:%vreg24
4B		  * %vreg25<def> = ANDI %vreg24, 63; GR32Bit:%vreg25,%vreg24
4B		  * %vreg26<def> = ADDI %zero, 832; GR32Bit:%vreg26
4B		  * %vreg27<def> = MUL %vreg21, %vreg26; GR32Bit:%vreg27,%vreg21,%vreg26
4B		  * %vreg28<def> = ADDI %zero, 52; GR32Bit:%vreg28
4B		  * %vreg29<def> = MUL %vreg23, %vreg28; GR32Bit:%vreg29,%vreg23,%vreg28
4B		  * %vreg30<def> = ADD %vreg29, %vreg25; GR32Bit:%vreg30,%vreg29,%vreg25
4B		  * %vreg31<def> = ADD %vreg30, %vreg27; GR32Bit:%vreg31,%vreg30,%vreg27
4B		  * %vreg32<def> = MUL %vreg31, %vreg20; GR32Bit:%vreg32,%vreg31,%vreg20
4B		  * %t5<def> = ADD %vreg19, %vreg32; GR32Bit:%vreg19,%vreg32
4B		  * %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
4B		  * %vreg0<def> = COPY %ra; GR32Bit:%vreg0
4B		  * SW %vreg0, %vreg1, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
4B		  * %vreg90<def> = LUI 1; GR32Bit:%vreg90
4B		  * WRITEPM %vreg90, %vreg0, 0; GR32Bit:%vreg90,%vreg0
4B		  * %vreg92<def> = LUI 2; GR32Bit:%vreg92
4B		  * WRITEPM %vreg92, %vreg0, 0; GR32Bit:%vreg92,%vreg0
4B		  * %vreg94<def> = LUI 3; GR32Bit:%vreg94
4B		  * WRITEPM %vreg94, %vreg0, 0; GR32Bit:%vreg94,%vreg0
4B		  * BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * JAL <BB#1>
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
268B		%t4<def> = ADD %t5, %zero
268B		  * %vreg35<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg35
268B		  * %vreg36<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg36
268B		  * %vreg37<def> = SRLI %vreg36, 12; GR32Bit:%vreg37,%vreg36
268B		  * %vreg38<def> = ADD %vreg35, %vreg37; GR32Bit:%vreg38,%vreg35,%vreg37
268B		  * %vreg39<def> = ADDI %zero, 12; GR32Bit:%vreg39
268B		  * %vreg40<def> = SRLI %t5, 22; GR32Bit:%vreg40
268B		  * %vreg41<def> = SRLI %t5, 12; GR32Bit:%vreg41
268B		  * %vreg42<def> = ANDI %vreg41, 15; GR32Bit:%vreg42,%vreg41
268B		  * %vreg43<def> = SRLI %t5, 6; GR32Bit:%vreg43
268B		  * %vreg44<def> = ANDI %vreg43, 63; GR32Bit:%vreg44,%vreg43
268B		  * %vreg45<def> = ADDI %zero, 832; GR32Bit:%vreg45
268B		  * %vreg46<def> = MUL %vreg40, %vreg45; GR32Bit:%vreg46,%vreg40,%vreg45
268B		  * %vreg47<def> = ADDI %zero, 52; GR32Bit:%vreg47
268B		  * %vreg48<def> = MUL %vreg42, %vreg47; GR32Bit:%vreg48,%vreg42,%vreg47
268B		  * %vreg49<def> = ADD %vreg48, %vreg44; GR32Bit:%vreg49,%vreg48,%vreg44
268B		  * %vreg50<def> = ADD %vreg49, %vreg46; GR32Bit:%vreg50,%vreg49,%vreg46
268B		  * %vreg51<def> = MUL %vreg50, %vreg39; GR32Bit:%vreg51,%vreg50,%vreg39
268B		  * %t5<def> = ADD %vreg38, %vreg51; GR32Bit:%vreg38,%vreg51
268B		  * %vreg91<def> = LUI 1; GR32Bit:%vreg91
268B		  * %vreg96<def> = DREADPM %vreg91, 0; GR32Bit:%vreg96,%vreg91
268B		  * BLT <BB#4>, %vreg96, %zero; GR32Bit:%vreg96
268B		  * %zero<def> = ADDI %zero, 0
268B		  * %zero<def> = ADDI %zero, 0
268B		  * JAL <BB#1>
268B		  * %zero<def> = ADDI %zero, 0
268B		  * %zero<def> = ADDI %zero, 0
484B		%t4<def> = ADD %t5, %zero
484B		  * %vreg54<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg54
484B		  * %vreg55<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg55
484B		  * %vreg56<def> = SRLI %vreg55, 12; GR32Bit:%vreg56,%vreg55
484B		  * %vreg57<def> = ADD %vreg54, %vreg56; GR32Bit:%vreg57,%vreg54,%vreg56
484B		  * %vreg58<def> = ADDI %zero, 12; GR32Bit:%vreg58
484B		  * %vreg59<def> = SRLI %t5, 22; GR32Bit:%vreg59
484B		  * %vreg60<def> = SRLI %t5, 12; GR32Bit:%vreg60
484B		  * %vreg61<def> = ANDI %vreg60, 15; GR32Bit:%vreg61,%vreg60
484B		  * %vreg62<def> = SRLI %t5, 6; GR32Bit:%vreg62
484B		  * %vreg63<def> = ANDI %vreg62, 63; GR32Bit:%vreg63,%vreg62
484B		  * %vreg64<def> = ADDI %zero, 832; GR32Bit:%vreg64
484B		  * %vreg65<def> = MUL %vreg59, %vreg64; GR32Bit:%vreg65,%vreg59,%vreg64
484B		  * %vreg66<def> = ADDI %zero, 52; GR32Bit:%vreg66
484B		  * %vreg67<def> = MUL %vreg61, %vreg66; GR32Bit:%vreg67,%vreg61,%vreg66
484B		  * %vreg68<def> = ADD %vreg67, %vreg63; GR32Bit:%vreg68,%vreg67,%vreg63
484B		  * %vreg69<def> = ADD %vreg68, %vreg65; GR32Bit:%vreg69,%vreg68,%vreg65
484B		  * %vreg70<def> = MUL %vreg69, %vreg58; GR32Bit:%vreg70,%vreg69,%vreg58
484B		  * %t5<def> = ADD %vreg57, %vreg70; GR32Bit:%vreg57,%vreg70
484B		  * %vreg93<def> = LUI 2; GR32Bit:%vreg93
484B		  * %vreg97<def> = DREADPM %vreg93, 0; GR32Bit:%vreg97,%vreg93
484B		  * BLT <BB#4>, %vreg97, %zero; GR32Bit:%vreg97
484B		  * %zero<def> = ADDI %zero, 0
484B		  * %zero<def> = ADDI %zero, 0
484B		  * JAL <BB#1>
484B		  * %zero<def> = ADDI %zero, 0
484B		  * %zero<def> = ADDI %zero, 0
700B		%t4<def> = ADD %t5, %zero
700B		  * %vreg73<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg73
700B		  * %vreg74<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg74
700B		  * %vreg75<def> = SRLI %vreg74, 12; GR32Bit:%vreg75,%vreg74
700B		  * %vreg76<def> = ADD %vreg73, %vreg75; GR32Bit:%vreg76,%vreg73,%vreg75
700B		  * %vreg77<def> = ADDI %zero, 12; GR32Bit:%vreg77
700B		  * %vreg78<def> = SRLI %t5, 22; GR32Bit:%vreg78
700B		  * %vreg79<def> = SRLI %t5, 12; GR32Bit:%vreg79
700B		  * %vreg80<def> = ANDI %vreg79, 15; GR32Bit:%vreg80,%vreg79
700B		  * %vreg81<def> = SRLI %t5, 6; GR32Bit:%vreg81
700B		  * %vreg82<def> = ANDI %vreg81, 63; GR32Bit:%vreg82,%vreg81
700B		  * %vreg83<def> = ADDI %zero, 832; GR32Bit:%vreg83
700B		  * %vreg84<def> = MUL %vreg78, %vreg83; GR32Bit:%vreg84,%vreg78,%vreg83
700B		  * %vreg85<def> = ADDI %zero, 52; GR32Bit:%vreg85
700B		  * %vreg86<def> = MUL %vreg80, %vreg85; GR32Bit:%vreg86,%vreg80,%vreg85
700B		  * %vreg87<def> = ADD %vreg86, %vreg82; GR32Bit:%vreg87,%vreg86,%vreg82
700B		  * %vreg88<def> = ADD %vreg87, %vreg84; GR32Bit:%vreg88,%vreg87,%vreg84
700B		  * %vreg89<def> = MUL %vreg88, %vreg77; GR32Bit:%vreg89,%vreg88,%vreg77
700B		  * %t5<def> = ADD %vreg76, %vreg89; GR32Bit:%vreg76,%vreg89
700B		  * %vreg95<def> = LUI 3; GR32Bit:%vreg95
700B		  * %vreg98<def> = DREADPM %vreg95, 0; GR32Bit:%vreg98,%vreg95
700B		  * BLT <BB#4>, %vreg98, %zero; GR32Bit:%vreg98
700B		  * %zero<def> = ADDI %zero, 0
700B		  * %zero<def> = ADDI %zero, 0
700B		  * JAL <BB#1>
700B		  * %zero<def> = ADDI %zero, 0
700B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#4(12) BB#1(20)

1172B	BB#1: derived from LLVM BB %eicas_calculator3.if.else
	    Predecessors according to CFG: BB#0
1180B		%vreg4<def> = LUI 16; GR32Bit:%vreg4
1180B		  * %a5<def> = LUI 0
1180B		  * %a5<def> = SRLI %a5<internal>, 12
1180B		  * ADD %vreg4, %vreg4, %a5; GR32Bit:%vreg4
1180B		  * %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
1180B		  * %vreg3<def> = LW %vreg2, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
1180B		  * %vreg99<def> = LUI 1; GR32Bit:%vreg99
1180B		  * WRITEPM %vreg99, %vreg3, 0; GR32Bit:%vreg99,%vreg3
1180B		  * %vreg101<def> = LUI 2; GR32Bit:%vreg101
1180B		  * WRITEPM %vreg101, %vreg3, 0; GR32Bit:%vreg101,%vreg3
1180B		  * %vreg103<def> = LUI 3; GR32Bit:%vreg103
1180B		  * WRITEPM %vreg103, %vreg3, 0; GR32Bit:%vreg103,%vreg3
1180B		  * WRITEPM %vreg99, %vreg4, 4; GR32Bit:%vreg99,%vreg4
1180B		  * WRITEPM %vreg101, %vreg4, 4; GR32Bit:%vreg101,%vreg4
1180B		  * WRITEPM %vreg103, %vreg4, 4; GR32Bit:%vreg103,%vreg4
1180B		  * BLT <BB#3>, %vreg3, %vreg4; GR32Bit:%vreg3,%vreg4
1180B		  * %zero<def> = ADDI %zero, 0
1180B		  * %zero<def> = ADDI %zero, 0
1180B		  * JAL <BB#2>
1180B		  * %zero<def> = ADDI %zero, 0
1180B		  * %zero<def> = ADDI %zero, 0
1356B		%vreg100<def> = LUI 1; GR32Bit:%vreg100
1356B		  * %vreg105<def> = DREADPM %vreg100, 0; GR32Bit:%vreg105,%vreg100
1356B		  * %vreg108<def> = DREADPM %vreg100, 4; GR32Bit:%vreg108,%vreg100
1356B		  * BLT <BB#3>, %vreg105, %vreg108; GR32Bit:%vreg105,%vreg108
1356B		  * %zero<def> = ADDI %zero, 0
1356B		  * %zero<def> = ADDI %zero, 0
1356B		  * JAL <BB#2>
1356B		  * %zero<def> = ADDI %zero, 0
1356B		  * %zero<def> = ADDI %zero, 0
1444B		%vreg102<def> = LUI 2; GR32Bit:%vreg102
1444B		  * %vreg106<def> = DREADPM %vreg102, 0; GR32Bit:%vreg106,%vreg102
1444B		  * %vreg109<def> = DREADPM %vreg102, 4; GR32Bit:%vreg109,%vreg102
1444B		  * BLT <BB#3>, %vreg106, %vreg109; GR32Bit:%vreg106,%vreg109
1444B		  * %zero<def> = ADDI %zero, 0
1444B		  * %zero<def> = ADDI %zero, 0
1444B		  * JAL <BB#2>
1444B		  * %zero<def> = ADDI %zero, 0
1444B		  * %zero<def> = ADDI %zero, 0
1532B		%vreg104<def> = LUI 3; GR32Bit:%vreg104
1532B		  * %vreg107<def> = DREADPM %vreg104, 0; GR32Bit:%vreg107,%vreg104
1532B		  * %vreg110<def> = DREADPM %vreg104, 4; GR32Bit:%vreg110,%vreg104
1532B		  * BLT <BB#3>, %vreg107, %vreg110; GR32Bit:%vreg107,%vreg110
1532B		  * %zero<def> = ADDI %zero, 0
1532B		  * %zero<def> = ADDI %zero, 0
1532B		  * JAL <BB#2>
1532B		  * %zero<def> = ADDI %zero, 0
1532B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#2(16) BB#3(16)

1804B	BB#2: derived from LLVM BB %eicas_calculator3.if.then2
	    Predecessors according to CFG: BB#1
1200B		%vreg9<def> = LUI 15; GR32Bit:%vreg9
1200B		  * %a5<def> = LUI 4095
1200B		  * %a5<def> = SRLI %a5<internal>, 12
1200B		  * ADD %vreg9, %vreg9, %a5; GR32Bit:%vreg9
1200B		  * %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
1200B		  * SW %vreg9, %vreg8, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
1200B		  * JAL <BB#5>
1200B		  * %zero<def> = ADDI %zero, 0
1200B		  * %zero<def> = ADDI %zero, 0
1868B		JAL <BB#5>
1868B		  * %zero<def> = ADDI %zero, 0
1868B		  * %zero<def> = ADDI %zero, 0
1892B		JAL <BB#5>
1892B		  * %zero<def> = ADDI %zero, 0
1892B		  * %zero<def> = ADDI %zero, 0
1916B		JAL <BB#5>
1916B		  * %zero<def> = ADDI %zero, 0
1916B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#5

1988B	BB#3: derived from LLVM BB %eicas_calculator3.if.else3
	    Predecessors according to CFG: BB#1
1996B		%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
1996B		  * %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
1996B		  * %vreg6<def> = LW %vreg5, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
1996B		  * SW %vreg6, %vreg7, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
1996B		  * JAL <BB#5>
1996B		  * %zero<def> = ADDI %zero, 0
1996B		  * %zero<def> = ADDI %zero, 0
2060B		JAL <BB#5>
2060B		  * %zero<def> = ADDI %zero, 0
2060B		  * %zero<def> = ADDI %zero, 0
2084B		JAL <BB#5>
2084B		  * %zero<def> = ADDI %zero, 0
2084B		  * %zero<def> = ADDI %zero, 0
2108B		JAL <BB#5>
2108B		  * %zero<def> = ADDI %zero, 0
2108B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#5

2180B	BB#4: derived from LLVM BB %eicas_calculator3.if.then
	    Predecessors according to CFG: BB#0
2188B		%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
2188B		  * SW %zero, %vreg10, 0; mem:ST4[%3] GR32Bit:%vreg10
2196B		%zero<def> = ADDI %zero, 0
2204B		%zero<def> = ADDI %zero, 0
2212B		%zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#5

2228B	BB#5: derived from LLVM BB %eicas_calculator3.return
	    Predecessors according to CFG: BB#3 BB#2 BB#4
2236B		%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
2236B		  * %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
2236B		  * %vreg12<def> = LW %vreg11, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
2236B		  * SW %vreg12, %vreg13, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
2236B		  * %vreg111<def> = ADDI %zero, 128; GR32Bit:%vreg111
2236B		  * %vreg112<def> = LW %t5, <fi#0>; GR32Bit:%vreg112
2236B		  * WRITECM %vreg111, %vreg112, 0; GR32Bit:%vreg111,%vreg112
2236B		  * FDELETE %t4, 0
2236B		  * END 0
2236B		  * %zero<def> = ADDI %zero, 0
2236B		  * %zero<def> = ADDI %zero, 0
2332B		END 0
2332B		  * %zero<def> = ADDI %zero, 0
2332B		  * %zero<def> = ADDI %zero, 0
2356B		END 0
2356B		  * %zero<def> = ADDI %zero, 0
2356B		  * %zero<def> = ADDI %zero, 0
2380B		END 0
2380B		  * %zero<def> = ADDI %zero, 0
2380B		  * %zero<def> = ADDI %zero, 0

# End machine code for function eicas_calculator3.

********** COMPUTING LIVE DEBUG VARIABLES: eicas_calculator3 **********
********** DEBUG VARIABLES **********
********** Compute Spill Weights **********
********** Function: eicas_calculator3
********** GREEDY REGISTER ALLOCATION **********
********** Function: eicas_calculator3
Replacing 43 with 43 for instruction%vreg0<def> = COPY %ra; GR32Bit:%vreg0

selectOrSplit GR32Bit:%vreg0 [156r,220r:0)  0@156r
hints: %ra
reg 2147483648 that was live-in gets phys reg:43 instead of phys reg:43
assigning %vreg0 to %ra: ra

selectOrSplit GR32Bit:%vreg19 [28r,140r:0)  0@28r
assigning %vreg19 to %t0: t0

selectOrSplit GR32Bit:%vreg38 [300r,412r:0)  0@300r
assigning %vreg38 to %t0: t0

selectOrSplit GR32Bit:%vreg57 [516r,628r:0)  0@516r
assigning %vreg57 to %t0: t0

selectOrSplit GR32Bit:%vreg76 [732r,844r:0)  0@732r
assigning %vreg76 to %t0: t0

selectOrSplit GR32Bit:%vreg4 [1200r,1308r:0)  0@1200r
assigning %vreg4 to %t0: t0

selectOrSplit GR32Bit:%vreg20 [36r,132r:0)  0@36r
assigning %vreg20 to %t1: t1

selectOrSplit GR32Bit:%vreg39 [308r,404r:0)  0@308r
assigning %vreg39 to %t1: t1

selectOrSplit GR32Bit:%vreg58 [524r,620r:0)  0@524r
assigning %vreg58 to %t1: t1

selectOrSplit GR32Bit:%vreg77 [740r,836r:0)  0@740r
assigning %vreg77 to %t1: t1

selectOrSplit GR32Bit:%vreg107 [1548r,1636r:0)  0@1548r
assigning %vreg107 to %t0: t0

selectOrSplit GR32Bit:%vreg3 [1228r,1308r:0)  0@1228r
assigning %vreg3 to %t1: t1

selectOrSplit GR32Bit:%vreg104 [1532r,1596r:0)  0@1532r
assigning %vreg104 to %t1: t1

selectOrSplit GR32Bit:%vreg21 [44r,92r:0)  0@44r
assigning %vreg21 to %t2: t2

selectOrSplit GR32Bit:%vreg23 [60r,108r:0)  0@60r
assigning %vreg23 to %fp: fp

selectOrSplit GR32Bit:%vreg40 [316r,364r:0)  0@316r
assigning %vreg40 to %t2: t2

selectOrSplit GR32Bit:%vreg42 [332r,380r:0)  0@332r
assigning %vreg42 to %fp: fp

selectOrSplit GR32Bit:%vreg59 [532r,580r:0)  0@532r
assigning %vreg59 to %t2: t2

selectOrSplit GR32Bit:%vreg61 [548r,596r:0)  0@548r
assigning %vreg61 to %fp: fp

selectOrSplit GR32Bit:%vreg78 [748r,796r:0)  0@748r
assigning %vreg78 to %t2: t2

selectOrSplit GR32Bit:%vreg80 [764r,812r:0)  0@764r
assigning %vreg80 to %fp: fp

selectOrSplit GR32Bit:%vreg99 [1236r,1284r:0)  0@1236r
assigning %vreg99 to %t2: t2

selectOrSplit GR32Bit:%vreg25 [76r,116r:0)  0@76r
assigning %vreg25 to %a0: a0

selectOrSplit GR32Bit:%vreg44 [348r,388r:0)  0@348r
assigning %vreg44 to %a0: a0

selectOrSplit GR32Bit:%vreg63 [564r,604r:0)  0@564r
assigning %vreg63 to %a0: a0

selectOrSplit GR32Bit:%vreg82 [780r,820r:0)  0@780r
assigning %vreg82 to %a0: a0

selectOrSplit GR32Bit:%vreg101 [1252r,1292r:0)  0@1252r
assigning %vreg101 to %fp: fp

selectOrSplit GR32Bit:%vreg110 [1596r,1636r:0)  0@1596r
assigning %vreg110 to %t1: t1

selectOrSplit GR32Bit:%vreg7 [1996r,2028r:0)  0@1996r
assigning %vreg7 to %t0: t0

selectOrSplit GR32Bit:%vreg10 [2188r,2220r:0)  0@2188r
assigning %vreg10 to %t0: t0

selectOrSplit GR32Bit:%vreg13 [2236r,2268r:0)  0@2236r
assigning %vreg13 to %t0: t0

selectOrSplit GR32Bit:%vreg27 [92r,124r:0)  0@92r
assigning %vreg27 to %t2: t2

selectOrSplit GR32Bit:%vreg46 [364r,396r:0)  0@364r
assigning %vreg46 to %t2: t2

selectOrSplit GR32Bit:%vreg65 [580r,612r:0)  0@580r
assigning %vreg65 to %t2: t2

selectOrSplit GR32Bit:%vreg84 [796r,828r:0)  0@796r
assigning %vreg84 to %t2: t2

selectOrSplit GR32Bit:%vreg98 [972r,1004r:0)  0@972r
assigning %vreg98 to %t0: t0

selectOrSplit GR32Bit:%vreg103 [1268r,1300r:0)  0@1268r
assigning %vreg103 to %a0: a0

selectOrSplit GR32Bit:%vreg9 [1812r,1836r:0)  0@1812r
assigning %vreg9 to %t0: t0

selectOrSplit GR32Bit:%vreg35 [276r,300r:0)  0@276r
assigning %vreg35 to %t0: t0

selectOrSplit GR32Bit:%vreg54 [492r,516r:0)  0@492r
assigning %vreg54 to %t0: t0

selectOrSplit GR32Bit:%vreg73 [708r,732r:0)  0@708r
assigning %vreg73 to %t0: t0

selectOrSplit GR32Bit:%vreg100 [1356r,1380r:0)  0@1356r
assigning %vreg100 to %t0: t0

selectOrSplit GR32Bit:%vreg102 [1444r,1468r:0)  0@1444r
assigning %vreg102 to %t0: t0

selectOrSplit GR32Bit:%vreg1 [148r,164r:0)  0@148r
assigning %vreg1 to %t0: t0

selectOrSplit GR32Bit:%vreg6 [2012r,2028r:0)  0@2012r
assigning %vreg6 to %t1: t1

selectOrSplit GR32Bit:%vreg8 [1820r,1836r:0)  0@1820r
assigning %vreg8 to %t1: t1

selectOrSplit GR32Bit:%vreg12 [2252r,2268r:0)  0@2252r
assigning %vreg12 to %t1: t1

selectOrSplit GR32Bit:%vreg16 [12r,28r:0)  0@12r
assigning %vreg16 to %t0: t0

selectOrSplit GR32Bit:%vreg95 [956r,972r:0)  0@956r
assigning %vreg95 to %t0: t0

selectOrSplit GR32Bit:%vreg105 [1372r,1388r:0)  0@1372r
assigning %vreg105 to %t1: t1

selectOrSplit GR32Bit:%vreg106 [1460r,1476r:0)  0@1460r
assigning %vreg106 to %t1: t1

selectOrSplit GR32Bit:%vreg111 [2276r,2292r:0)  0@2276r
assigning %vreg111 to %t0: t0

selectOrSplit GR32Bit:%vreg2 [1220r,1228r:0)  0@1220r
assigning %vreg2 to %t1: t1

selectOrSplit GR32Bit:%vreg5 [2004r,2012r:0)  0@2004r
assigning %vreg5 to %t1: t1

selectOrSplit GR32Bit:%vreg11 [2244r,2252r:0)  0@2244r
assigning %vreg11 to %t1: t1

selectOrSplit GR32Bit:%vreg18 [20r,28r:0)  0@20r
assigning %vreg18 to %t1: t1

selectOrSplit GR32Bit:%vreg22 [52r,60r:0)  0@52r
assigning %vreg22 to %fp: fp

selectOrSplit GR32Bit:%vreg24 [68r,76r:0)  0@68r
assigning %vreg24 to %a0: a0

selectOrSplit GR32Bit:%vreg26 [84r,92r:0)  0@84r
assigning %vreg26 to %a1: a1

selectOrSplit GR32Bit:%vreg28 [100r,108r:0)  0@100r
assigning %vreg28 to %a1: a1

selectOrSplit GR32Bit:%vreg29 [108r,116r:0)  0@108r
assigning %vreg29 to %fp: fp

selectOrSplit GR32Bit:%vreg30 [116r,124r:0)  0@116r
assigning %vreg30 to %fp: fp

selectOrSplit GR32Bit:%vreg31 [124r,132r:0)  0@124r
assigning %vreg31 to %t2: t2

selectOrSplit GR32Bit:%vreg32 [132r,140r:0)  0@132r
assigning %vreg32 to %t1: t1

selectOrSplit GR32Bit:%vreg36 [284r,292r:0)  0@284r
assigning %vreg36 to %t1: t1

selectOrSplit GR32Bit:%vreg37 [292r,300r:0)  0@292r
assigning %vreg37 to %t1: t1

selectOrSplit GR32Bit:%vreg41 [324r,332r:0)  0@324r
assigning %vreg41 to %fp: fp

selectOrSplit GR32Bit:%vreg43 [340r,348r:0)  0@340r
assigning %vreg43 to %a0: a0

selectOrSplit GR32Bit:%vreg45 [356r,364r:0)  0@356r
assigning %vreg45 to %a1: a1

selectOrSplit GR32Bit:%vreg47 [372r,380r:0)  0@372r
assigning %vreg47 to %a1: a1

selectOrSplit GR32Bit:%vreg48 [380r,388r:0)  0@380r
assigning %vreg48 to %fp: fp

selectOrSplit GR32Bit:%vreg49 [388r,396r:0)  0@388r
assigning %vreg49 to %fp: fp

selectOrSplit GR32Bit:%vreg50 [396r,404r:0)  0@396r
assigning %vreg50 to %t2: t2

selectOrSplit GR32Bit:%vreg51 [404r,412r:0)  0@404r
assigning %vreg51 to %t1: t1

selectOrSplit GR32Bit:%vreg55 [500r,508r:0)  0@500r
assigning %vreg55 to %t1: t1

selectOrSplit GR32Bit:%vreg56 [508r,516r:0)  0@508r
assigning %vreg56 to %t1: t1

selectOrSplit GR32Bit:%vreg60 [540r,548r:0)  0@540r
assigning %vreg60 to %fp: fp

selectOrSplit GR32Bit:%vreg62 [556r,564r:0)  0@556r
assigning %vreg62 to %a0: a0

selectOrSplit GR32Bit:%vreg64 [572r,580r:0)  0@572r
assigning %vreg64 to %a1: a1

selectOrSplit GR32Bit:%vreg66 [588r,596r:0)  0@588r
assigning %vreg66 to %a1: a1

selectOrSplit GR32Bit:%vreg67 [596r,604r:0)  0@596r
assigning %vreg67 to %fp: fp

selectOrSplit GR32Bit:%vreg68 [604r,612r:0)  0@604r
assigning %vreg68 to %fp: fp

selectOrSplit GR32Bit:%vreg69 [612r,620r:0)  0@612r
assigning %vreg69 to %t2: t2

selectOrSplit GR32Bit:%vreg70 [620r,628r:0)  0@620r
assigning %vreg70 to %t1: t1

selectOrSplit GR32Bit:%vreg74 [716r,724r:0)  0@716r
assigning %vreg74 to %t1: t1

selectOrSplit GR32Bit:%vreg75 [724r,732r:0)  0@724r
assigning %vreg75 to %t1: t1

selectOrSplit GR32Bit:%vreg79 [756r,764r:0)  0@756r
assigning %vreg79 to %fp: fp

selectOrSplit GR32Bit:%vreg81 [772r,780r:0)  0@772r
assigning %vreg81 to %a0: a0

selectOrSplit GR32Bit:%vreg83 [788r,796r:0)  0@788r
assigning %vreg83 to %a1: a1

selectOrSplit GR32Bit:%vreg85 [804r,812r:0)  0@804r
assigning %vreg85 to %a1: a1

selectOrSplit GR32Bit:%vreg86 [812r,820r:0)  0@812r
assigning %vreg86 to %fp: fp

selectOrSplit GR32Bit:%vreg87 [820r,828r:0)  0@820r
assigning %vreg87 to %fp: fp

selectOrSplit GR32Bit:%vreg88 [828r,836r:0)  0@828r
assigning %vreg88 to %t2: t2

selectOrSplit GR32Bit:%vreg89 [836r,844r:0)  0@836r
assigning %vreg89 to %t1: t1

selectOrSplit GR32Bit:%vreg90 [172r,180r:0)  0@172r
assigning %vreg90 to %t0: t0

selectOrSplit GR32Bit:%vreg91 [420r,428r:0)  0@420r
assigning %vreg91 to %t0: t0

selectOrSplit GR32Bit:%vreg92 [188r,196r:0)  0@188r
assigning %vreg92 to %t0: t0

selectOrSplit GR32Bit:%vreg93 [636r,644r:0)  0@636r
assigning %vreg93 to %t0: t0

selectOrSplit GR32Bit:%vreg94 [204r,212r:0)  0@204r
assigning %vreg94 to %t0: t0

selectOrSplit GR32Bit:%vreg96 [428r,436r:0)  0@428r
assigning %vreg96 to %t0: t0

selectOrSplit GR32Bit:%vreg97 [644r,652r:0)  0@644r
assigning %vreg97 to %t0: t0

selectOrSplit GR32Bit:%vreg108 [1380r,1388r:0)  0@1380r
assigning %vreg108 to %t0: t0

selectOrSplit GR32Bit:%vreg109 [1468r,1476r:0)  0@1468r
assigning %vreg109 to %t0: t0

selectOrSplit GR32Bit:%vreg112 [2284r,2292r:0)  0@2284r
assigning %vreg112 to %t1: t1

selectOrSplit GR32Bit:%vreg17 [16r,20r:0)  0@16r
assigning %vreg17 to %t1: t1
********** REWRITE VIRTUAL REGISTERS **********
********** Function: eicas_calculator3
********** REGISTER MAP **********
[%vreg0 -> %ra] GR32Bit
[%vreg1 -> %t0] GR32Bit
[%vreg2 -> %t1] GR32Bit
[%vreg3 -> %t1] GR32Bit
[%vreg4 -> %t0] GR32Bit
[%vreg5 -> %t1] GR32Bit
[%vreg6 -> %t1] GR32Bit
[%vreg7 -> %t0] GR32Bit
[%vreg8 -> %t1] GR32Bit
[%vreg9 -> %t0] GR32Bit
[%vreg10 -> %t0] GR32Bit
[%vreg11 -> %t1] GR32Bit
[%vreg12 -> %t1] GR32Bit
[%vreg13 -> %t0] GR32Bit
[%vreg16 -> %t0] GR32Bit
[%vreg17 -> %t1] GR32Bit
[%vreg18 -> %t1] GR32Bit
[%vreg19 -> %t0] GR32Bit
[%vreg20 -> %t1] GR32Bit
[%vreg21 -> %t2] GR32Bit
[%vreg22 -> %fp] GR32Bit
[%vreg23 -> %fp] GR32Bit
[%vreg24 -> %a0] GR32Bit
[%vreg25 -> %a0] GR32Bit
[%vreg26 -> %a1] GR32Bit
[%vreg27 -> %t2] GR32Bit
[%vreg28 -> %a1] GR32Bit
[%vreg29 -> %fp] GR32Bit
[%vreg30 -> %fp] GR32Bit
[%vreg31 -> %t2] GR32Bit
[%vreg32 -> %t1] GR32Bit
[%vreg35 -> %t0] GR32Bit
[%vreg36 -> %t1] GR32Bit
[%vreg37 -> %t1] GR32Bit
[%vreg38 -> %t0] GR32Bit
[%vreg39 -> %t1] GR32Bit
[%vreg40 -> %t2] GR32Bit
[%vreg41 -> %fp] GR32Bit
[%vreg42 -> %fp] GR32Bit
[%vreg43 -> %a0] GR32Bit
[%vreg44 -> %a0] GR32Bit
[%vreg45 -> %a1] GR32Bit
[%vreg46 -> %t2] GR32Bit
[%vreg47 -> %a1] GR32Bit
[%vreg48 -> %fp] GR32Bit
[%vreg49 -> %fp] GR32Bit
[%vreg50 -> %t2] GR32Bit
[%vreg51 -> %t1] GR32Bit
[%vreg54 -> %t0] GR32Bit
[%vreg55 -> %t1] GR32Bit
[%vreg56 -> %t1] GR32Bit
[%vreg57 -> %t0] GR32Bit
[%vreg58 -> %t1] GR32Bit
[%vreg59 -> %t2] GR32Bit
[%vreg60 -> %fp] GR32Bit
[%vreg61 -> %fp] GR32Bit
[%vreg62 -> %a0] GR32Bit
[%vreg63 -> %a0] GR32Bit
[%vreg64 -> %a1] GR32Bit
[%vreg65 -> %t2] GR32Bit
[%vreg66 -> %a1] GR32Bit
[%vreg67 -> %fp] GR32Bit
[%vreg68 -> %fp] GR32Bit
[%vreg69 -> %t2] GR32Bit
[%vreg70 -> %t1] GR32Bit
[%vreg73 -> %t0] GR32Bit
[%vreg74 -> %t1] GR32Bit
[%vreg75 -> %t1] GR32Bit
[%vreg76 -> %t0] GR32Bit
[%vreg77 -> %t1] GR32Bit
[%vreg78 -> %t2] GR32Bit
[%vreg79 -> %fp] GR32Bit
[%vreg80 -> %fp] GR32Bit
[%vreg81 -> %a0] GR32Bit
[%vreg82 -> %a0] GR32Bit
[%vreg83 -> %a1] GR32Bit
[%vreg84 -> %t2] GR32Bit
[%vreg85 -> %a1] GR32Bit
[%vreg86 -> %fp] GR32Bit
[%vreg87 -> %fp] GR32Bit
[%vreg88 -> %t2] GR32Bit
[%vreg89 -> %t1] GR32Bit
[%vreg90 -> %t0] GR32Bit
[%vreg91 -> %t0] GR32Bit
[%vreg92 -> %t0] GR32Bit
[%vreg93 -> %t0] GR32Bit
[%vreg94 -> %t0] GR32Bit
[%vreg95 -> %t0] GR32Bit
[%vreg96 -> %t0] GR32Bit
[%vreg97 -> %t0] GR32Bit
[%vreg98 -> %t0] GR32Bit
[%vreg99 -> %t2] GR32Bit
[%vreg100 -> %t0] GR32Bit
[%vreg101 -> %fp] GR32Bit
[%vreg102 -> %t0] GR32Bit
[%vreg103 -> %a0] GR32Bit
[%vreg104 -> %t1] GR32Bit
[%vreg105 -> %t1] GR32Bit
[%vreg106 -> %t1] GR32Bit
[%vreg107 -> %t0] GR32Bit
[%vreg108 -> %t0] GR32Bit
[%vreg109 -> %t0] GR32Bit
[%vreg110 -> %t1] GR32Bit
[%vreg111 -> %t0] GR32Bit
[%vreg112 -> %t1] GR32Bit

0B	BB#0: derived from LLVM BB %eicas_calculator3.entry
	    Live Ins: %ra
4B		%t4<def> = ADD %t5, %zero
4B		  * %vreg16<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg16
4B		  * %vreg17<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg17
4B		  * %vreg18<def> = SRLI %vreg17<kill>, 12; GR32Bit:%vreg18,%vreg17
4B		  * %vreg19<def> = ADD %vreg16<kill>, %vreg18<kill>; GR32Bit:%vreg19,%vreg16,%vreg18
4B		  * %vreg20<def> = ADDI %zero, 12; GR32Bit:%vreg20
4B		  * %vreg21<def> = SRLI %t5, 22; GR32Bit:%vreg21
4B		  * %vreg22<def> = SRLI %t5, 12; GR32Bit:%vreg22
4B		  * %vreg23<def> = ANDI %vreg22<kill>, 15; GR32Bit:%vreg23,%vreg22
4B		  * %vreg24<def> = SRLI %t5, 6; GR32Bit:%vreg24
4B		  * %vreg25<def> = ANDI %vreg24<kill>, 63; GR32Bit:%vreg25,%vreg24
4B		  * %vreg26<def> = ADDI %zero, 832; GR32Bit:%vreg26
4B		  * %vreg27<def> = MUL %vreg21<kill>, %vreg26<kill>; GR32Bit:%vreg27,%vreg21,%vreg26
4B		  * %vreg28<def> = ADDI %zero, 52; GR32Bit:%vreg28
4B		  * %vreg29<def> = MUL %vreg23<kill>, %vreg28<kill>; GR32Bit:%vreg29,%vreg23,%vreg28
4B		  * %vreg30<def> = ADD %vreg29<kill>, %vreg25<kill>; GR32Bit:%vreg30,%vreg29,%vreg25
4B		  * %vreg31<def> = ADD %vreg30<kill>, %vreg27<kill>; GR32Bit:%vreg31,%vreg30,%vreg27
4B		  * %vreg32<def> = MUL %vreg31<kill>, %vreg20<kill>; GR32Bit:%vreg32,%vreg31,%vreg20
4B		  * %t5<def> = ADD %vreg19<kill>, %vreg32<kill>; GR32Bit:%vreg19,%vreg32
4B		  * %vreg1<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg1
4B		  * %vreg0<def> = COPY %ra; GR32Bit:%vreg0
4B		  * SW %vreg0, %vreg1<kill>, 0; mem:ST4[%2] GR32Bit:%vreg0,%vreg1
4B		  * %vreg90<def> = LUI 1; GR32Bit:%vreg90
4B		  * WRITEPM %vreg90<kill>, %vreg0, 0; GR32Bit:%vreg90,%vreg0
4B		  * %vreg92<def> = LUI 2; GR32Bit:%vreg92
4B		  * WRITEPM %vreg92<kill>, %vreg0, 0; GR32Bit:%vreg92,%vreg0
4B		  * %vreg94<def> = LUI 3; GR32Bit:%vreg94
4B		  * WRITEPM %vreg94<kill>, %vreg0, 0; GR32Bit:%vreg94,%vreg0
4B		  * BLT <BB#4>, %vreg0, %zero; GR32Bit:%vreg0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
4B		  * JAL <BB#1>
4B		  * %zero<def> = ADDI %zero, 0
4B		  * %zero<def> = ADDI %zero, 0
268B		%t4<def> = ADD %t5, %zero
268B		  * %vreg35<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg35
268B		  * %vreg36<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg36
268B		  * %vreg37<def> = SRLI %vreg36<kill>, 12; GR32Bit:%vreg37,%vreg36
268B		  * %vreg38<def> = ADD %vreg35<kill>, %vreg37<kill>; GR32Bit:%vreg38,%vreg35,%vreg37
268B		  * %vreg39<def> = ADDI %zero, 12; GR32Bit:%vreg39
268B		  * %vreg40<def> = SRLI %t5, 22; GR32Bit:%vreg40
268B		  * %vreg41<def> = SRLI %t5, 12; GR32Bit:%vreg41
268B		  * %vreg42<def> = ANDI %vreg41<kill>, 15; GR32Bit:%vreg42,%vreg41
268B		  * %vreg43<def> = SRLI %t5, 6; GR32Bit:%vreg43
268B		  * %vreg44<def> = ANDI %vreg43<kill>, 63; GR32Bit:%vreg44,%vreg43
268B		  * %vreg45<def> = ADDI %zero, 832; GR32Bit:%vreg45
268B		  * %vreg46<def> = MUL %vreg40<kill>, %vreg45<kill>; GR32Bit:%vreg46,%vreg40,%vreg45
268B		  * %vreg47<def> = ADDI %zero, 52; GR32Bit:%vreg47
268B		  * %vreg48<def> = MUL %vreg42<kill>, %vreg47<kill>; GR32Bit:%vreg48,%vreg42,%vreg47
268B		  * %vreg49<def> = ADD %vreg48<kill>, %vreg44<kill>; GR32Bit:%vreg49,%vreg48,%vreg44
268B		  * %vreg50<def> = ADD %vreg49<kill>, %vreg46<kill>; GR32Bit:%vreg50,%vreg49,%vreg46
268B		  * %vreg51<def> = MUL %vreg50<kill>, %vreg39<kill>; GR32Bit:%vreg51,%vreg50,%vreg39
268B		  * %t5<def> = ADD %vreg38<kill>, %vreg51<kill>; GR32Bit:%vreg38,%vreg51
268B		  * %vreg91<def> = LUI 1; GR32Bit:%vreg91
268B		  * %vreg96<def> = DREADPM %vreg91<kill>, 0; GR32Bit:%vreg96,%vreg91
268B		  * BLT <BB#4>, %vreg96<kill>, %zero; GR32Bit:%vreg96
268B		  * %zero<def> = ADDI %zero, 0
268B		  * %zero<def> = ADDI %zero, 0
268B		  * JAL <BB#1>
268B		  * %zero<def> = ADDI %zero, 0
268B		  * %zero<def> = ADDI %zero, 0
484B		%t4<def> = ADD %t5, %zero
484B		  * %vreg54<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg54
484B		  * %vreg55<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg55
484B		  * %vreg56<def> = SRLI %vreg55<kill>, 12; GR32Bit:%vreg56,%vreg55
484B		  * %vreg57<def> = ADD %vreg54<kill>, %vreg56<kill>; GR32Bit:%vreg57,%vreg54,%vreg56
484B		  * %vreg58<def> = ADDI %zero, 12; GR32Bit:%vreg58
484B		  * %vreg59<def> = SRLI %t5, 22; GR32Bit:%vreg59
484B		  * %vreg60<def> = SRLI %t5, 12; GR32Bit:%vreg60
484B		  * %vreg61<def> = ANDI %vreg60<kill>, 15; GR32Bit:%vreg61,%vreg60
484B		  * %vreg62<def> = SRLI %t5, 6; GR32Bit:%vreg62
484B		  * %vreg63<def> = ANDI %vreg62<kill>, 63; GR32Bit:%vreg63,%vreg62
484B		  * %vreg64<def> = ADDI %zero, 832; GR32Bit:%vreg64
484B		  * %vreg65<def> = MUL %vreg59<kill>, %vreg64<kill>; GR32Bit:%vreg65,%vreg59,%vreg64
484B		  * %vreg66<def> = ADDI %zero, 52; GR32Bit:%vreg66
484B		  * %vreg67<def> = MUL %vreg61<kill>, %vreg66<kill>; GR32Bit:%vreg67,%vreg61,%vreg66
484B		  * %vreg68<def> = ADD %vreg67<kill>, %vreg63<kill>; GR32Bit:%vreg68,%vreg67,%vreg63
484B		  * %vreg69<def> = ADD %vreg68<kill>, %vreg65<kill>; GR32Bit:%vreg69,%vreg68,%vreg65
484B		  * %vreg70<def> = MUL %vreg69<kill>, %vreg58<kill>; GR32Bit:%vreg70,%vreg69,%vreg58
484B		  * %t5<def> = ADD %vreg57<kill>, %vreg70<kill>; GR32Bit:%vreg57,%vreg70
484B		  * %vreg93<def> = LUI 2; GR32Bit:%vreg93
484B		  * %vreg97<def> = DREADPM %vreg93<kill>, 0; GR32Bit:%vreg97,%vreg93
484B		  * BLT <BB#4>, %vreg97<kill>, %zero; GR32Bit:%vreg97
484B		  * %zero<def> = ADDI %zero, 0
484B		  * %zero<def> = ADDI %zero, 0
484B		  * JAL <BB#1>
484B		  * %zero<def> = ADDI %zero, 0
484B		  * %zero<def> = ADDI %zero, 0
700B		%t4<def> = ADD %t5, %zero
700B		  * %vreg73<def> = LUI <MCSym="%hi("ga#512")">; GR32Bit:%vreg73
700B		  * %vreg74<def> = LUI <MCSym="%lo("ga#512")">; GR32Bit:%vreg74
700B		  * %vreg75<def> = SRLI %vreg74<kill>, 12; GR32Bit:%vreg75,%vreg74
700B		  * %vreg76<def> = ADD %vreg73<kill>, %vreg75<kill>; GR32Bit:%vreg76,%vreg73,%vreg75
700B		  * %vreg77<def> = ADDI %zero, 12; GR32Bit:%vreg77
700B		  * %vreg78<def> = SRLI %t5, 22; GR32Bit:%vreg78
700B		  * %vreg79<def> = SRLI %t5, 12; GR32Bit:%vreg79
700B		  * %vreg80<def> = ANDI %vreg79<kill>, 15; GR32Bit:%vreg80,%vreg79
700B		  * %vreg81<def> = SRLI %t5, 6; GR32Bit:%vreg81
700B		  * %vreg82<def> = ANDI %vreg81<kill>, 63; GR32Bit:%vreg82,%vreg81
700B		  * %vreg83<def> = ADDI %zero, 832; GR32Bit:%vreg83
700B		  * %vreg84<def> = MUL %vreg78<kill>, %vreg83<kill>; GR32Bit:%vreg84,%vreg78,%vreg83
700B		  * %vreg85<def> = ADDI %zero, 52; GR32Bit:%vreg85
700B		  * %vreg86<def> = MUL %vreg80<kill>, %vreg85<kill>; GR32Bit:%vreg86,%vreg80,%vreg85
700B		  * %vreg87<def> = ADD %vreg86<kill>, %vreg82<kill>; GR32Bit:%vreg87,%vreg86,%vreg82
700B		  * %vreg88<def> = ADD %vreg87<kill>, %vreg84<kill>; GR32Bit:%vreg88,%vreg87,%vreg84
700B		  * %vreg89<def> = MUL %vreg88<kill>, %vreg77<kill>; GR32Bit:%vreg89,%vreg88,%vreg77
700B		  * %t5<def> = ADD %vreg76<kill>, %vreg89<kill>; GR32Bit:%vreg76,%vreg89
700B		  * %vreg95<def> = LUI 3; GR32Bit:%vreg95
700B		  * %vreg98<def> = DREADPM %vreg95<kill>, 0; GR32Bit:%vreg98,%vreg95
700B		  * BLT <BB#4>, %vreg98<kill>, %zero; GR32Bit:%vreg98
700B		  * %zero<def> = ADDI %zero, 0
700B		  * %zero<def> = ADDI %zero, 0
700B		  * JAL <BB#1>
700B		  * %zero<def> = ADDI %zero, 0
700B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#4(12) BB#1(20)
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> %t0<def> = ADDI %t5, <fi#1>
> %ra<def> = COPY %ra
Deleting identity copy.
> SW %ra, %t0<kill>, 0; mem:ST4[%2]
> %t0<def> = LUI 1
> WRITEPM %t0<kill>, %ra, 0
> %t0<def> = LUI 2
> WRITEPM %t0<kill>, %ra, 0
> %t0<def> = LUI 3
> WRITEPM %t0<kill>, %ra, 0
> BLT <BB#4>, %ra, %zero
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#1>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> %t0<def> = LUI 1
> %t0<def> = DREADPM %t0<kill>, 0
> BLT <BB#4>, %t0<kill>, %zero
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#1>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> %t0<def> = LUI 2
> %t0<def> = DREADPM %t0<kill>, 0
> BLT <BB#4>, %t0<kill>, %zero
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#1>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t4<def> = ADD %t5, %zero
> %t0<def> = LUI <MCSym="%hi("ga#512")">
> %t1<def> = LUI <MCSym="%lo("ga#512")">
> %t1<def> = SRLI %t1<kill>, 12
> %t0<def> = ADD %t0<kill>, %t1<kill>
> %t1<def> = ADDI %zero, 12
> %t2<def> = SRLI %t5, 22
> %fp<def> = SRLI %t5, 12
> %fp<def> = ANDI %fp<kill>, 15
> %a0<def> = SRLI %t5, 6
> %a0<def> = ANDI %a0<kill>, 63
> %a1<def> = ADDI %zero, 832
> %t2<def> = MUL %t2<kill>, %a1<kill>
> %a1<def> = ADDI %zero, 52
> %fp<def> = MUL %fp<kill>, %a1<kill>
> %fp<def> = ADD %fp<kill>, %a0<kill>
> %t2<def> = ADD %fp<kill>, %t2<kill>
> %t1<def> = MUL %t2<kill>, %t1<kill>
> %t5<def> = ADD %t0<kill>, %t1<kill>
> %t0<def> = LUI 3
> %t0<def> = DREADPM %t0<kill>, 0
> BLT <BB#4>, %t0<kill>, %zero
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#1>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
1172B	BB#1: derived from LLVM BB %eicas_calculator3.if.else
	    Predecessors according to CFG: BB#0
1180B		%vreg4<def> = LUI 16; GR32Bit:%vreg4
1180B		  * %a5<def> = LUI 0
1180B		  * %a5<def> = SRLI %a5<internal>, 12
1180B		  * ADD %vreg4, %vreg4, %a5; GR32Bit:%vreg4
1180B		  * %vreg2<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg2
1180B		  * %vreg3<def> = LW %vreg2<kill>, 0; mem:LD4[%2] GR32Bit:%vreg3,%vreg2
1180B		  * %vreg99<def> = LUI 1; GR32Bit:%vreg99
1180B		  * WRITEPM %vreg99, %vreg3, 0; GR32Bit:%vreg99,%vreg3
1180B		  * %vreg101<def> = LUI 2; GR32Bit:%vreg101
1180B		  * WRITEPM %vreg101, %vreg3, 0; GR32Bit:%vreg101,%vreg3
1180B		  * %vreg103<def> = LUI 3; GR32Bit:%vreg103
1180B		  * WRITEPM %vreg103, %vreg3, 0; GR32Bit:%vreg103,%vreg3
1180B		  * WRITEPM %vreg99<kill>, %vreg4, 4; GR32Bit:%vreg99,%vreg4
1180B		  * WRITEPM %vreg101<kill>, %vreg4, 4; GR32Bit:%vreg101,%vreg4
1180B		  * WRITEPM %vreg103<kill>, %vreg4, 4; GR32Bit:%vreg103,%vreg4
1180B		  * BLT <BB#3>, %vreg3<kill>, %vreg4<kill>; GR32Bit:%vreg3,%vreg4
1180B		  * %zero<def> = ADDI %zero, 0
1180B		  * %zero<def> = ADDI %zero, 0
1180B		  * JAL <BB#2>
1180B		  * %zero<def> = ADDI %zero, 0
1180B		  * %zero<def> = ADDI %zero, 0
1356B		%vreg100<def> = LUI 1; GR32Bit:%vreg100
1356B		  * %vreg105<def> = DREADPM %vreg100, 0; GR32Bit:%vreg105,%vreg100
1356B		  * %vreg108<def> = DREADPM %vreg100<kill>, 4; GR32Bit:%vreg108,%vreg100
1356B		  * BLT <BB#3>, %vreg105<kill>, %vreg108<kill>; GR32Bit:%vreg105,%vreg108
1356B		  * %zero<def> = ADDI %zero, 0
1356B		  * %zero<def> = ADDI %zero, 0
1356B		  * JAL <BB#2>
1356B		  * %zero<def> = ADDI %zero, 0
1356B		  * %zero<def> = ADDI %zero, 0
1444B		%vreg102<def> = LUI 2; GR32Bit:%vreg102
1444B		  * %vreg106<def> = DREADPM %vreg102, 0; GR32Bit:%vreg106,%vreg102
1444B		  * %vreg109<def> = DREADPM %vreg102<kill>, 4; GR32Bit:%vreg109,%vreg102
1444B		  * BLT <BB#3>, %vreg106<kill>, %vreg109<kill>; GR32Bit:%vreg106,%vreg109
1444B		  * %zero<def> = ADDI %zero, 0
1444B		  * %zero<def> = ADDI %zero, 0
1444B		  * JAL <BB#2>
1444B		  * %zero<def> = ADDI %zero, 0
1444B		  * %zero<def> = ADDI %zero, 0
1532B		%vreg104<def> = LUI 3; GR32Bit:%vreg104
1532B		  * %vreg107<def> = DREADPM %vreg104, 0; GR32Bit:%vreg107,%vreg104
1532B		  * %vreg110<def> = DREADPM %vreg104<kill>, 4; GR32Bit:%vreg110,%vreg104
1532B		  * BLT <BB#3>, %vreg107<kill>, %vreg110<kill>; GR32Bit:%vreg107,%vreg110
1532B		  * %zero<def> = ADDI %zero, 0
1532B		  * %zero<def> = ADDI %zero, 0
1532B		  * JAL <BB#2>
1532B		  * %zero<def> = ADDI %zero, 0
1532B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#2(16) BB#3(16)
> %t0<def> = LUI 16
> %a5<def> = LUI 0
> %a5<def> = SRLI %a5<internal>, 12
> ADD %t0, %t0, %a5
> %t1<def> = ADDI %t5, <fi#1>
> %t1<def> = LW %t1<kill>, 0; mem:LD4[%2]
> %t2<def> = LUI 1
> WRITEPM %t2, %t1, 0
> %fp<def> = LUI 2
> WRITEPM %fp, %t1, 0
> %a0<def> = LUI 3
> WRITEPM %a0, %t1, 0
> WRITEPM %t2<kill>, %t0, 4
> WRITEPM %fp<kill>, %t0, 4
> WRITEPM %a0<kill>, %t0, 4
> BLT <BB#3>, %t1<kill>, %t0<kill>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#2>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t0<def> = LUI 1
> %t1<def> = DREADPM %t0, 0
> %t0<def> = DREADPM %t0<kill>, 4
> BLT <BB#3>, %t1<kill>, %t0<kill>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#2>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t0<def> = LUI 2
> %t1<def> = DREADPM %t0, 0
> %t0<def> = DREADPM %t0<kill>, 4
> BLT <BB#3>, %t1<kill>, %t0<kill>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#2>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %t1<def> = LUI 3
> %t0<def> = DREADPM %t1, 0
> %t1<def> = DREADPM %t1<kill>, 4
> BLT <BB#3>, %t0<kill>, %t1<kill>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#2>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
1804B	BB#2: derived from LLVM BB %eicas_calculator3.if.then2
	    Predecessors according to CFG: BB#1
1200B		%vreg9<def> = LUI 15; GR32Bit:%vreg9
1200B		  * %a5<def> = LUI 4095
1200B		  * %a5<def> = SRLI %a5<internal>, 12
1200B		  * ADD %vreg9, %vreg9, %a5; GR32Bit:%vreg9
1200B		  * %vreg8<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg8
1200B		  * SW %vreg9<kill>, %vreg8<kill>, 0; mem:ST4[%3] GR32Bit:%vreg9,%vreg8
1200B		  * JAL <BB#5>
1200B		  * %zero<def> = ADDI %zero, 0
1200B		  * %zero<def> = ADDI %zero, 0
1868B		JAL <BB#5>
1868B		  * %zero<def> = ADDI %zero, 0
1868B		  * %zero<def> = ADDI %zero, 0
1892B		JAL <BB#5>
1892B		  * %zero<def> = ADDI %zero, 0
1892B		  * %zero<def> = ADDI %zero, 0
1916B		JAL <BB#5>
1916B		  * %zero<def> = ADDI %zero, 0
1916B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#5
> %t0<def> = LUI 15
> %a5<def> = LUI 4095
> %a5<def> = SRLI %a5<internal>, 12
> ADD %t0, %t0, %a5
> %t1<def> = ADDI %t5, <fi#2>
> SW %t0<kill>, %t1<kill>, 0; mem:ST4[%3]
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
1988B	BB#3: derived from LLVM BB %eicas_calculator3.if.else3
	    Predecessors according to CFG: BB#1
1996B		%vreg7<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg7
1996B		  * %vreg5<def> = ADDI %t5, <fi#1>; GR32Bit:%vreg5
1996B		  * %vreg6<def> = LW %vreg5<kill>, 0; mem:LD4[%2] GR32Bit:%vreg6,%vreg5
1996B		  * SW %vreg6<kill>, %vreg7<kill>, 0; mem:ST4[%3] GR32Bit:%vreg6,%vreg7
1996B		  * JAL <BB#5>
1996B		  * %zero<def> = ADDI %zero, 0
1996B		  * %zero<def> = ADDI %zero, 0
2060B		JAL <BB#5>
2060B		  * %zero<def> = ADDI %zero, 0
2060B		  * %zero<def> = ADDI %zero, 0
2084B		JAL <BB#5>
2084B		  * %zero<def> = ADDI %zero, 0
2084B		  * %zero<def> = ADDI %zero, 0
2108B		JAL <BB#5>
2108B		  * %zero<def> = ADDI %zero, 0
2108B		  * %zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#5
> %t0<def> = ADDI %t5, <fi#2>
> %t1<def> = ADDI %t5, <fi#1>
> %t1<def> = LW %t1<kill>, 0; mem:LD4[%2]
> SW %t1<kill>, %t0<kill>, 0; mem:ST4[%3]
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> JAL <BB#5>
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
2180B	BB#4: derived from LLVM BB %eicas_calculator3.if.then
	    Predecessors according to CFG: BB#0
2188B		%vreg10<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg10
2188B		  * SW %zero, %vreg10<kill>, 0; mem:ST4[%3] GR32Bit:%vreg10
2196B		%zero<def> = ADDI %zero, 0
2204B		%zero<def> = ADDI %zero, 0
2212B		%zero<def> = ADDI %zero, 0
	    Successors according to CFG: BB#5
> %t0<def> = ADDI %t5, <fi#2>
> SW %zero, %t0<kill>, 0; mem:ST4[%3]
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
2228B	BB#5: derived from LLVM BB %eicas_calculator3.return
	    Predecessors according to CFG: BB#3 BB#2 BB#4
2236B		%vreg13<def> = ADDI %t5, <fi#0>; GR32Bit:%vreg13
2236B		  * %vreg11<def> = ADDI %t5, <fi#2>; GR32Bit:%vreg11
2236B		  * %vreg12<def> = LW %vreg11<kill>, 0; mem:LD4[%3] GR32Bit:%vreg12,%vreg11
2236B		  * SW %vreg12<kill>, %vreg13<kill>, 0; mem:ST4[%1] GR32Bit:%vreg12,%vreg13
2236B		  * %vreg111<def> = ADDI %zero, 128; GR32Bit:%vreg111
2236B		  * %vreg112<def> = LW %t5, <fi#0>; GR32Bit:%vreg112
2236B		  * WRITECM %vreg111<kill>, %vreg112<kill>, 0; GR32Bit:%vreg111,%vreg112
2236B		  * FDELETE %t4, 0
2236B		  * END 0
2236B		  * %zero<def> = ADDI %zero, 0
2236B		  * %zero<def> = ADDI %zero, 0
2332B		END 0
2332B		  * %zero<def> = ADDI %zero, 0
2332B		  * %zero<def> = ADDI %zero, 0
2356B		END 0
2356B		  * %zero<def> = ADDI %zero, 0
2356B		  * %zero<def> = ADDI %zero, 0
2380B		END 0
2380B		  * %zero<def> = ADDI %zero, 0
2380B		  * %zero<def> = ADDI %zero, 0
> %t0<def> = ADDI %t5, <fi#0>
> %t1<def> = ADDI %t5, <fi#2>
> %t1<def> = LW %t1<kill>, 0; mem:LD4[%3]
> SW %t1<kill>, %t0<kill>, 0; mem:ST4[%1]
> %t0<def> = ADDI %zero, 128
> %t1<def> = LW %t5, <fi#0>
> WRITECM %t0<kill>, %t1<kill>, 0
> FDELETE %t4, 0
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
> END 0
> %zero<def> = ADDI %zero, 0
> %zero<def> = ADDI %zero, 0
********** EMITTING LIVE DEBUG VARIABLES **********
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: eicas_calculator3
current state of mf:# Machine code for function eicas_calculator3: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
  fi#2: size=4, align=4, at location [SP]
Function Live Ins: %ra in %vreg0

BB#0: derived from LLVM BB %eicas_calculator3.entry
    Live Ins: %ra
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * %t0<def> = ADDI %t5, <fi#1>
	  * SW %ra, %t0<kill>, 0; mem:ST4[%2]
	  * %t0<def> = LUI 1
	  * WRITEPM %t0<kill>, %ra, 0
	  * %t0<def> = LUI 2
	  * WRITEPM %t0<kill>, %ra, 0
	  * %t0<def> = LUI 3
	  * WRITEPM %t0<kill>, %ra, 0
	  * BLT <BB#4>, %ra, %zero
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * %t0<def> = LUI 1
	  * %t0<def> = DREADPM %t0<kill>, 0
	  * BLT <BB#4>, %t0<kill>, %zero
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * %t0<def> = LUI 2
	  * %t0<def> = DREADPM %t0<kill>, 0
	  * BLT <BB#4>, %t0<kill>, %zero
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t4<def> = ADD %t5, %zero
	  * %t0<def> = LUI <MCSym="%hi("ga#512")">
	  * %t1<def> = LUI <MCSym="%lo("ga#512")">
	  * %t1<def> = SRLI %t1<kill>, 12
	  * %t0<def> = ADD %t0<kill>, %t1<kill>
	  * %t1<def> = ADDI %zero, 12
	  * %t2<def> = SRLI %t5, 22
	  * %fp<def> = SRLI %t5, 12
	  * %fp<def> = ANDI %fp<kill>, 15
	  * %a0<def> = SRLI %t5, 6
	  * %a0<def> = ANDI %a0<kill>, 63
	  * %a1<def> = ADDI %zero, 832
	  * %t2<def> = MUL %t2<kill>, %a1<kill>
	  * %a1<def> = ADDI %zero, 52
	  * %fp<def> = MUL %fp<kill>, %a1<kill>
	  * %fp<def> = ADD %fp<kill>, %a0<kill>
	  * %t2<def> = ADD %fp<kill>, %t2<kill>
	  * %t1<def> = MUL %t2<kill>, %t1<kill>
	  * %t5<def> = ADD %t0<kill>, %t1<kill>
	  * %t0<def> = LUI 3
	  * %t0<def> = DREADPM %t0<kill>, 0
	  * BLT <BB#4>, %t0<kill>, %zero
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#1>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#4(12) BB#1(20)

BB#1: derived from LLVM BB %eicas_calculator3.if.else
    Predecessors according to CFG: BB#0
	%t0<def> = LUI 16
	  * %a5<def> = LUI 0
	  * %a5<def> = SRLI %a5<internal>, 12
	  * ADD %t0, %t0, %a5
	  * %t1<def> = ADDI %t5, <fi#1>
	  * %t1<def> = LW %t1<kill>, 0; mem:LD4[%2]
	  * %t2<def> = LUI 1
	  * WRITEPM %t2, %t1, 0
	  * %fp<def> = LUI 2
	  * WRITEPM %fp, %t1, 0
	  * %a0<def> = LUI 3
	  * WRITEPM %a0, %t1, 0
	  * WRITEPM %t2<kill>, %t0, 4
	  * WRITEPM %fp<kill>, %t0, 4
	  * WRITEPM %a0<kill>, %t0, 4
	  * BLT <BB#3>, %t1<kill>, %t0<kill>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t0<def> = LUI 1
	  * %t1<def> = DREADPM %t0, 0
	  * %t0<def> = DREADPM %t0<kill>, 4
	  * BLT <BB#3>, %t1<kill>, %t0<kill>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t0<def> = LUI 2
	  * %t1<def> = DREADPM %t0, 0
	  * %t0<def> = DREADPM %t0<kill>, 4
	  * BLT <BB#3>, %t1<kill>, %t0<kill>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	%t1<def> = LUI 3
	  * %t0<def> = DREADPM %t1, 0
	  * %t1<def> = DREADPM %t1<kill>, 4
	  * BLT <BB#3>, %t0<kill>, %t1<kill>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	  * JAL <BB#2>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#2(16) BB#3(16)

BB#2: derived from LLVM BB %eicas_calculator3.if.then2
    Predecessors according to CFG: BB#1
	%t0<def> = LUI 15
	  * %a5<def> = LUI 4095
	  * %a5<def> = SRLI %a5<internal>, 12
	  * ADD %t0, %t0, %a5
	  * %t1<def> = ADDI %t5, <fi#2>
	  * SW %t0<kill>, %t1<kill>, 0; mem:ST4[%3]
	  * JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

BB#3: derived from LLVM BB %eicas_calculator3.if.else3
    Predecessors according to CFG: BB#1
	%t0<def> = ADDI %t5, <fi#2>
	  * %t1<def> = ADDI %t5, <fi#1>
	  * %t1<def> = LW %t1<kill>, 0; mem:LD4[%2]
	  * SW %t1<kill>, %t0<kill>, 0; mem:ST4[%3]
	  * JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	JAL <BB#5>
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

BB#4: derived from LLVM BB %eicas_calculator3.if.then
    Predecessors according to CFG: BB#0
	%t0<def> = ADDI %t5, <fi#2>
	  * SW %zero, %t0<kill>, 0; mem:ST4[%3]
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
	%zero<def> = ADDI %zero, 0
    Successors according to CFG: BB#5

BB#5: derived from LLVM BB %eicas_calculator3.return
    Predecessors according to CFG: BB#3 BB#2 BB#4
	%t0<def> = ADDI %t5, <fi#0>
	  * %t1<def> = ADDI %t5, <fi#2>
	  * %t1<def> = LW %t1<kill>, 0; mem:LD4[%3]
	  * SW %t1<kill>, %t0<kill>, 0; mem:ST4[%1]
	  * %t0<def> = ADDI %zero, 128
	  * %t1<def> = LW %t5, <fi#0>
	  * WRITECM %t0<kill>, %t1<kill>, 0
	  * FDELETE %t4, 0
	  * END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0
	END 0
	  * %zero<def> = ADDI %zero, 0
	  * %zero<def> = ADDI %zero, 0

# End machine code for function eicas_calculator3.

lowering frame index for func eicas_calculator3:1 TO VAL:4
lowering frame index for func eicas_calculator3:1 TO VAL:4
lowering frame index for func eicas_calculator3:2 TO VAL:8
lowering frame index for func eicas_calculator3:2 TO VAL:8
lowering frame index for func eicas_calculator3:1 TO VAL:4
lowering frame index for func eicas_calculator3:2 TO VAL:8
lowering frame index for func eicas_calculator3:0 TO VAL:0
lowering frame index for func eicas_calculator3:2 TO VAL:8
lowering frame index for func eicas_calculator3:0 TO VAL:0
