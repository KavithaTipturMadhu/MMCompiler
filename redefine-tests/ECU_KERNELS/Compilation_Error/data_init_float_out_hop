Args: /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/opt -debug --load /home/arka/Workspace/work/Git_Compiler_Repo/redefine-tests/ECU_KERNELS/../../..//MM_Compiler_latest/build/Release+Asserts/bin/../lib/HyperOpCreationPass.so --HyperOpCreationPass -S ./Compilation_Error/data_init_float.ll -o ./Compilation_Error/data_init_float_HyOpPass.ll 

Features:
CPU:REDEFINE

Found cycles?0

-----------
Partitioning function:data_init

-------
Acquiring bb entry
entered end hop for function data_init
Adding basic blocks for traversal in a breadth biased order for function data_init
added to succ list:
adding to creation map bbargs of size 1

-----------
Partitioning function:redefine_start

-------
Acquiring bb entry
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:for.cond,
distance of for.cond to exit 3

-------
Acquiring bb for.cond
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:for.body,for.end,
distance of for.body to exit 4
distance of for.end to exit 1

-------
Acquiring bb for.body
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:newName0,
distance of for.end to exit 1
distance of newName0 to exit 4

-------
Acquiring bb newName0
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:newName01,
distance of for.end to exit 1
distance of newName01 to exit 5

-------
Acquiring bb newName01
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:for.inc,
distance of for.end to exit 1
distance of for.inc to exit 5

-------
Acquiring bb for.inc
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:didn't add for.cond

distance of for.end to exit 1

-------
Acquiring bb for.end
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:
distance of for.end to exit 1

-------
Acquiring bb for.end
entered end hop for function redefine_start
Adding basic blocks for traversal in a breadth biased order for function redefine_start
added to succ list:
adding to creation map bbargs of size 4
before partitioning:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{}
-----------Creating HyperOps from partitioned functions-----------
added to traversallist:entry
added to traversallist:newName0
added to traversallist:newName01
added to traversallist:for.end
now at func:entry

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:entry from parent:redefine_start

--------
Acquired bb:for.cond from parent:redefine_start

--------
Acquired bb:for.body from parent:redefine_start
created func:redefine_start1
now at func:newName0
now at func:newName01

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:newName01 from parent:redefine_start

--------
Acquired bb:for.inc from parent:redefine_start
created func:redefine_start2
now at func:for.end

-----------Creating a new HyperOp for function:redefine_start-----------

--------
Acquired bb:for.end from parent:redefine_start
created func:redefine_start3
now at func:entry

-----------Creating a new HyperOp for function:data_init-----------
newName0,
--------
Acquired bb:entry from parent:data_init

--------
Acquired bb:newName0 from parent:redefine_start
created func:data_init4
before patching stuff:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %redefine_start2.for.inc, %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %redefine_start1.for.body, %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %redefine_start1.for.cond, %for.cond
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i32, align 4
  %1 = alloca i32, align 4
  %2 = load i32* @redefine_in_placeholder, align 4
  store i32 %2, i32* %1, align 4
  store i32 0, i32* %0, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %3 = load i32* %0, align 4
  %4 = icmp slt i32 %3, 25
  br i1 %4, label %redefine_start1.for.body, label %for.end

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %5 = load i32* %1, align 4
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %for.cond

redefine_start2.return:                           ; No predecessors!
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca i32, align 4
  store i32 %0, i32* %1, align 4
  %2 = bitcast i32* %1 to float*
  %3 = load float* %2, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}

----------Adding dependences across created HyperOps----------

-----------Patching created function redefine_start1--------------
accumulated bbs:
entry,for.cond,for.body,

----------Adding consumed by metadata----------

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function redefine_start1, module:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %redefine_start1.for.body, %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %redefine_start1.for.cond, %for.cond
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i32, align 4
  %1 = alloca i32, align 4
  %2 = load i32* @redefine_in_placeholder, align 4
  store i32 %2, i32* %1, align 4
  store i32 0, i32* %0, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %3 = load i32* %0, align 4
  %4 = icmp slt i32 %3, 25
  br i1 %4, label %redefine_start1.for.body, label %for.end

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %5 = load i32* %1, align 4
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.for.inc
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca i32, align 4
  store i32 %0, i32* %1, align 4
  %2 = bitcast i32* %1 to float*
  %3 = load float* %2, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}

-----------Patching created function redefine_start2--------------
accumulated bbs:
newName01,for.inc,

----------Adding consumed by metadata----------
cloned inst second:  store i32 0, i32* %i, align 4
producer function:redefine_start1
how many clones?1
added metadata on instruction that belongs to parent redefine_start1 and is mapped to slot 0 when the function has 2 and is of type:1:  %0 = alloca i32, align 4, !ConsumedBy !8
  %call = call float @data_init(i32 %2)
cloned inst second:  %1 = load float* %0, align 4
producer function:data_init4
how many clones?1
added metadata on instruction that belongs to parent data_init4 and is mapped to slot 1 when the function has 2 and is of type:1:  %1 = alloca float, align 4, !ConsumedBy !8

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %for.body, label %for.end
target bb:
for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

producer of data:redefine_start and its clone?redefine_start1, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function redefine_start2, module:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %redefine_start1.for.body, %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %redefine_start1.for.cond, %for.cond
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i1, align 4, !Controls !8
  %1 = alloca i32, align 4, !ConsumedBy !10
  %2 = alloca i32, align 4
  %3 = load i32* @redefine_in_placeholder, align 4
  store i32 %3, i32* %2, align 4
  store i32 0, i32* %1, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %4 = load i32* %1, align 4
  %5 = icmp slt i32 %4, 25
  store i1 %5, i1* %0, align 4
  br i1 %5, label %redefine_start1.for.body, label %for.end

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %6 = load i32* %2, align 4
  br label %newName0

redefine_start1.return:                           ; No predecessors!
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.for.inc
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca float, align 4, !ConsumedBy !12
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* %1, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !2, metadata !"1"}
!10 = metadata !{metadata !11}
!11 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!12 = metadata !{metadata !13}
!13 = metadata !{metadata !2, metadata !"LocalReference", i32 1}

-----------Patching created function redefine_start3--------------
accumulated bbs:
for.end,

----------Adding consumed by metadata----------

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:0

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??0

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
Adding sync edge to hyperop redefine_start3
after patching function redefine_start3, module:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %redefine_start1.for.body, %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i1, align 4, !Sync !8
  %1 = alloca i1, align 4, !Controls !10
  %2 = alloca i32, align 4, !ConsumedBy !12
  %3 = alloca i32, align 4
  %4 = load i32* @redefine_in_placeholder, align 4
  store i32 %4, i32* %3, align 4
  store i32 0, i32* %2, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %5 = load i32* %2, align 4
  %6 = icmp slt i32 %5, 25
  store i1 %6, i1* %1, align 4
  br i1 %6, label %redefine_start1.for.body, label %redefine_start1.return

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %7 = load i32* %3, align 4
  br label %newName0

redefine_start1.return:                           ; preds = %redefine_start1.for.cond
  store i1 true, i1* %0, align 4
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.for.inc
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca float, align 4, !ConsumedBy !14
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* %1, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !4}
!10 = metadata !{metadata !11}
!11 = metadata !{metadata !2, metadata !"1"}
!12 = metadata !{metadata !13}
!13 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!14 = metadata !{metadata !15}
!15 = metadata !{metadata !2, metadata !"LocalReference", i32 1}

-----------Patching created function data_init4--------------
accumulated bbs:
entry,

----------Adding consumed by metadata----------
cloned inst second:  %Array_test = alloca i32, align 4
producer function:redefine_start1
how many clones?1
added metadata on instruction that belongs to parent redefine_start1 and is mapped to slot 0 when the function has 1 and is of type:0:  %3 = alloca i32, align 4, !ConsumedBy !14

----------Dealing with conditional branches from other HyperOps----------
number of conditional jump sources:1
working on conditional branch instruction:  br i1 %cmp, label %for.body, label %for.end
target bb:
newName0:                                         ; preds = %redefine_start1.for.body, %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

producer of data:redefine_start and its clone?redefine_start1, is it static?1

----------Dealing with unconditional branches from other HyperOps----------
number of unconditional jump sources:1
what was callsite size earlier??1

----------Adding a predicate from entry hyperop if there are no incoming edges to the hyperop----------
after patching function data_init4, module:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i1, align 4, !Sync !8
  %1 = alloca i1, align 4, !Controls !10
  %2 = alloca i32, align 4, !ConsumedBy !13
  %3 = alloca i32, align 4, !ConsumedBy !15
  %4 = load i32* @redefine_in_placeholder, align 4
  store i32 %4, i32* %3, align 4
  store i32 0, i32* %2, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %5 = load i32* %2, align 4
  %6 = icmp slt i32 %5, 25
  store i1 %6, i1* %1, align 4
  br i1 %6, label %redefine_start1.for.body, label %redefine_start1.return

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %7 = load i32* %3, align 4
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.for.body, %redefine_start1.for.cond
  store i1 true, i1* %0, align 4
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.for.inc
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca float, align 4, !ConsumedBy !17
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* %1, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !4}
!10 = metadata !{metadata !11, metadata !12}
!11 = metadata !{metadata !2, metadata !"1"}
!12 = metadata !{metadata !6, metadata !"1"}
!13 = metadata !{metadata !14}
!14 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!15 = metadata !{metadata !16}
!16 = metadata !{metadata !6, metadata !"Scalar", i32 0}
!17 = metadata !{metadata !18}
!18 = metadata !{metadata !2, metadata !"LocalReference", i32 1}

----------Adding sync edges to dangling HyperOps----------
added sync edge between redefine_start2 and redefine_start3

-----------Re-routing sync edges from end hyperop to the newly created end HyperOp-----------
whats in module now?; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

; Function Attrs: nounwind
define float @data_init(i32 %x) #0 {
entry:
  %x.addr = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  %0 = bitcast i32* %x.addr to float*
  %1 = load float* %0, align 4
  ret float %1
}

; Function Attrs: nounwind
define void @redefine_start() #0 {
entry:
  %i = alloca i32, align 4
  %Array_test = alloca i32, align 4
  %0 = load i32* @redefine_in_placeholder, align 4
  store i32 %0, i32* %Array_test, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 25
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32* %Array_test, align 4
  br label %newName0

newName0:                                         ; preds = %for.body
  %call = call float @data_init(i32 %2)
  br label %newName01

newName01:                                        ; preds = %newName0
  %3 = load i32* %i, align 4
  %arrayidx = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %call, float* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %newName01
  %4 = load i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i1, align 4, !Sync !8
  %1 = alloca i1, align 4, !Controls !10
  %2 = alloca i32, align 4, !ConsumedBy !13
  %3 = alloca i32, align 4, !ConsumedBy !15
  %4 = load i32* @redefine_in_placeholder, align 4
  store i32 %4, i32* %3, align 4
  store i32 0, i32* %2, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %5 = load i32* %2, align 4
  %6 = icmp slt i32 %5, 25
  store i1 %6, i1* %1, align 4
  br i1 %6, label %redefine_start1.for.body, label %redefine_start1.return

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %7 = load i32* %3, align 4
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.for.body, %redefine_start1.for.cond
  store i1 true, i1* %0, align 4
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1, !Sync !8
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.for.inc
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca float, align 4, !ConsumedBy !17
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* %1, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !4}
!10 = metadata !{metadata !11, metadata !12}
!11 = metadata !{metadata !2, metadata !"1"}
!12 = metadata !{metadata !6, metadata !"1"}
!13 = metadata !{metadata !14}
!14 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!15 = metadata !{metadata !16}
!16 = metadata !{metadata !6, metadata !"Scalar", i32 0}
!17 = metadata !{metadata !18}
!18 = metadata !{metadata !2, metadata !"LocalReference", i32 1}

-----------Deleting unused functions-----------
deleting contents of function:data_init
deleting contents of function:redefine_start
Final module contents:; ModuleID = './Compilation_Error/data_init_float.ll'
target datalayout = "E-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-n32"
target triple = "redefine"

@redefine_in_placeholder = common global i32 0, align 4
@redefine_out_array = common global [25 x float] zeroinitializer, align 4

define void @redefine_start1() {
redefine_start1.entry:
  %0 = alloca i1, align 4, !Sync !8
  %1 = alloca i1, align 4, !Controls !10
  %2 = alloca i32, align 4, !ConsumedBy !13
  %3 = alloca i32, align 4, !ConsumedBy !15
  %4 = load i32* @redefine_in_placeholder, align 4
  store i32 %4, i32* %3, align 4
  store i32 0, i32* %2, align 4
  br label %redefine_start1.for.cond

redefine_start1.for.cond:                         ; preds = %redefine_start1.entry
  %5 = load i32* %2, align 4
  %6 = icmp slt i32 %5, 25
  store i1 %6, i1* %1, align 4
  br i1 %6, label %redefine_start1.for.body, label %redefine_start1.return

redefine_start1.for.body:                         ; preds = %redefine_start1.for.cond
  %7 = load i32* %3, align 4
  br label %redefine_start1.return

redefine_start1.return:                           ; preds = %redefine_start1.for.body, %redefine_start1.for.cond
  store i1 true, i1* %0, align 4
  ret void
}

define void @redefine_start2(i32*, float*) {
redefine_start2.newName01:
  %2 = load float* %1, !Sync !8
  %3 = load i32* %0, align 4
  %4 = getelementptr inbounds [25 x float]* @redefine_out_array, i32 0, i32 %3
  store float %2, float* %4, align 4
  br label %redefine_start2.for.inc

redefine_start2.for.inc:                          ; preds = %redefine_start2.newName01
  %5 = load i32* %0, align 4
  %6 = add nsw i32 %5, 1
  store i32 %6, i32* %0, align 4
  br label %redefine_start2.return

redefine_start2.return:                           ; preds = %redefine_start2.for.inc
  ret void
}

define void @redefine_start3() {
redefine_start3.for.end:
  br label %redefine_start3.return

redefine_start3.return:                           ; preds = %redefine_start3.for.end
  ret void
}

define void @data_init4(i32 inreg) {
data_init4.entry:
  %1 = alloca float, align 4, !ConsumedBy !17
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = bitcast i32* %2 to float*
  %4 = load float* %3, align 4
  store float %4, float* %1, align 4
  br label %data_init4.return

data_init4.return:                                ; preds = %data_init4.entry
  ret void
}

!redefine.annotations = !{!0, !1, !2, !3, !4, !5, !6, !7}

!0 = metadata !{metadata !"HyperOp", void ()* @redefine_start1, metadata !"Static"}
!1 = metadata !{metadata !"Entry", metadata !0}
!2 = metadata !{metadata !"HyperOp", void (i32*, float*)* @redefine_start2, metadata !"Static"}
!3 = metadata !{metadata !"Intermediate", metadata !2}
!4 = metadata !{metadata !"HyperOp", void ()* @redefine_start3, metadata !"Static"}
!5 = metadata !{metadata !"Exit", metadata !4}
!6 = metadata !{metadata !"HyperOp", void (i32)* @data_init4, metadata !"Static"}
!7 = metadata !{metadata !"Intermediate", metadata !6}
!8 = metadata !{metadata !9}
!9 = metadata !{metadata !4}
!10 = metadata !{metadata !11, metadata !12}
!11 = metadata !{metadata !2, metadata !"1"}
!12 = metadata !{metadata !6, metadata !"1"}
!13 = metadata !{metadata !14}
!14 = metadata !{metadata !2, metadata !"LocalReference", i32 0}
!15 = metadata !{metadata !16}
!16 = metadata !{metadata !6, metadata !"Scalar", i32 0}
!17 = metadata !{metadata !18}
!18 = metadata !{metadata !2, metadata !"LocalReference", i32 1}
